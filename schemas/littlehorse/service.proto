syntax = "proto3";

package littlehorse;

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "common_wfspec.proto";
import "common_enums.proto";
import "object_id.proto";
import "variable.proto";
import "external_event.proto";
import "wf_run.proto";
import "node_run.proto";
import "task_run.proto";
import "user_tasks.proto";
import "wf_spec.proto";
import "task_def.proto";
import "acls.proto";
import "workflow_event.proto";

option go_package = ".;model";
option java_multiple_files = true;
option java_package = "io.littlehorse.sdk.common.proto";
option csharp_namespace = "LittleHorse.Common.Proto";

service LittleHorse {
  // Creates a TaskDef.
  rpc PutTaskDef(PutTaskDefRequest) returns (TaskDef) {}

  // Gets a TaskDef.
  rpc GetTaskDef(TaskDefId) returns (TaskDef) {}

  // Gets the registered task worker group associated with a specific TaskDef.
  rpc GetTaskWorkerGroup (TaskDefId) returns (TaskWorkerGroup) {}

  // Creates an ExternalEventDef.
  rpc PutExternalEventDef(PutExternalEventDefRequest) returns (ExternalEventDef) {}

  // Gets an ExternalEventDef.
  rpc GetExternalEventDef(ExternalEventDefId) returns (ExternalEventDef) {}

  // EXPERIMENTAL: Creates a WorkflowEventDef.
  rpc PutWorkflowEventDef(PutWorkflowEventDefRequest) returns (WorkflowEventDef) {}

  // Creates a WfSpec.
  rpc PutWfSpec(PutWfSpecRequest) returns (WfSpec) {}

  // Gets a WfSpec.
  rpc GetWfSpec(WfSpecId) returns (WfSpec) {}

  // Returns the latest WfSpec with a specified name (and optionally a specified Major Version).
  rpc GetLatestWfSpec(GetLatestWfSpecRequest) returns (WfSpec) {}

  /*
   * EXPERIMENTAL: Migrates all WfRun's from one version of a WfSpec onto a newer version of the
   * same WfSpec. This is useful for long-running WfRun's (eg. a 60-day marketing campaign) where
   * you must update WfRun's that are in the RUNNING state rather than allowing them to run to
   * completion.
   *
   * As of 0.7.2, this feature is only partially implemented.
   */
  rpc MigrateWfSpec(MigrateWfSpecRequest) returns (WfSpec) {}

  // Creates a UserTaskDef.
  rpc PutUserTaskDef(PutUserTaskDefRequest) returns (UserTaskDef) {}

  /* Gets a specific UserTaskDef.
   *
   * This RPC is highly useful for applications built around
   * User Tasks. For example, a UI that dynamically displays form fields based on the User Task
   * might first receive a UserTaskRun, then use that UserTaskRun to look up the UserTaskDef.
   * The frontend would inspect the UserTaskDef and display a form field on the browser page
   * for each field in the UserTaskDef.
   */
  rpc GetUserTaskDef(UserTaskDefId) returns (UserTaskDef) {}

  // Returns the most recent UserTaskDef with a specific name.
  rpc GetLatestUserTaskDef(GetLatestUserTaskDefRequest) returns (UserTaskDef) {}

  // Runs a WfSpec to create a WfRun.
  rpc RunWf(RunWfRequest) returns (WfRun) {}

  // Gets a WfRun. Although useful for development and debugging, this RPC is not often
  // used by applications.
  rpc GetWfRun(WfRunId) returns (WfRun) {}

  // Loads a specific UserTaskRun. It includes information about to whom the UserTask is
  // currently assigned, history of assignments and reassignments, and any context for that
  // UserTaskRun which is specific to the WfRun.
  rpc GetUserTaskRun(UserTaskRunId) returns (UserTaskRun) {}

  // Change the ownership of a UserTaskRun to a new userId, userGroup, or both. The
  // action will be reflected in your next call to SearchUserTaskRun. This RPC is useful for
  // applications that are using User Tasks to build an internal task-list and wish to
  // administer the tasks.
  rpc AssignUserTaskRun(AssignUserTaskRunRequest) returns (google.protobuf.Empty) {}

  // Completes a UserTaskRun. Includes the results of the UserTaskRun, the UserTaskRun Id, and
  // the userId of the user who completes the UserTaskRun. Results in the UserTask NodeRun being
  // completed, and unblocks the associated ThreadRun in the WfRun.
  //
  // This RPC is highly useful for applications built around a WfSpec that uses USER_TASK nodes.
  rpc CompleteUserTaskRun(CompleteUserTaskRunRequest) returns (google.protobuf.Empty) {}

  // Cancels a UserTaskRun. This will result in an EXCEPTION being propagated to the WfRun.
  rpc CancelUserTaskRun(CancelUserTaskRunRequest) returns (google.protobuf.Empty) {}

  // Lists all UserTaskRun's for a specific WfRun. Can be useful when using a WfRun
  // to model an entity.
  rpc ListUserTaskRuns(ListUserTaskRunRequest) returns (UserTaskRunList) {}

  // Gets a specific NodeRun.
  rpc GetNodeRun(NodeRunId) returns (NodeRun) {}

  // Lists all NodeRun's for a specific WfRun.
  rpc ListNodeRuns(ListNodeRunsRequest) returns (NodeRunList) {}

  // Gets a specific TaskRun.
  rpc GetTaskRun(TaskRunId) returns (TaskRun) {}

  // Lists all TaskRun's for a specific WfRun.
  rpc ListTaskRuns(ListTaskRunsRequest) returns (TaskRunList) {}

  // Get the value of a specific Variable. When using a WfRun to model an entity, this
  // RPC is useful for retrieving information. It is equivalent to looking up the value of a
  // column for a specific row in a SQL table.
  rpc GetVariable(VariableId) returns (Variable) {}

  // List all Variables from a WfRun.
  rpc ListVariables(ListVariablesRequest) returns (VariableList) {}

  // Post an ExternalEvent. This RPC is highly useful for
  rpc PutExternalEvent(PutExternalEventRequest) returns (ExternalEvent) {}

  // Get a specific ExternalEvent.
  rpc GetExternalEvent(ExternalEventId) returns (ExternalEvent) {}

  // Waits for a WorkflowEvent to be thrown by a given WfRun. Returns immediately if a matching
  // WorkflowEvent has already been thrown; throws a DEADLINE_EXCEEDED error if the WorkflowEvent
  // is not thrown before the deadline specified by the client.
  //
  // To specify the deadline, the client should use GRPC deadlines.
  rpc AwaitWorkflowEvent(AwaitWorkflowEventRequest) returns (WorkflowEvent) {}

  // List ExternalEvent's for a specific WfRun.
  rpc ListExternalEvents(ListExternalEventsRequest) returns (ExternalEventList) {}

  // Search for WfRun's. This RPC is highly useful for applications that store data
  // in LittleHorse and need to find a specific WfRun based on certain indexed fields.
  rpc SearchWfRun(SearchWfRunRequest) returns (WfRunIdList) {}

  // Search for NodeRun's. This RPC is useful for monitoring and finding bugs in
  // your workflows or Task Workers.
  rpc SearchNodeRun(SearchNodeRunRequest) returns (NodeRunIdList) {}

  // Search for TaskRun's. This RPC is useful for finding bugs in your Task Workers.
  rpc SearchTaskRun(SearchTaskRunRequest) returns (TaskRunIdList) {}

  // Search for UserTaskRun's. This RPC is highly useful for applications that connect
  // human end-users to LittleHorse: it enables you to find all tasks assigned to a specific
  // person or group of people.
  rpc SearchUserTaskRun(SearchUserTaskRunRequest) returns (UserTaskRunIdList) {}

  // Search for Variable's. This RPC is highly useful for applications that store data
  // in LittleHorse and need to find a specific WfRun based on certain indexed fields.
  rpc SearchVariable(SearchVariableRequest) returns (VariableIdList) {}

  // Search for ExternalEvent's.
  rpc SearchExternalEvent(SearchExternalEventRequest) returns (ExternalEventIdList) {}

  // Search for TaskDef's.
  rpc SearchTaskDef(SearchTaskDefRequest) returns (TaskDefIdList) {}

  // Search for UserTaskDef's.
  rpc SearchUserTaskDef(SearchUserTaskDefRequest) returns (UserTaskDefIdList) {}

  // Search for WfSpec's.
  rpc SearchWfSpec(SearchWfSpecRequest) returns (WfSpecIdList) {}

  // Search for ExternalEventDef's.
  rpc SearchExternalEventDef(SearchExternalEventDefRequest) returns (ExternalEventDefIdList) {}

  // Search for all available TenantIds for current Principal
  rpc SearchTenant(SearchTenantRequest) returns (TenantIdList) {}

  //
  rpc SearchPrincipal(SearchPrincipalRequest) returns (PrincipalIdList) {}

  // Used by the Task Worker to:
  // 1. Tell the LH Server that the Task Worker has joined the Task Worker Group.
  // 2. Receive the assignemnt of LH Server's to poll from.
  // Generally, you won't use this request manually.
  rpc RegisterTaskWorker(RegisterTaskWorkerRequest) returns (RegisterTaskWorkerResponse) {}
  // Used by Task Workers to listen for TaskRuns on the Task Queue. Generally, you won't
  // use this RPC manually.
  rpc PollTask(stream PollTaskRequest) returns (stream PollTaskResponse) {}
  // Used by Task Workers to report the result of a TaskRun. Generally, you won't use
  // this rpc manually.
  rpc ReportTask(ReportTaskRun) returns (google.protobuf.Empty) {}

  // Move a WfRun or a specific ThreadRun in that WfRun to the HALTED state.
  rpc StopWfRun(StopWfRunRequest) returns (google.protobuf.Empty) {}
  // Resumes a WfRun or a specific ThreadRun of a WfRun.
  rpc ResumeWfRun(ResumeWfRunRequest) returns (google.protobuf.Empty) {}
  // Rescues a failed ThreadRun (in the ERROR state only) by restarting it from 
  // the point of failure. Useful if a bug in Task Worker implementation caused
  // a WfRun to fail and you did not have a FailureHandler for that NodeRun.
  //
  // The specified `ThreadRun` must be in a state where it's latest `NodeRun` is: <br/>
  // - In the `ERROR` state.<br/>
  // - Has no `FailureHandler` `ThreadRun`s <br/>
  // - The parent `ThreadRun`, or any parent of the parent, has not handled the `Failure`
  // yet.
  //
  // If that is not true, then the `ThreadRun` cannot be rescued and the request
  // will return `FAILED_PRECONDITION`.
  rpc RescueThreadRun(RescueThreadRunRequest) returns (WfRun) {}

  // Deletes a WfRun. The WfRun cannot be in the RUNNING state.
  rpc DeleteWfRun(DeleteWfRunRequest) returns (google.protobuf.Empty) {}
  // Deletes a TaskDef.
  rpc DeleteTaskDef(DeleteTaskDefRequest) returns (google.protobuf.Empty) {}
  // Deletes a WfSpec.
  rpc DeleteWfSpec(DeleteWfSpecRequest) returns (google.protobuf.Empty) {}
  // Deletes a UserTaskDef.
  rpc DeleteUserTaskDef(DeleteUserTaskDefRequest) returns (google.protobuf.Empty) {}
  // Deletes an ExternalEventDef.
  rpc DeleteExternalEventDef(DeleteExternalEventDefRequest) returns (google.protobuf.Empty) {}
  // Deletes a `Principal`. Fails with `FAILED_PRECONDITION` if the specified `Principal`
  // is the last remaining `Principal` with admin permissions. Admin permissions are defined
  // as having the `global_acls` of `ALL_ACTIONS` over the `ACL_ALL_RESOURCES` scope.
  rpc DeletePrincipal(DeletePrincipalRequest) returns (google.protobuf.Empty) {}

  // Returns TaskDef Metrics for a specific TaskDef and a specific time window.
  rpc GetTaskDefMetricsWindow(TaskDefMetricsQueryRequest) returns (TaskDefMetrics) {}
  // Returns WfSpec Metrics for a specific WfSpec and a specific time window.
  rpc GetWfSpecMetricsWindow(WfSpecMetricsQueryRequest) returns (WfSpecMetrics) {}
  // Returns a list of TaskDef Metrics Windows.
  rpc ListTaskDefMetrics(ListTaskMetricsRequest) returns (ListTaskMetricsResponse) {}
  // Returns a list of WfSpec Metrics Windows.
  rpc ListWfSpecMetrics(ListWfMetricsRequest) returns (ListWfMetricsResponse) {}

  // EXPERIMENTAL: Creates another Tenant in the LH Server.
  rpc PutTenant(PutTenantRequest) returns (Tenant) {}

  // EXPERIMENTAL: Gets a Tenant from the LH Server.
  rpc GetTenant(TenantId) returns (Tenant) {}

  // EXPERIMENTAL: Creates an Principal.
  rpc PutPrincipal(PutPrincipalRequest) returns (Principal) {}

  // Returns the Principal of the caller.
  rpc Whoami(google.protobuf.Empty) returns (Principal) {}

  // Gets the version of the LH Server.
  rpc GetServerVersion(google.protobuf.Empty) returns (ServerVersionResponse) {}
}

// Returns the UserTaskDef with a given name and the highest version number.
message GetLatestUserTaskDefRequest {
  // The name of the UserTaskDef to search for.
  string name = 1;
}

// Creates a WfSpec. Generally, this request is generated by the Workflow object in
// our various SDK's.
message PutWfSpecRequest {
  // The name of the resulting WfSpec.
  string name = 1;
  reserved 2, 3, 4;

  // Map from name the ThreadSpec.
  map<string, ThreadSpec> thread_specs = 5;

  // The name of the ThreadSpec to be used as the workflow entrypoint.
  string entrypoint_thread_name = 6;

  // Optional policy to determine how long a WfRun is retained in the data store after
  // it is completed or terminated.
  optional WorkflowRetentionPolicy retention_policy = 8;

  // Parent WfSpec Reference. If this is set, then all WfRun's for this WfSpec *MUST* be
  // Child WfRun's of the specified WfSpec.
  optional WfSpec.ParentWfSpecReference parent_wf_spec = 9;

  // Configures the behavior of this individual request. Can be used to prevent
  // breaking changes to the WfSpec, prevent any changes to the WfSpec, or allow
  // all changes to the WfSpec.
  AllowedUpdateType allowed_updates = 10;
}

// This enum controls the behavior of a PutWfSpecRequest when a WfSpec with the same
// name previously exists.
enum AllowedUpdateType {
  // Allows any update: both minor (revsion) changes and breaking (majorVersion) changes
  // are accepted
  ALL_UPDATES = 0;

  // Allows only backwards-compatible changes that do not change the required input variables
  // or the searchable variables in the WfSpec.
  MINOR_REVISION_UPDATES = 1;

  // Rejects any changes to the WfSpec.
  NO_UPDATES = 2;
}

// Creates a TaskDef.
message PutTaskDefRequest {
  // The name of the TaskDef to create.
  string name = 1;

  // Variables required to execute the TaskDef. Normally, these are automatically
  // generated by the Task Worker SDK.
  repeated VariableDef input_vars = 2;
}

// EXPERIMENTAL: Creates a WorkflowEventDef
message PutWorkflowEventDefRequest {
  string name = 1;
  VariableType type = 2;
}

// Creates a UserTaskDef.
message PutUserTaskDefRequest {
  // The name of the UserTaskDef to create.
  string name = 1;

  // The fields that should be presented to the user on the screen in order to fill
  // out the User Task. Note that these fields also define a data contract for the
  // result of the UserTaskDef.
  repeated UserTaskField fields = 2;

  // Optional metadata field to store user-defined data. Does not impact workflow
  // execution. Fine to store up to a few KB of text here.
  optional string description = 3;
}

// Field to create an ExternalEventDef.
message PutExternalEventDefRequest {
  // The name of the resulting ExternalEventDef.
  string name = 1;

  // Policy to determine how long an ExternalEvent is retained after creation if it
  // is not yet claimed by a WfRun. Note that once a WfRun has been matched with the
  // ExternalEvent, the ExternalEvent is deleted if/when that WfRun is deleted.
  // If not set, then ExternalEvent's are not deleted if they are not matched with
  // a WfRun.
  //
  // A future version of LittleHorse will allow changing the retention_policy, which
  // will trigger a cleanup of old `ExternalEvent`s.
  ExternalEventRetentionPolicy retention_policy = 2;
}

// Request used to create an ExternalEvent.
message PutExternalEventRequest {
  // The ID of the WfRun that this Event is sent to.
  WfRunId wf_run_id = 1;

  // The ID of the ExternalEventDef that this event implements.
  ExternalEventDefId external_event_def_id = 2;

  // Note that an ExternalEventDefId is a three-part ID:
  // 1. WfRunId
  // 2. ExternalEventDef Name
  // 3. A guid
  // The guid from part 3) can be optionally provided to the PutExternalEventRequest
  // in order to make it idempotent. It is a best practice to do so.
  optional string guid = 3;

  // The content of this event.
  VariableValue content = 5;

  // Optionally specify that this ExternalEvent may only be claimed by a specific ThreadRun.
  optional int32 thread_run_number = 6;

  // Optionally specify that this ExternalEvent may only be claimed by a specific NodeRun.
  // In order for this to be set, you must also set thread_run_number.
  optional int32 node_run_position = 7;
  reserved 4, 8;
}

// Deletes an ExternalEvent.
message DeleteExternalEventRequest {
  // The ID of the ExternalEvent to delete.
  ExternalEventId id = 1;
}

// Deletes a WfRun.
message DeleteWfRunRequest {
  // The ID of the WfRun to delete.
  WfRunId id = 1;
}

// Deletes a TaskDef.
message DeleteTaskDefRequest {
  // The ID of the TaskDef to delete.
  TaskDefId id = 1;
}

// Deletes a UserTaskDef.
message DeleteUserTaskDefRequest {
  // The ID of the UserTaskDef to delete.
  UserTaskDefId id = 1;
}

// Deletes a WfSpec
message DeleteWfSpecRequest {
  // The ID of the WfSpec to delete
  WfSpecId id = 1;
}

// Deletes an ExternalEventDef
message DeleteExternalEventDefRequest {
  // The ID of the ExternalEventDef to delete.
  ExternalEventDefId id = 1;
}

// Create a Workflow Run.
message RunWfRequest {
  // The name of the WfSpec to run.
  string wf_spec_name = 1;

  // Optionally specify the major version of the WfSpec to run. This guarantees that
  // the "signature" of the WfSpec (i.e. the required input variables, and searchable
  // variables) will not change for this app.
  optional int32 major_version = 2;

  // Optionally specify the specific revision of the WfSpec to run. It is not recommended
  // to use this in practice, as the WfSpec logic should be de-coupled from the applications
  // that run WfRun's.
  optional int32 revision = 3;

  // A map from Variable Name to Values for those variables. The provided variables are
  // passed as input to the Entrypoint ThreadRun.
  map<string, VariableValue> variables = 4;

  // You can optionally specify the ID of this WfRun. This is a recommended best practice
  // as it also makes your request idempotent and allows you to easily find the WfRun at
  // a later time.
  optional string id = 5;
  optional WfRunId parent_wf_run_id = 6;
}

// Used by a SearchWfRunRequest to filter WfRun's and only return those whose Variable's
// match a certain filter.
message VariableMatch {
    // The name of the variable to inspect.
    string var_name = 1;

    // The value that the Variable must have in order to satisfy this VariableMatch
    VariableValue value = 2;
}

// Request to await until a WorkflowEvent of a certain WorkflowEventDef on a certain WfRun
// is thrown. Relies upon native GRPC deadlines to configure timeouts.
message AwaitWorkflowEventRequest {
  // The ID of the WfRun which must throw the WorkflowEvent.
  WfRunId wf_run_id = 1;

  // The IDs of the WorkflowEventDef that must be thrown. The request will return the first matching
  // WorkflowEvent is thrown. If event_def_ids is empty, then the request will return the first
  // WorkflowEvent thrown by the WfRun.
  repeated WorkflowEventDefId event_def_ids = 2;

  // Since a single WfRun may throw multiple WorkflowEvent's with the same WorkflowEventDefId, it
  // is necessary to provide a client the ability to "ignore" WorkflowEvent's that have already been
  // 'awaited'. Any WorkflowEvent specified by this field is ignored by the rpc.
  repeated WorkflowEventId workflow_events_to_ignore = 3;
}

// A request used to retrieve a list of WfRunId's by certain criteria.
message SearchWfRunRequest {
    // Bookmark for cursor-based pagination; pass if applicable.
    optional bytes bookmark = 1;

    // Maximum results to return in one request.
    optional int32 limit = 2;

    // The WfSpec whose WfRun's we are searching for. This is required.
    string wf_spec_name = 3;

    // Specifies to return only WfRun's from this WfSpec Major Version.
    optional int32 wf_spec_major_version = 4;

    // Specifies to return only WfRun's from this WfSpec Revision. Can only be set if
    // wf_spec_major_version is also set.
    optional int32 wf_spec_revision = 5;

    // Specifies to return only WfRun's matching this status.
    optional LHStatus status = 6;

    // Specifies to return only WfRun's that started after this time
    optional google.protobuf.Timestamp earliest_start = 7;

    // Specifies to return only WfRun's that started before this time
    optional google.protobuf.Timestamp latest_start = 8;

    // Allows filtering WfRun's based on the value of the Variables. This ONLY
    // works for the Variables in the entrypiont threadrun (that is, variables
    // where the threadRunNumber == 0).
    repeated VariableMatch variable_filters = 9;
}

// List of WfRun Id's
message WfRunIdList {
  // The resulting object id's.
  repeated WfRunId results = 1;

  // The bookmark can be used for cursor-based pagination. If it is null, the server
  // has returned all results. If it is set, you can pass it into your next request
  // to resume searching where your previous request left off.
  optional bytes bookmark = 2;
}

// Searches for TaskRuns by various criteria.
message SearchTaskRunRequest {
    // Bookmark for cursor-based pagination; pass if applicable.
    optional bytes bookmark = 1;

    // Maximum results to return in one request.
    optional int32 limit = 2;

    // Specifies the TaskDef of TaskRun's to return. This is required.
    string task_def_name = 3;

    // Specifies to only return TaskRun's matching this status.
    optional TaskStatus status = 4;

    // Specifies to only return TaskRun's that were scheduled after this time.
    optional google.protobuf.Timestamp earliest_start = 5;

    // Specifies to only return TaskRun's that were scheduled before this time.
    optional google.protobuf.Timestamp latest_start = 6;
}

// List of TaskRun ID's.
message TaskRunIdList {
  // The resulting object id's.
  repeated TaskRunId results = 1;

  // The bookmark can be used for cursor-based pagination. If it is null, the server
  // has returned all results. If it is set, you can pass it into your next request
  // to resume searching where your previous request left off.
  optional bytes bookmark = 2;
}

// Search for NodeRun's by certain criteria.
message SearchNodeRunRequest {
  // This enum denotes the type of a NodeRun.
  enum NodeType {
    // TASK node schedules a TaskRun
    TASK = 0;
    // EXTERNAL_EVENT blocks the ThreadRun until a specified ExternalEvent arrives
    EXTERNAL_EVENT = 1;
    // ENTRYPOINT kicks off a ThreadRun
    ENTRYPOINT = 2;
    // EXIT completes a ThreadRun
    EXIT = 3;
    // START_THREAD creates a Child ThreadRun
    START_THREAD = 4;
    // WAIT_THREADS waits for one or more child ThreadRuns to complete
    WAIT_THREADS = 5;
    // SLEEP makes the ThreadRun sleep for a specified time
    SLEEP = 6;
    // USER_TASK creates a UserTaskRun and blocks until the UserTaskRun is completed.
    USER_TASK = 7;
    // START_MULTIPLE_THREADS iterates over a list and starts a Child Thread for each item
    START_MULTIPLE_THREADS = 8;
  }

  // Bookmark for cursor-based pagination; pass if applicable.
  optional bytes bookmark = 1;

  // Maximum results to return in one request.
  optional int32 limit = 2;

  // Only return NodeRun's created after this time.
  optional google.protobuf.Timestamp earliest_start = 3;

  // Only return NodeRun's created before this time.
  optional google.protobuf.Timestamp latest_start = 4;

  // Specifies the type of NodeRun to search for.
  NodeType node_type = 5;

  // Specifies the status of NodeRun to search for.
  LHStatus status = 6;
}

// List of NodeRun Id's.
message NodeRunIdList {
  // The resulting object id's.
  repeated NodeRunId results = 1;

  // The bookmark can be used for cursor-based pagination. If it is null, the server
  // has returned all results. If it is set, you can pass it into your next request
  // to resume searching where your previous request left off.
  optional bytes bookmark = 2;
}

// Search for UserTaskRun's matching certain criteria. The attributes are additive,
// you may specify any combination of fields in this request. Only UserTaskRun's
// matching all criteria will be returned.
message SearchUserTaskRunRequest {
  // Bookmark for cursor-based pagination; pass if applicable.
  optional bytes bookmark = 1;
  // Maximum results to return in one request.
  optional int32 limit = 2;

  // Status of UserTaskRun's to return.
  optional UserTaskRunStatus status = 3;
  // UserTaskDef name to search for.
  optional string user_task_def_name = 4;

  // Search for UserTaskRun's assigned to this user id.
  optional string user_id = 5;
  // Search for UserTaskRun's assigned to this user group.
  optional string user_group = 6;

  // Search for UserTaskRun's that were created after this time.
  optional google.protobuf.Timestamp earliest_start = 7;

  // Search for UserTaskRun's that were created before this time.
  optional google.protobuf.Timestamp latest_start = 8;
}

// A list of UserTaskRun Id's
message UserTaskRunIdList {
  // The resulting object id's.
  repeated UserTaskRunId results = 1;

  // The bookmark can be used for cursor-based pagination. If it is null, the server
  // has returned all results. If it is set, you can pass it into your next request
  // to resume searching where your previous request left off.
  optional bytes bookmark = 2;
}

// Search for Variables by their value. This request is also highly useful to search for
// WfRun's based on the value of Variable's that are not in the Entrypoint ThreadRun,
// and also when you are using LittleHorse as a data store and need to perform a search.
//
// You may only search for a Variable that has an index specified on it. This may be done
// via th `.searchable()` method on our SDK's.
//
// Note that we do not yet support searching JSON_OBJ or JSON_ARR fields, but you may
// still mark those fields as searchable. We will soon add the ability to query those
// fields via the indices.
message SearchVariableRequest {
  // Bookmark for cursor-based pagination; pass if applicable.
  optional bytes bookmark = 1;
  // Maximum results to return in one request.
  optional int32 limit = 2;

  // Specifies the value that the variable must be. Exact match is required.
  VariableValue value = 3;

  // Specifies major version of the WfSpec for the associated WfRun.
  optional int32 wf_spec_major_version = 4;
  // Specifies the revision of the WfSpec for the associated WfRun.
  optional int32 wf_spec_revision = 5;

  // Specifies the name of the variable to search for. This is required.
  string var_name = 6;

  // Specifies the name of the WfSpec for the associated WfRun's. This is required.
  string wf_spec_name = 7;
}

// This is a list of Variable ID's.
message VariableIdList {
  // The resulting object id's.
  repeated VariableId results = 1;

  // The bookmark can be used for cursor-based pagination. If it is null, the server
  // has returned all results. If it is set, you can pass it into your next request
  // to resume searching where your previous request left off.
  optional bytes bookmark = 2;
}

// Search for TaskDef's based on certain criteria.
message SearchTaskDefRequest {
  // Bookmark for cursor-based pagination; pass if applicable.
  optional bytes bookmark = 1;
  // Maximum results to return in one request.
  optional int32 limit = 2;

  // Optionally specify to only return TaskDef's with a specific prefix.
  optional string prefix = 3;
}

// List of TaskDef Id's.
message TaskDefIdList {
  // The resulting object id's.
  repeated TaskDefId results = 1;

  // The bookmark can be used for cursor-based pagination. If it is null, the server
  // has returned all results. If it is set, you can pass it into your next request
  // to resume searching where your previous request left off.
  optional bytes bookmark = 2;
}

// Search for UserTaskDef's.
message SearchUserTaskDefRequest {
  // Bookmark for cursor-based pagination; pass if applicable.
  optional bytes bookmark = 1;
  // Maximum results to return in one request.
  optional int32 limit = 2;

  // Optionally specify filters. If no filters are specified, all UserTaskDef's are
  // returned.
  oneof user_task_def_criteria {
    // Return all UserTaskDef's with a specific prefix.
    string prefix = 3;
    // Return all UserTaskDef's with a specific name.
    string name = 4;
  }
}

// List of UserTaskDef Id's.
message UserTaskDefIdList {
  // The resulting object id's.
  repeated UserTaskDefId results = 1;

  // The bookmark can be used for cursor-based pagination. If it is null, the server
  // has returned all results. If it is set, you can pass it into your next request
  // to resume searching where your previous request left off.
  optional bytes bookmark = 2;
}

// Search for WfSpec's.
message SearchWfSpecRequest {
  // Bookmark for cursor-based pagination; pass if applicable.
  optional bytes bookmark = 1;
  // Maximum results to return in one request.
  optional int32 limit = 2;

  // Optionally specify filters. If no filters are specified, all UserTaskDef's are
  // returned.
  oneof wf_spec_criteria {
    // Return WfSpec's with a specific name.
    string name = 3;
    // Return WfSpec's with a specific prefix.
    string prefix = 4;
    // Return all WfSpec's that make use of a given TaskDef.
    string task_def_name = 5;
  }
}

// List of WfSpec Id's.
message WfSpecIdList {
  // The resulting object id's.
  repeated WfSpecId results = 1;

  // The bookmark can be used for cursor-based pagination. If it is null, the server
  // has returned all results. If it is set, you can pass it into your next request
  // to resume searching where your previous request left off.
  optional bytes bookmark = 2;
}

// Search for ExternalEventDef's.
message SearchExternalEventDefRequest {
  // Bookmark for cursor-based pagination; pass if applicable.
  optional bytes bookmark = 1;
  // Maximum results to return in one request.
  optional int32 limit = 2;

  // Optionally search only for ExternalEventDef's whose name starts with this prefix.
  optional string prefix = 3;
}

// List of ExternalEventDef Id's.
message ExternalEventDefIdList {
  // The resulting object id's.
  repeated ExternalEventDefId results = 1;

  // The bookmark can be used for cursor-based pagination. If it is null, the server
  // has returned all results. If it is set, you can pass it into your next request
  // to resume searching where your previous request left off.
  optional bytes bookmark = 2;
}

// Search for all available TenantIds for current Principal
message SearchTenantRequest {
      // Maximum results to return in one request.
      optional int32 limit = 1;
      // Bookmark for cursor-based pagination; pass if applicable.
      optional bytes bookmark = 2;
}

message TenantIdList {
      // The resulting object id's.
      repeated TenantId results = 1;
      // Bookmark for cursor-based pagination; pass if applicable.
      optional bytes bookmark = 2;
}

// Search for Principals based on certain criteria.
message SearchPrincipalRequest {
  // Bookmark for cursor-based pagination; pass if applicable.
  optional bytes bookmark = 1;
  // Maximum results to return in one request.
  optional int32 limit = 2;

  // Specifies to return only Principals's created after this time
  optional google.protobuf.Timestamp earliest_start = 3;

  // Specifies to return only Principals's created before this time
  optional google.protobuf.Timestamp latest_start = 4;

  oneof principal_criteria {
    // List only Principals that are admins
    bool isAdmin = 5;
    // List Principals associated with this Tenant ID
    string tenantId = 6;
  }
}

message PrincipalIdList {
  // The resulting object id's.
  repeated PrincipalId results = 1;
  // Bookmark for cursor-based pagination; pass if applicable.
  optional bytes bookmark = 2;
}

// EVOLVING: Search for ExternalEvent's.
//
// Currently, this request allows you to search for ExternalEvent's based on either:
// 1. A WfRunId
// 2. An ExternalEventDefName and status.
//
// This specific RPC is under discussions for a Refactor and will soon experience breaking changes.
// It is recommended for applications needing to search by WfRunId to instead use the
// `rpc ListExternalEvents` call, as we plan to remove the 'by WfRunId' option from this request.
//
// Specifically, we plan to remove the "by wfRunId" option (which is redundant with the ListExternalEvents
// request), and "flatten" the "ByExtEvtDefNameAndStatusRequest" fields into the main message.
message SearchExternalEventRequest {
  // Bookmark for cursor-based pagination; pass if applicable.
  optional bytes bookmark = 1;
  // Maximum results to return in one request.
  optional int32 limit = 2;

  // EVOLVING: message encapsulating criteria to search for ExternalEvent's by their status
  // and ExternalEventDefName.
  message ByExtEvtDefNameAndStatusRequest {
    string external_event_def_name = 1;
    optional bool is_claimed = 2;
  }

  // EVOLVING
  oneof ext_evt_criteria {
    WfRunId wf_run_id = 3;
    ByExtEvtDefNameAndStatusRequest external_event_def_name_and_status = 4;
  }
}

// List of ExternalEvent Id's
message ExternalEventIdList {
  // The resulting object id's.
  repeated ExternalEventId results = 1;

  // The bookmark can be used for cursor-based pagination. If it is null, the server
  // has returned all results. If it is set, you can pass it into your next request
  // to resume searching where your previous request left off.
  optional bytes bookmark = 2;
}

// List all NodeRun's for a given WfRun. Note that List requests return actual NodeRun Objects,
// not NodeRunId's.
message ListNodeRunsRequest {
  // The WfRun for whom we list NodeRun's.
  WfRunId wf_run_id = 1;

  // Optionally specify the thread run number to filter NodeRun's by.
  optional int32 thread_run_number = 2;

  // Bookmark for cursor-based pagination; pass if applicable.
  optional bytes bookmark = 3;

  // Maximum results to return in one request.
  optional int32 limit = 4;
}

// A list of NodeRun Objects.
message NodeRunList {
  // A list of NodeRun Objects.
  repeated NodeRun results = 1;

  // The bookmark can be used for cursor-based pagination. If it is null, the server
  // has returned all results. If it is set, you can pass it into your next request
  // to resume searching where your previous request left off.
  optional bytes bookmark = 2;
}

// List all Variables for a specific WfRun. Note that List requests return actual Variable Objects,
// not VariableId's.
message ListVariablesRequest {
  // The WfRun for whom we will list Variables.
  WfRunId wf_run_id = 1;
}

// A list of Variables.
message VariableList {
  // A list of Variable objects.
  repeated Variable results = 1;
}

// List all ExternalEvents for a specific WfRunId. Note that List Requests return actual
// ExternalEvent objects, not ExternalEventId's.
message ListExternalEventsRequest {
  // The WfRunId for whom we list ExternalEvent's.
  WfRunId wf_run_id = 1;
}

// A list of ExternalEvents.
message ExternalEventList {
  // A list of ExternalEvent objects.
  repeated ExternalEvent results = 1;
}

// Message used by Task Worker to register itself to the server and ask for assignments of
// servers to poll.
//
// Used by the Task Worker SDK; generally, you shouldn't have to touch this manually.
message RegisterTaskWorkerRequest {
  // Is the ID of the Task Worker.
  string task_worker_id = 1;

  // The TaskDef the worker wants to poll for.
  TaskDefId task_def_id = 2;

  // The listener that the worker is polling on. Used by the server to determine which
  // advertised hosts to return.
  string listener_name = 3;
}

// Message used by Task Worker to register itself to the server and ask for assignments of
// servers to poll.
//
// Used by the Task Worker SDK; generally, you shouldn't have to touch this manually.
message TaskWorkerHeartBeatRequest {
  string client_id = 1;
  TaskDefId task_def_id = 2;
  string listener_name = 3;
}

// Response containing list of Servers that the Task Worker should connect to and start polling from.
// Only used internally by the Task Worker SDK.
message RegisterTaskWorkerResponse {
  // The list of LH Server hosts that the Task Worker should start polling.
  repeated LHHostInfo your_hosts = 1;

  // Whether the LH Cluster is healthy.
  optional bool is_cluster_healthy = 2;
}

// Information about a specific LH Server to contact.
message LHHostInfo {
  // The host on the server
  string host = 1;

  // The port for the specified listener.
  int32 port = 2;
}

// Request sent by the Task Worker SDK to tell the Server that the Task Worker is ready
// to execute a TaskRun. Generally used only by the Task Worker SDK.
message PollTaskRequest {
  // Is the TaskDefId that the Task Worker wants to execute.
  TaskDefId task_def_id = 1;

  // Is the ID of the Task Worker.
  string client_id = 2;

  // Optionally specifies the version of the Task Worker, so that it can be recorded
  // for debugging purposes on the TaskRun itself.
  optional string task_worker_version = 3;
}

// Message sent by server to Task Worker SDK specifying a specific TaskRun to be executed.
// This is used and handled internally by the Task Worker SDK.
message ScheduledTask {
  // Id of the TaskRun to execute.
  TaskRunId task_run_id = 1;

  // ID of the TaskDef to which the TaskRun belongs.
  TaskDefId task_def_id = 2;

  // Attempt number of the TaskRun, zero indexed. attempt_number of `0` means this is the
  // first attempt; `1` means this is the first retry, etc.
  int32 attempt_number = 3;

  // Input variables for this TaskRun.
  repeated VarNameAndVal variables = 4;
  google.protobuf.Timestamp created_at = 5;

  // Source of the TaskRun. Currently, there are two options:
  // 1. A TASK node
  // 2. A reminder task scheduled by a trigger on a User Task.
  TaskRunSource source = 6;
}

// Response from the server for PollTaskRequest.
message PollTaskResponse {
  // If possible, a ScheduledTask is returned.
  optional ScheduledTask result = 1;
}

// Request used by the Task Worker SDK to report the result of a TaskRun execution.
message ReportTaskRun {
  // ID of the TaskRun
  TaskRunId task_run_id = 1;

  // When the TaskRun was executed
  google.protobuf.Timestamp time = 2;

  // Status of the TaskRun
  TaskStatus status = 3;

  // Optional information for logging or exceptions
  optional VariableValue log_output = 5;

  // Attempt number of the TaskRun
  int32 attempt_number = 6;

  // Result can be one of three things:
  // 1. output: the TaskRun was successfully executed and returned some output.
  // 2. error: the TaskRun failed with a technical problem.
  // 3. exception: the business logic threw an LHTaskException due to some business
  //      precondition not being met.
  oneof result {
    // Successfully completed task
    VariableValue output = 4;
    // Technical error
    LHTaskError error = 7;
    // Business exception
    LHTaskException exception = 8;
  }
}

// Message to HALT a WfRun.
message StopWfRunRequest {
  // Is the WfRunId
  WfRunId wf_run_id = 1;

  // The number of the ThreadRun to halt. Note that halting the entrypoint ThreadRun (which
  // always has number `0`) causes the whole WfRun to halt. If you do not manually set
  // the thread_run_number field, it defaults to zero, so stopping the entire WfRun is the
  // default behavior.
  int32 thread_run_number = 2;
}

// Resume a WfRun.
message ResumeWfRunRequest {
  // Is the WfRunId
  WfRunId wf_run_id = 1;

  // The number of the ThreadRun to resume. Note that resuming the entrypoint ThreadRun (which
  // always has number `0`) causes the whole WfRun to resume. If you do not manually set
  // the thread_run_number field, it defaults to zero, so resuming the entire WfRun is the
  // default behavior.
  int32 thread_run_number = 2;
}

// The request used to rescue a failed ThreadRun at a specific NodeRun.
message RescueThreadRunRequest {
    // The id of the `WfRun` which we are going to rescue.
    WfRunId wf_run_id = 1;

    // The number of the failed `ThreadRun` that we will rescue. The specified
    // `ThreadRun` must be in a state where it's latest `NodeRun` is: <br/>
    // - In the `ERROR` state.<br/>
    // - Has no `FailureHandler` `ThreadRun`s <br/>
    // - The parent `ThreadRun`, or any parent of the parent, has not handled the `Failure`
    // yet.
    //
    // If that is not true, then the `ThreadRun` cannot be rescued and the request
    // will return `FAILED_PRECONDITION`.
    int32 thread_run_number = 2;

    // If set to `true`, then the ThreadRun will skip past the `Node` of the
    // current failed `NodeRun` and advance according to the outgoing edges.
    // If set to `false`, then the `ThreadRun` will schedule another `NodeRun` for
    // the current `Node`
    bool skip_current_node = 3;
}

// Query to retrieve a specific TaskDef Metrics Window.
message TaskDefMetricsQueryRequest {
  // Return the window *containing* this timestamp. The window start is not guaranteed to
  // align perfectly with the request.
  google.protobuf.Timestamp window_start = 1;

  // The window size
  MetricsWindowLength window_type = 2;

  // The name of the specific TaskDef for which we are calculating metrics.
  optional string task_def_name = 3;
}

// Query to retrieve TaskDef Metrics over a period of time.
message ListTaskMetricsRequest {
  // TaskDef id for whichwe retrieve metrics.
  TaskDefId task_def_id = 1;

  // This parameter is a timestamp that is used to determine the *last* window returned. The
  // server will then return `num_windows` worth of data from before this timestamp.
  google.protobuf.Timestamp last_window_start = 2;
  // Window size
  MetricsWindowLength window_length = 3;
  // Number of windows to retrieve.
  int32 num_windows = 4;
}

// A list of TaskDef Metrics WIndows
message ListTaskMetricsResponse {
  // List of TaskDef Metrics Windows
  repeated TaskDefMetrics results = 1;
}

// Query to retrieve a specific WfSpec Metrics Window.
message WfSpecMetricsQueryRequest {
  // WfSpecId of metrics to get.
  WfSpecId wf_spec_id = 1;

  // Return the window *containing* this timestamp. The window start is not guaranteed to
  // align perfectly with the request.
  google.protobuf.Timestamp window_start = 2;

  // The window size
  MetricsWindowLength window_length = 3;
}

// Query to retrieve WfSpec Metrics over a period of time.
message ListWfMetricsRequest {
  // WfSpecId of metrics to get.
  WfSpecId wf_spec_id = 1;

  // This parameter is a timestamp that is used to determine the *last* window returned. The
  // server will then return `num_windows` worth of data from before this timestamp.
  google.protobuf.Timestamp last_window_start = 2;

  // The window size
  MetricsWindowLength window_length = 3;
  // Number of windows to retrieve
  int32 num_windows = 4;
}

// A list of WfSpec Metrics Windows
message ListWfMetricsResponse {
  // List of WfSpec Metrics Windows
  repeated WfSpecMetrics results = 1;
}

// Metrics for a TaskDef in a certain time period.
message TaskDefMetrics {
  // TaskDef that the metrics apply to.
  TaskDefId task_def_id = 1;

  // When the window started.
  google.protobuf.Timestamp window_start = 2;

  // Length of the window.
  MetricsWindowLength type = 3;

  // Longest time that a TaskRun was in the TASK_SCHEDULED state
  int64 schedule_to_start_max = 4;
  // Average time that a TaskRun was in the TASK_SCHEDULED state
  int64 schedule_to_start_avg = 5;
  // Longest time between a TaskRun being started and completed
  int64 start_to_complete_max = 6;
  // Average time between a TaskRun being started and completed
  int64 start_to_complete_avg = 7;
  // Total number of TaskRun's that reached the TASK_SUCCESS state
  int64 total_completed = 8;
  // Total number of TaskRun's that reached the TASK_ERROR state
  int64 total_errored = 9;
  // Total number of TaskRun's that transitioned to the TASK_RUNNING state
  int64 total_started = 10;
  // Total number of TaskRun's that were scheduled
  int64 total_scheduled = 11;
}

// Metrics for a WfSpec in a specific time window
message WfSpecMetrics {
  // The WfSpecId that these metrics analyze
  WfSpecId wf_spec_id = 1;
  // The time that the window started
  google.protobuf.Timestamp window_start = 2;
  // The length of the window
  MetricsWindowLength type = 3;

  // Total number of WfRun's created for this WfSpec
  int64 total_started = 4;
  // Total number of WfRun's that reached the COMPLETED state
  int64 total_completed = 5;
  // Total number of WfRun's that reached the ERROR state
  int64 total_errored = 6;
  // Longest time between a WfRun being started and reaching the COMPLETED state
  int64 start_to_complete_max = 7;
  // Average time that a WfRun took to reach the COMPLETED state
  int64 start_to_complete_avg = 8;
}

// List UserTaskRun's for a specific WfRun
message ListUserTaskRunRequest {
  // The WfRun for which to list UserTaskRuns
  WfRunId wf_run_id = 1;
}

// List of UserTaskRuns
message UserTaskRunList {
  // A list of UserTaskRun Objects
  repeated UserTaskRun results = 1;
}

// Describes a specific task worker
message TaskWorkerMetadata {
  // User-defined identifier for the worker.
  string task_worker_id = 1;
  // Timestamp indicating the last heartbeat sent by the worker.
  google.protobuf.Timestamp latest_heartbeat = 2;
  // The host(s) where the worker is polling tasks
  repeated LHHostInfo hosts = 3;
}

// Describes all workers registered for a specific TaskDef.
message TaskWorkerGroup {
  // Identifier for the group.
  TaskWorkerGroupId id = 1;
  // Timestamp indicating when the worker group was initially registered.
  google.protobuf.Timestamp created_at = 2;
  // Metadata grouped by ClientId string.
  map<string, TaskWorkerMetadata> task_workers = 3;
}

// List TaskRun's for a specific WfRun
message ListTaskRunsRequest {
  // The WfRun for which to list TaskRun's
  WfRunId wf_run_id = 1;
}

// A list of TaskRun's
message TaskRunList {
  // A list of TaskRun Objects
  repeated TaskRun results = 1;
}

// EXPERIMENTAL: migrate live WfRun's from one version of a WfSpec to another.
message MigrateWfSpecRequest {
  WfSpecId old_wf_spec = 1;
  WfSpecVersionMigration migration = 2;
}

// Get the latest WfSpec with a given name and optionally majorVersion
message GetLatestWfSpecRequest {
  // The name of the WfSpec to get. This is required.
  string name = 1;

  // Optionally get only WfSpec's that have the same major version. This can be useful
  // if you want to guarantee that there have been no breaking changes to the API of the
  // WfSpec, for example, to ensure that there have been no changes to searchable variables
  // or required input variables.
  optional int32 major_version = 2;
}

// The version of the LH Server according to Semantic Versioning
message ServerVersionResponse {
  // Server Major Version
  int32 major_version = 1;

  // Server Minor Version
  int32 minor_version = 2;

  // Server Patch Version
  int32 patch_version = 3;

  // Prerelease Identifier. If this is set, then the server is NOT a production release
  // but rather a release candidate or experimental pre-release.
  optional string pre_release_identifier = 4;
}
