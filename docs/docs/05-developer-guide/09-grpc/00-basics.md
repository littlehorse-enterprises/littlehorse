import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Background

The public LittleHorse API is a GRPC service exposed by the LH Server. We plan to add auto-generated GRPC documentation soon (i.e. before the upcoming release of `1.0.0`). In the meantime, you can find our service defined in our [source code](https://github.com/littlehorse-enterprises/littlehorse/schemas/service.proto).

:::tip
For background, we would recommend checking out the GRPC documentation for a primer on GRPC in [Java](https://grpc.io/docs/languages/java/), [Go](https://grpc.io/docs/languages/go/), and [Python](https://grpc.io/docs/languages/python/).
:::

Because the public LittleHorse API is a GRPC service, you may notice that the `LHConfig` object in all three of our SDK's has a `getStub()` method or equivalent. This returns the autogenerated GRPC client in the appropriate language.

This page describes several patterns in the LittleHorse API. Some of these patterns come directly from GRPC (such as error handling and status codes), and others such as our implementation of cursor-based pagination are specific to LittleHorse.

## Error Handling

The LittleHorse API uses the standard GRPC Error Codes, and we strictly follow the conventions described in [the official documentation](https://grpc.github.io/grpc/core/md_doc_statuscodes.html). The most common error codes you will encounter are `NOT_FOUND`, `FAILED_PRECONDITION`, `ALREADY_EXISTS`, and `INVALID_ARGUMENT`.

When handling errors from the LittleHorse API, you should treat the status code as a machine-readable signal, and the error-message should be treated as a _human-readable_ debugging aid. Your control flow logic should not depend on the content of the error message; it should only pay attention to the error status code.

LittleHorse **currently** does not utilize the GRPC Trailers to send error content in the form of a well-formed protobuf message.

In the example below, we will make a `RunWf` request and provide the `id` of the `WfRun` which we want to run. Such a request will fail with an `ALREADY_EXISTS` error if the `WfRun` already exists. The example below will show you how to catch such an error.

<Tabs>
  <TabItem value="java" label="Java" default>

```java
import io.grpc.StatusRuntimeException; // GRPC propagates errors through this exception.
import io.grpc.Status.Code; // This is the proper enum for handling responses. NOTE: it is
                            // different than the enum used for **throwing** errors on the
                            // server side.

LittleHorseBlockingStub client = ...;
String wfRunId = "obi-wan-workflow-run-id";

try {
    client.runWf(RunWfRequest.newBuilder()
            .setWfSpecName("example-run-wf")
            .putVariables("n", LHLibUtil.objToVarVal(n))
            .build()
    );
} catch (StatusRuntimeException exn) {
    if (exn.getStatus().getCode() == Code.ALREADY_EXISTS) {
        System.out.println("Request failed because WfRun with this ID already exists!");
    } else {
        System.out.println("Yikes, we got a different error.");
        throw exn;
    }
}
```

  </TabItem>
  <TabItem value="go" label="Go">

Go example coming soon. However, it should be highly similar to the Java example above.

  </TabItem>
  <TabItem value="python" label="Python">

Python example coming soon. However, it should be highly similar to the Java example above.

  </TabItem>
</Tabs>

## Read-Only Requests and Mutating Requests

In LittleHorse, there are two predominant types of GRPC requests:

* Read-Only Requests, which simply returns information about the current state of the system without altering it (eg. get a `WfRun` via the `rpc GetWfRun`), and
* Mutating Requests, which may alter the state of the system (eg. run a `WfRun` via the `rpc RunWf`).

In LittleHorse, all Read-Only Requests (with the exception of `rpc Whoami`) start with `Get`, `List`, or `Search`. Any other request is a Mutating Request.

All Mutating Requests in LittleHorse _can be_ made idempotent if you pass in the proper information. For example, if you pass in the `id` field on the `rpc RunWf`, you can safely retry the request multiple times and only one `WfRun` will be created. For 

## List and Search

List Requests and Search Requests are highly similar, with one distinct difference: a _List Request_ returns a series of _objects_, whereas a Search Request returns a series of _object id's_. For example, the `rpc ListTaskRun` returns a `TaskRunList` (list of `TaskRun`'s) whereas the `rpc SearchTaskRun` returns a `TaskRunIdList` (list of `TaskRunId`'s).

Generally, List Requests list all objects of a certain type belonging to a specific `WfRun`, but that is an observation and not a rule.

### What is an LH API Object?

Something that is stored in the LittleHorse Data Store and can be retrieved through some request `rpc GetFoo` in the LittleHorse API is refered to as a "LittleHorse API Object". Some common types of LH Api Objects are `WfRun`, `WfSpec`, `TaskRun`, and `TaskDef`.

An "Object Id" is a unique identifier for an LH API Object and contains all of the necessary information required to retrieve the LH API Object from the API via a request `rpc GetFoo`, such as: `rpc GetWfRun`, `rpc GetWfSpec`, `rpc GetTaskRun`, and `rpc GetTaskDef`.

For a given LH API Object Type (in this example, `TaskRun`), it is common to have some or all of the following requests:

```protobuf
message TaskRunId {
    WfRunId wf_run_id = 1;
    string guid = 2;
}

message TaskRunIdList {
    repeated TaskRunId results = 1;
    optional bytes bookmark = 2; // for cursor-based pagination
}

message TaskRunList {
    repeated TaskRun results = 1;
    optional bytes bookmark = 2; // for cursor-based pagination
}

// ...
service LittleHorse {
    // ...
    rpc GetTaskRun(TaskRunId) returns(TaskRun) {}
    rpc ListTaskRun(ListTaskRunRequest) returns (TaskRunList) {}
    rpc SearchTaskRun(SearchTaskRunRequest) returns (TaskRunIdList) {}
}
```

### Pagination

Both List Requests and Search Requests alike use [Cursor-Based Pagination](https://slack.engineering/evolving-api-pagination-at-slack/). For an example, we will look at the `rpc SearchTaskRun`. Note the `optiona bytes bookmark` field and the `optional int32 limit` field.

```proto
// Searches for TaskRuns by various criteria.
message SearchTaskRunRequest {
    optional bytes bookmark = 1;
    optional int32 limit = 2;
    string task_def_name = 3;
    optional TaskStatus status = 4;
    optional google.protobuf.Timestamp earliest_start = 5;
    optional google.protobuf.Timestamp latest_start = 6;
}
```

The `limit` field determines the maximum number of results to be returned in a single request.

Recall the `optional bytes bookmark` field in the `TaskRunIdList` proto. The `TaskRunIdList` is the response format for the request `rpc SearchTaskRun`. If the `rpc SearchTaskRun` has more results than can be returned in one request (see `limit`), then the `bookmark` field of the `TaskRunIdList` message is set to a byte-string that serves as a _cursor_.

To retrieve the next page of results, simply pass in the `bookmark` from your previous request to your next request. An example of iterating through pages of results is shown below.

<Tabs>
  <TabItem value="java" label="Java" default>

```java
import io.littlehorse.sdk.common.proto.SearchTaskRunRequest;
import io.littlehorse.sdk.common.proto.TaskRunIdList;

TaskRunIdList results = client.searchTaskRun(SearchTaskRunRequest.newBuilder()
        .setTaskDefName("my-task")
        .setLimit(5)
        .build());
// Omitted: process the TaskRunId's in `results.getResultsList()`.

while (results.hasBookmark()) {
    results = client.searchTaskRun(SearchTaskRunRequest.newBuilder()
            .setTaskDefName("my-task")
            .setLimit(5)
            .setBookmark(results.getBookmark())
            .build());
    // Omitted: process the TaskRunId's in results.getResultsList();
}
```
  </TabItem>
  <TabItem value="go" label="Go">

Go example coming soon. However, it should be highly similar to the Java example above.

  </TabItem>
  <TabItem value="python" label="Python">

Python example coming soon. However, it should be highly similar to the Java example above.

  </TabItem>
</Tabs>
