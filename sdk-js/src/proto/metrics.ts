// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.32.1
// source: metrics.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  AggregationType,
  aggregationTypeFromJSON,
  aggregationTypeToJSON,
  aggregationTypeToNumber,
  MetricEntityType,
  metricEntityTypeFromJSON,
  metricEntityTypeToJSON,
  metricEntityTypeToNumber,
  MetricRecordingLevel,
  metricRecordingLevelFromJSON,
  metricRecordingLevelToJSON,
  metricRecordingLevelToNumber,
} from "./common_enums";
import { Duration } from "./google/protobuf/duration";
import { Timestamp } from "./google/protobuf/timestamp";
import { TaskDefId, WfSpecId } from "./object_id";

export interface StatusTransition {
  entity: MetricEntityType;
  fromStatus: string;
  toStatus: string;
}

export interface MetricScope {
  type?:
    | { $case: "wfSpec"; value: WfSpecId }
    | { $case: "taskDef"; value: TaskDefId }
    | { $case: "node"; value: NodeReference }
    | { $case: "global"; value: boolean }
    | undefined;
}

export interface NodeReference {
  wfSpec: WfSpecId | undefined;
  threadName?: string | undefined;
  nodeName?: string | undefined;
  taskDef?: TaskDefId | undefined;
}

export interface MetricSpec {
  id: string;
  createdAt: string | undefined;
  aggregationType: AggregationType;
  scope: MetricScope | undefined;
  transition: StatusTransition | undefined;
  windowLength: Duration | undefined;
}

export interface ListMetricsRequest {
  metricSpecId: string;
  windowLength: Duration | undefined;
  aggregationType: AggregationType;
  startTime: string | undefined;
  endTime: string | undefined;
}

export interface MetricList {
  windows: MetricWindow[];
}

export interface CountAndTiming {
  count: number;
  minLatencyMs: number;
  maxLatencyMs: number;
  totalLatencyMs: number;
}

export interface MetricWindowId {
  entity: MetricEntityType;
  /** e.g., wf_spec name, task_def name */
  entityId: string;
  windowStart: string | undefined;
}

export interface MetricWindow {
  id:
    | MetricWindowId
    | undefined;
  /** for applicable entities */
  totalStarted: number;
  completed: CountAndTiming | undefined;
  halted: CountAndTiming | undefined;
  error: CountAndTiming | undefined;
  exception:
    | CountAndTiming
    | undefined;
  /** for exceptions, errors by type, etc. */
  custom: { [key: string]: CountAndTiming };
  /** Additional fields for TaskMetric specifics */
  scheduledToRunning: CountAndTiming | undefined;
  runningToSuccess: CountAndTiming | undefined;
  timeouts: number;
}

export interface MetricWindow_CustomEntry {
  key: string;
  value: CountAndTiming | undefined;
}

export interface MetricLevelOverride {
  id: string;
  newLevel: MetricRecordingLevel;
  target?: { $case: "wfSpec"; value: WfSpecId } | { $case: "taskDef"; value: TaskDefId } | {
    $case: "node";
    value: NodeReference;
  } | undefined;
}

export interface PutMetricLevelOverrideRequest {
  override: MetricLevelOverride | undefined;
}

export interface DeleteMetricLevelOverrideRequest {
  id: string;
}

export interface ListMetricLevelOverridesRequest {
  /** Optional filters */
  wfSpecFilter?: WfSpecId | undefined;
  taskDefFilter?: TaskDefId | undefined;
}

export interface MetricLevelOverridesList {
  overrides: MetricLevelOverride[];
}

function createBaseStatusTransition(): StatusTransition {
  return { entity: MetricEntityType.METRIC_WF_RUN, fromStatus: "", toStatus: "" };
}

export const StatusTransition = {
  encode(message: StatusTransition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entity !== MetricEntityType.METRIC_WF_RUN) {
      writer.uint32(8).int32(metricEntityTypeToNumber(message.entity));
    }
    if (message.fromStatus !== "") {
      writer.uint32(18).string(message.fromStatus);
    }
    if (message.toStatus !== "") {
      writer.uint32(26).string(message.toStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusTransition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusTransition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entity = metricEntityTypeFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fromStatus = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toStatus = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusTransition {
    return {
      entity: isSet(object.entity) ? metricEntityTypeFromJSON(object.entity) : MetricEntityType.METRIC_WF_RUN,
      fromStatus: isSet(object.fromStatus) ? globalThis.String(object.fromStatus) : "",
      toStatus: isSet(object.toStatus) ? globalThis.String(object.toStatus) : "",
    };
  },

  toJSON(message: StatusTransition): unknown {
    const obj: any = {};
    if (message.entity !== MetricEntityType.METRIC_WF_RUN) {
      obj.entity = metricEntityTypeToJSON(message.entity);
    }
    if (message.fromStatus !== "") {
      obj.fromStatus = message.fromStatus;
    }
    if (message.toStatus !== "") {
      obj.toStatus = message.toStatus;
    }
    return obj;
  },

  create(base?: DeepPartial<StatusTransition>): StatusTransition {
    return StatusTransition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StatusTransition>): StatusTransition {
    const message = createBaseStatusTransition();
    message.entity = object.entity ?? MetricEntityType.METRIC_WF_RUN;
    message.fromStatus = object.fromStatus ?? "";
    message.toStatus = object.toStatus ?? "";
    return message;
  },
};

function createBaseMetricScope(): MetricScope {
  return { type: undefined };
}

export const MetricScope = {
  encode(message: MetricScope, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.type?.$case) {
      case "wfSpec":
        WfSpecId.encode(message.type.value, writer.uint32(10).fork()).ldelim();
        break;
      case "taskDef":
        TaskDefId.encode(message.type.value, writer.uint32(18).fork()).ldelim();
        break;
      case "node":
        NodeReference.encode(message.type.value, writer.uint32(26).fork()).ldelim();
        break;
      case "global":
        writer.uint32(32).bool(message.type.value);
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricScope {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricScope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = { $case: "wfSpec", value: WfSpecId.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = { $case: "taskDef", value: TaskDefId.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = { $case: "node", value: NodeReference.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = { $case: "global", value: reader.bool() };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricScope {
    return {
      type: isSet(object.wfSpec)
        ? { $case: "wfSpec", value: WfSpecId.fromJSON(object.wfSpec) }
        : isSet(object.taskDef)
        ? { $case: "taskDef", value: TaskDefId.fromJSON(object.taskDef) }
        : isSet(object.node)
        ? { $case: "node", value: NodeReference.fromJSON(object.node) }
        : isSet(object.global)
        ? { $case: "global", value: globalThis.Boolean(object.global) }
        : undefined,
    };
  },

  toJSON(message: MetricScope): unknown {
    const obj: any = {};
    if (message.type?.$case === "wfSpec") {
      obj.wfSpec = WfSpecId.toJSON(message.type.value);
    }
    if (message.type?.$case === "taskDef") {
      obj.taskDef = TaskDefId.toJSON(message.type.value);
    }
    if (message.type?.$case === "node") {
      obj.node = NodeReference.toJSON(message.type.value);
    }
    if (message.type?.$case === "global") {
      obj.global = message.type.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MetricScope>): MetricScope {
    return MetricScope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricScope>): MetricScope {
    const message = createBaseMetricScope();
    if (object.type?.$case === "wfSpec" && object.type?.value !== undefined && object.type?.value !== null) {
      message.type = { $case: "wfSpec", value: WfSpecId.fromPartial(object.type.value) };
    }
    if (object.type?.$case === "taskDef" && object.type?.value !== undefined && object.type?.value !== null) {
      message.type = { $case: "taskDef", value: TaskDefId.fromPartial(object.type.value) };
    }
    if (object.type?.$case === "node" && object.type?.value !== undefined && object.type?.value !== null) {
      message.type = { $case: "node", value: NodeReference.fromPartial(object.type.value) };
    }
    if (object.type?.$case === "global" && object.type?.value !== undefined && object.type?.value !== null) {
      message.type = { $case: "global", value: object.type.value };
    }
    return message;
  },
};

function createBaseNodeReference(): NodeReference {
  return { wfSpec: undefined, threadName: undefined, nodeName: undefined, taskDef: undefined };
}

export const NodeReference = {
  encode(message: NodeReference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpec !== undefined) {
      WfSpecId.encode(message.wfSpec, writer.uint32(10).fork()).ldelim();
    }
    if (message.threadName !== undefined) {
      writer.uint32(18).string(message.threadName);
    }
    if (message.nodeName !== undefined) {
      writer.uint32(26).string(message.nodeName);
    }
    if (message.taskDef !== undefined) {
      TaskDefId.encode(message.taskDef, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeReference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpec = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.threadName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodeName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.taskDef = TaskDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeReference {
    return {
      wfSpec: isSet(object.wfSpec) ? WfSpecId.fromJSON(object.wfSpec) : undefined,
      threadName: isSet(object.threadName) ? globalThis.String(object.threadName) : undefined,
      nodeName: isSet(object.nodeName) ? globalThis.String(object.nodeName) : undefined,
      taskDef: isSet(object.taskDef) ? TaskDefId.fromJSON(object.taskDef) : undefined,
    };
  },

  toJSON(message: NodeReference): unknown {
    const obj: any = {};
    if (message.wfSpec !== undefined) {
      obj.wfSpec = WfSpecId.toJSON(message.wfSpec);
    }
    if (message.threadName !== undefined) {
      obj.threadName = message.threadName;
    }
    if (message.nodeName !== undefined) {
      obj.nodeName = message.nodeName;
    }
    if (message.taskDef !== undefined) {
      obj.taskDef = TaskDefId.toJSON(message.taskDef);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeReference>): NodeReference {
    return NodeReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeReference>): NodeReference {
    const message = createBaseNodeReference();
    message.wfSpec = (object.wfSpec !== undefined && object.wfSpec !== null)
      ? WfSpecId.fromPartial(object.wfSpec)
      : undefined;
    message.threadName = object.threadName ?? undefined;
    message.nodeName = object.nodeName ?? undefined;
    message.taskDef = (object.taskDef !== undefined && object.taskDef !== null)
      ? TaskDefId.fromPartial(object.taskDef)
      : undefined;
    return message;
  },
};

function createBaseMetricSpec(): MetricSpec {
  return {
    id: "",
    createdAt: undefined,
    aggregationType: AggregationType.COUNT,
    scope: undefined,
    transition: undefined,
    windowLength: undefined,
  };
}

export const MetricSpec = {
  encode(message: MetricSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).ldelim();
    }
    if (message.aggregationType !== AggregationType.COUNT) {
      writer.uint32(24).int32(aggregationTypeToNumber(message.aggregationType));
    }
    if (message.scope !== undefined) {
      MetricScope.encode(message.scope, writer.uint32(34).fork()).ldelim();
    }
    if (message.transition !== undefined) {
      StatusTransition.encode(message.transition, writer.uint32(42).fork()).ldelim();
    }
    if (message.windowLength !== undefined) {
      Duration.encode(message.windowLength, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricSpec {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.aggregationType = aggregationTypeFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.scope = MetricScope.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transition = StatusTransition.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.windowLength = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricSpec {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : undefined,
      aggregationType: isSet(object.aggregationType)
        ? aggregationTypeFromJSON(object.aggregationType)
        : AggregationType.COUNT,
      scope: isSet(object.scope) ? MetricScope.fromJSON(object.scope) : undefined,
      transition: isSet(object.transition) ? StatusTransition.fromJSON(object.transition) : undefined,
      windowLength: isSet(object.windowLength) ? Duration.fromJSON(object.windowLength) : undefined,
    };
  },

  toJSON(message: MetricSpec): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt;
    }
    if (message.aggregationType !== AggregationType.COUNT) {
      obj.aggregationType = aggregationTypeToJSON(message.aggregationType);
    }
    if (message.scope !== undefined) {
      obj.scope = MetricScope.toJSON(message.scope);
    }
    if (message.transition !== undefined) {
      obj.transition = StatusTransition.toJSON(message.transition);
    }
    if (message.windowLength !== undefined) {
      obj.windowLength = Duration.toJSON(message.windowLength);
    }
    return obj;
  },

  create(base?: DeepPartial<MetricSpec>): MetricSpec {
    return MetricSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricSpec>): MetricSpec {
    const message = createBaseMetricSpec();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.aggregationType = object.aggregationType ?? AggregationType.COUNT;
    message.scope = (object.scope !== undefined && object.scope !== null)
      ? MetricScope.fromPartial(object.scope)
      : undefined;
    message.transition = (object.transition !== undefined && object.transition !== null)
      ? StatusTransition.fromPartial(object.transition)
      : undefined;
    message.windowLength = (object.windowLength !== undefined && object.windowLength !== null)
      ? Duration.fromPartial(object.windowLength)
      : undefined;
    return message;
  },
};

function createBaseListMetricsRequest(): ListMetricsRequest {
  return {
    metricSpecId: "",
    windowLength: undefined,
    aggregationType: AggregationType.COUNT,
    startTime: undefined,
    endTime: undefined,
  };
}

export const ListMetricsRequest = {
  encode(message: ListMetricsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metricSpecId !== "") {
      writer.uint32(10).string(message.metricSpecId);
    }
    if (message.windowLength !== undefined) {
      Duration.encode(message.windowLength, writer.uint32(18).fork()).ldelim();
    }
    if (message.aggregationType !== AggregationType.COUNT) {
      writer.uint32(24).int32(aggregationTypeToNumber(message.aggregationType));
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListMetricsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpecId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.windowLength = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.aggregationType = aggregationTypeFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMetricsRequest {
    return {
      metricSpecId: isSet(object.metricSpecId) ? globalThis.String(object.metricSpecId) : "",
      windowLength: isSet(object.windowLength) ? Duration.fromJSON(object.windowLength) : undefined,
      aggregationType: isSet(object.aggregationType)
        ? aggregationTypeFromJSON(object.aggregationType)
        : AggregationType.COUNT,
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : undefined,
    };
  },

  toJSON(message: ListMetricsRequest): unknown {
    const obj: any = {};
    if (message.metricSpecId !== "") {
      obj.metricSpecId = message.metricSpecId;
    }
    if (message.windowLength !== undefined) {
      obj.windowLength = Duration.toJSON(message.windowLength);
    }
    if (message.aggregationType !== AggregationType.COUNT) {
      obj.aggregationType = aggregationTypeToJSON(message.aggregationType);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMetricsRequest>): ListMetricsRequest {
    return ListMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMetricsRequest>): ListMetricsRequest {
    const message = createBaseListMetricsRequest();
    message.metricSpecId = object.metricSpecId ?? "";
    message.windowLength = (object.windowLength !== undefined && object.windowLength !== null)
      ? Duration.fromPartial(object.windowLength)
      : undefined;
    message.aggregationType = object.aggregationType ?? AggregationType.COUNT;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseMetricList(): MetricList {
  return { windows: [] };
}

export const MetricList = {
  encode(message: MetricList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.windows) {
      MetricWindow.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.windows.push(MetricWindow.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricList {
    return {
      windows: globalThis.Array.isArray(object?.windows)
        ? object.windows.map((e: any) => MetricWindow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetricList): unknown {
    const obj: any = {};
    if (message.windows?.length) {
      obj.windows = message.windows.map((e) => MetricWindow.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MetricList>): MetricList {
    return MetricList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricList>): MetricList {
    const message = createBaseMetricList();
    message.windows = object.windows?.map((e) => MetricWindow.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCountAndTiming(): CountAndTiming {
  return { count: 0, minLatencyMs: 0, maxLatencyMs: 0, totalLatencyMs: 0 };
}

export const CountAndTiming = {
  encode(message: CountAndTiming, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== 0) {
      writer.uint32(8).int32(message.count);
    }
    if (message.minLatencyMs !== 0) {
      writer.uint32(16).int64(message.minLatencyMs);
    }
    if (message.maxLatencyMs !== 0) {
      writer.uint32(24).int64(message.maxLatencyMs);
    }
    if (message.totalLatencyMs !== 0) {
      writer.uint32(32).int64(message.totalLatencyMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CountAndTiming {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountAndTiming();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minLatencyMs = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxLatencyMs = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalLatencyMs = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CountAndTiming {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      minLatencyMs: isSet(object.minLatencyMs) ? globalThis.Number(object.minLatencyMs) : 0,
      maxLatencyMs: isSet(object.maxLatencyMs) ? globalThis.Number(object.maxLatencyMs) : 0,
      totalLatencyMs: isSet(object.totalLatencyMs) ? globalThis.Number(object.totalLatencyMs) : 0,
    };
  },

  toJSON(message: CountAndTiming): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.minLatencyMs !== 0) {
      obj.minLatencyMs = Math.round(message.minLatencyMs);
    }
    if (message.maxLatencyMs !== 0) {
      obj.maxLatencyMs = Math.round(message.maxLatencyMs);
    }
    if (message.totalLatencyMs !== 0) {
      obj.totalLatencyMs = Math.round(message.totalLatencyMs);
    }
    return obj;
  },

  create(base?: DeepPartial<CountAndTiming>): CountAndTiming {
    return CountAndTiming.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CountAndTiming>): CountAndTiming {
    const message = createBaseCountAndTiming();
    message.count = object.count ?? 0;
    message.minLatencyMs = object.minLatencyMs ?? 0;
    message.maxLatencyMs = object.maxLatencyMs ?? 0;
    message.totalLatencyMs = object.totalLatencyMs ?? 0;
    return message;
  },
};

function createBaseMetricWindowId(): MetricWindowId {
  return { entity: MetricEntityType.METRIC_WF_RUN, entityId: "", windowStart: undefined };
}

export const MetricWindowId = {
  encode(message: MetricWindowId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entity !== MetricEntityType.METRIC_WF_RUN) {
      writer.uint32(8).int32(metricEntityTypeToNumber(message.entity));
    }
    if (message.entityId !== "") {
      writer.uint32(18).string(message.entityId);
    }
    if (message.windowStart !== undefined) {
      Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricWindowId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricWindowId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entity = metricEntityTypeFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.windowStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricWindowId {
    return {
      entity: isSet(object.entity) ? metricEntityTypeFromJSON(object.entity) : MetricEntityType.METRIC_WF_RUN,
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      windowStart: isSet(object.windowStart) ? globalThis.String(object.windowStart) : undefined,
    };
  },

  toJSON(message: MetricWindowId): unknown {
    const obj: any = {};
    if (message.entity !== MetricEntityType.METRIC_WF_RUN) {
      obj.entity = metricEntityTypeToJSON(message.entity);
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.windowStart !== undefined) {
      obj.windowStart = message.windowStart;
    }
    return obj;
  },

  create(base?: DeepPartial<MetricWindowId>): MetricWindowId {
    return MetricWindowId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricWindowId>): MetricWindowId {
    const message = createBaseMetricWindowId();
    message.entity = object.entity ?? MetricEntityType.METRIC_WF_RUN;
    message.entityId = object.entityId ?? "";
    message.windowStart = object.windowStart ?? undefined;
    return message;
  },
};

function createBaseMetricWindow(): MetricWindow {
  return {
    id: undefined,
    totalStarted: 0,
    completed: undefined,
    halted: undefined,
    error: undefined,
    exception: undefined,
    custom: {},
    scheduledToRunning: undefined,
    runningToSuccess: undefined,
    timeouts: 0,
  };
}

export const MetricWindow = {
  encode(message: MetricWindow, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      MetricWindowId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalStarted !== 0) {
      writer.uint32(16).int32(message.totalStarted);
    }
    if (message.completed !== undefined) {
      CountAndTiming.encode(message.completed, writer.uint32(26).fork()).ldelim();
    }
    if (message.halted !== undefined) {
      CountAndTiming.encode(message.halted, writer.uint32(34).fork()).ldelim();
    }
    if (message.error !== undefined) {
      CountAndTiming.encode(message.error, writer.uint32(42).fork()).ldelim();
    }
    if (message.exception !== undefined) {
      CountAndTiming.encode(message.exception, writer.uint32(50).fork()).ldelim();
    }
    Object.entries(message.custom).forEach(([key, value]) => {
      MetricWindow_CustomEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    if (message.scheduledToRunning !== undefined) {
      CountAndTiming.encode(message.scheduledToRunning, writer.uint32(66).fork()).ldelim();
    }
    if (message.runningToSuccess !== undefined) {
      CountAndTiming.encode(message.runningToSuccess, writer.uint32(74).fork()).ldelim();
    }
    if (message.timeouts !== 0) {
      writer.uint32(80).int32(message.timeouts);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricWindow {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = MetricWindowId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalStarted = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.completed = CountAndTiming.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.halted = CountAndTiming.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = CountAndTiming.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.exception = CountAndTiming.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = MetricWindow_CustomEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.custom[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.scheduledToRunning = CountAndTiming.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.runningToSuccess = CountAndTiming.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.timeouts = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricWindow {
    return {
      id: isSet(object.id) ? MetricWindowId.fromJSON(object.id) : undefined,
      totalStarted: isSet(object.totalStarted) ? globalThis.Number(object.totalStarted) : 0,
      completed: isSet(object.completed) ? CountAndTiming.fromJSON(object.completed) : undefined,
      halted: isSet(object.halted) ? CountAndTiming.fromJSON(object.halted) : undefined,
      error: isSet(object.error) ? CountAndTiming.fromJSON(object.error) : undefined,
      exception: isSet(object.exception) ? CountAndTiming.fromJSON(object.exception) : undefined,
      custom: isObject(object.custom)
        ? Object.entries(object.custom).reduce<{ [key: string]: CountAndTiming }>((acc, [key, value]) => {
          acc[key] = CountAndTiming.fromJSON(value);
          return acc;
        }, {})
        : {},
      scheduledToRunning: isSet(object.scheduledToRunning)
        ? CountAndTiming.fromJSON(object.scheduledToRunning)
        : undefined,
      runningToSuccess: isSet(object.runningToSuccess) ? CountAndTiming.fromJSON(object.runningToSuccess) : undefined,
      timeouts: isSet(object.timeouts) ? globalThis.Number(object.timeouts) : 0,
    };
  },

  toJSON(message: MetricWindow): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = MetricWindowId.toJSON(message.id);
    }
    if (message.totalStarted !== 0) {
      obj.totalStarted = Math.round(message.totalStarted);
    }
    if (message.completed !== undefined) {
      obj.completed = CountAndTiming.toJSON(message.completed);
    }
    if (message.halted !== undefined) {
      obj.halted = CountAndTiming.toJSON(message.halted);
    }
    if (message.error !== undefined) {
      obj.error = CountAndTiming.toJSON(message.error);
    }
    if (message.exception !== undefined) {
      obj.exception = CountAndTiming.toJSON(message.exception);
    }
    if (message.custom) {
      const entries = Object.entries(message.custom);
      if (entries.length > 0) {
        obj.custom = {};
        entries.forEach(([k, v]) => {
          obj.custom[k] = CountAndTiming.toJSON(v);
        });
      }
    }
    if (message.scheduledToRunning !== undefined) {
      obj.scheduledToRunning = CountAndTiming.toJSON(message.scheduledToRunning);
    }
    if (message.runningToSuccess !== undefined) {
      obj.runningToSuccess = CountAndTiming.toJSON(message.runningToSuccess);
    }
    if (message.timeouts !== 0) {
      obj.timeouts = Math.round(message.timeouts);
    }
    return obj;
  },

  create(base?: DeepPartial<MetricWindow>): MetricWindow {
    return MetricWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricWindow>): MetricWindow {
    const message = createBaseMetricWindow();
    message.id = (object.id !== undefined && object.id !== null) ? MetricWindowId.fromPartial(object.id) : undefined;
    message.totalStarted = object.totalStarted ?? 0;
    message.completed = (object.completed !== undefined && object.completed !== null)
      ? CountAndTiming.fromPartial(object.completed)
      : undefined;
    message.halted = (object.halted !== undefined && object.halted !== null)
      ? CountAndTiming.fromPartial(object.halted)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? CountAndTiming.fromPartial(object.error)
      : undefined;
    message.exception = (object.exception !== undefined && object.exception !== null)
      ? CountAndTiming.fromPartial(object.exception)
      : undefined;
    message.custom = Object.entries(object.custom ?? {}).reduce<{ [key: string]: CountAndTiming }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = CountAndTiming.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.scheduledToRunning = (object.scheduledToRunning !== undefined && object.scheduledToRunning !== null)
      ? CountAndTiming.fromPartial(object.scheduledToRunning)
      : undefined;
    message.runningToSuccess = (object.runningToSuccess !== undefined && object.runningToSuccess !== null)
      ? CountAndTiming.fromPartial(object.runningToSuccess)
      : undefined;
    message.timeouts = object.timeouts ?? 0;
    return message;
  },
};

function createBaseMetricWindow_CustomEntry(): MetricWindow_CustomEntry {
  return { key: "", value: undefined };
}

export const MetricWindow_CustomEntry = {
  encode(message: MetricWindow_CustomEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CountAndTiming.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricWindow_CustomEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricWindow_CustomEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CountAndTiming.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricWindow_CustomEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CountAndTiming.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MetricWindow_CustomEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CountAndTiming.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MetricWindow_CustomEntry>): MetricWindow_CustomEntry {
    return MetricWindow_CustomEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricWindow_CustomEntry>): MetricWindow_CustomEntry {
    const message = createBaseMetricWindow_CustomEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CountAndTiming.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMetricLevelOverride(): MetricLevelOverride {
  return { id: "", newLevel: MetricRecordingLevel.INFO, target: undefined };
}

export const MetricLevelOverride = {
  encode(message: MetricLevelOverride, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.newLevel !== MetricRecordingLevel.INFO) {
      writer.uint32(16).int32(metricRecordingLevelToNumber(message.newLevel));
    }
    switch (message.target?.$case) {
      case "wfSpec":
        WfSpecId.encode(message.target.value, writer.uint32(26).fork()).ldelim();
        break;
      case "taskDef":
        TaskDefId.encode(message.target.value, writer.uint32(34).fork()).ldelim();
        break;
      case "node":
        NodeReference.encode(message.target.value, writer.uint32(42).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricLevelOverride {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricLevelOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.newLevel = metricRecordingLevelFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = { $case: "wfSpec", value: WfSpecId.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.target = { $case: "taskDef", value: TaskDefId.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.target = { $case: "node", value: NodeReference.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricLevelOverride {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      newLevel: isSet(object.newLevel) ? metricRecordingLevelFromJSON(object.newLevel) : MetricRecordingLevel.INFO,
      target: isSet(object.wfSpec)
        ? { $case: "wfSpec", value: WfSpecId.fromJSON(object.wfSpec) }
        : isSet(object.taskDef)
        ? { $case: "taskDef", value: TaskDefId.fromJSON(object.taskDef) }
        : isSet(object.node)
        ? { $case: "node", value: NodeReference.fromJSON(object.node) }
        : undefined,
    };
  },

  toJSON(message: MetricLevelOverride): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.newLevel !== MetricRecordingLevel.INFO) {
      obj.newLevel = metricRecordingLevelToJSON(message.newLevel);
    }
    if (message.target?.$case === "wfSpec") {
      obj.wfSpec = WfSpecId.toJSON(message.target.value);
    }
    if (message.target?.$case === "taskDef") {
      obj.taskDef = TaskDefId.toJSON(message.target.value);
    }
    if (message.target?.$case === "node") {
      obj.node = NodeReference.toJSON(message.target.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MetricLevelOverride>): MetricLevelOverride {
    return MetricLevelOverride.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricLevelOverride>): MetricLevelOverride {
    const message = createBaseMetricLevelOverride();
    message.id = object.id ?? "";
    message.newLevel = object.newLevel ?? MetricRecordingLevel.INFO;
    if (object.target?.$case === "wfSpec" && object.target?.value !== undefined && object.target?.value !== null) {
      message.target = { $case: "wfSpec", value: WfSpecId.fromPartial(object.target.value) };
    }
    if (object.target?.$case === "taskDef" && object.target?.value !== undefined && object.target?.value !== null) {
      message.target = { $case: "taskDef", value: TaskDefId.fromPartial(object.target.value) };
    }
    if (object.target?.$case === "node" && object.target?.value !== undefined && object.target?.value !== null) {
      message.target = { $case: "node", value: NodeReference.fromPartial(object.target.value) };
    }
    return message;
  },
};

function createBasePutMetricLevelOverrideRequest(): PutMetricLevelOverrideRequest {
  return { override: undefined };
}

export const PutMetricLevelOverrideRequest = {
  encode(message: PutMetricLevelOverrideRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.override !== undefined) {
      MetricLevelOverride.encode(message.override, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutMetricLevelOverrideRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutMetricLevelOverrideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.override = MetricLevelOverride.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutMetricLevelOverrideRequest {
    return { override: isSet(object.override) ? MetricLevelOverride.fromJSON(object.override) : undefined };
  },

  toJSON(message: PutMetricLevelOverrideRequest): unknown {
    const obj: any = {};
    if (message.override !== undefined) {
      obj.override = MetricLevelOverride.toJSON(message.override);
    }
    return obj;
  },

  create(base?: DeepPartial<PutMetricLevelOverrideRequest>): PutMetricLevelOverrideRequest {
    return PutMetricLevelOverrideRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PutMetricLevelOverrideRequest>): PutMetricLevelOverrideRequest {
    const message = createBasePutMetricLevelOverrideRequest();
    message.override = (object.override !== undefined && object.override !== null)
      ? MetricLevelOverride.fromPartial(object.override)
      : undefined;
    return message;
  },
};

function createBaseDeleteMetricLevelOverrideRequest(): DeleteMetricLevelOverrideRequest {
  return { id: "" };
}

export const DeleteMetricLevelOverrideRequest = {
  encode(message: DeleteMetricLevelOverrideRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteMetricLevelOverrideRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMetricLevelOverrideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMetricLevelOverrideRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteMetricLevelOverrideRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteMetricLevelOverrideRequest>): DeleteMetricLevelOverrideRequest {
    return DeleteMetricLevelOverrideRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteMetricLevelOverrideRequest>): DeleteMetricLevelOverrideRequest {
    const message = createBaseDeleteMetricLevelOverrideRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListMetricLevelOverridesRequest(): ListMetricLevelOverridesRequest {
  return { wfSpecFilter: undefined, taskDefFilter: undefined };
}

export const ListMetricLevelOverridesRequest = {
  encode(message: ListMetricLevelOverridesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpecFilter !== undefined) {
      WfSpecId.encode(message.wfSpecFilter, writer.uint32(10).fork()).ldelim();
    }
    if (message.taskDefFilter !== undefined) {
      TaskDefId.encode(message.taskDefFilter, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListMetricLevelOverridesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMetricLevelOverridesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpecFilter = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskDefFilter = TaskDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMetricLevelOverridesRequest {
    return {
      wfSpecFilter: isSet(object.wfSpecFilter) ? WfSpecId.fromJSON(object.wfSpecFilter) : undefined,
      taskDefFilter: isSet(object.taskDefFilter) ? TaskDefId.fromJSON(object.taskDefFilter) : undefined,
    };
  },

  toJSON(message: ListMetricLevelOverridesRequest): unknown {
    const obj: any = {};
    if (message.wfSpecFilter !== undefined) {
      obj.wfSpecFilter = WfSpecId.toJSON(message.wfSpecFilter);
    }
    if (message.taskDefFilter !== undefined) {
      obj.taskDefFilter = TaskDefId.toJSON(message.taskDefFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<ListMetricLevelOverridesRequest>): ListMetricLevelOverridesRequest {
    return ListMetricLevelOverridesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMetricLevelOverridesRequest>): ListMetricLevelOverridesRequest {
    const message = createBaseListMetricLevelOverridesRequest();
    message.wfSpecFilter = (object.wfSpecFilter !== undefined && object.wfSpecFilter !== null)
      ? WfSpecId.fromPartial(object.wfSpecFilter)
      : undefined;
    message.taskDefFilter = (object.taskDefFilter !== undefined && object.taskDefFilter !== null)
      ? TaskDefId.fromPartial(object.taskDefFilter)
      : undefined;
    return message;
  },
};

function createBaseMetricLevelOverridesList(): MetricLevelOverridesList {
  return { overrides: [] };
}

export const MetricLevelOverridesList = {
  encode(message: MetricLevelOverridesList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.overrides) {
      MetricLevelOverride.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricLevelOverridesList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricLevelOverridesList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.overrides.push(MetricLevelOverride.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricLevelOverridesList {
    return {
      overrides: globalThis.Array.isArray(object?.overrides)
        ? object.overrides.map((e: any) => MetricLevelOverride.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetricLevelOverridesList): unknown {
    const obj: any = {};
    if (message.overrides?.length) {
      obj.overrides = message.overrides.map((e) => MetricLevelOverride.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MetricLevelOverridesList>): MetricLevelOverridesList {
    return MetricLevelOverridesList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricLevelOverridesList>): MetricLevelOverridesList {
    const message = createBaseMetricLevelOverridesList();
    message.overrides = object.overrides?.map((e) => MetricLevelOverride.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
