// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.32.1
// source: metrics.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  LHStatus,
  lHStatusFromJSON,
  lHStatusToJSON,
  lHStatusToNumber,
  TaskStatus,
  taskStatusFromJSON,
  taskStatusToJSON,
  taskStatusToNumber,
} from "./common_enums";
import { Timestamp } from "./google/protobuf/timestamp";
import { TaskDefId, WfSpecId } from "./object_id";
import {
  UserTaskRunStatus,
  userTaskRunStatusFromJSON,
  userTaskRunStatusToJSON,
  userTaskRunStatusToNumber,
} from "./user_tasks";

export interface LHTransition {
  fromStatus: LHStatus;
  toStatus: LHStatus;
}

export interface TaskTransition {
  fromStatus: TaskStatus;
  toStatus: TaskStatus;
}

export interface UserTaskTransition {
  fromStatus: UserTaskRunStatus;
  toStatus: UserTaskRunStatus;
}

export interface StatusTransition {
  transition?:
    | { $case: "lhTransition"; value: LHTransition }
    | { $case: "taskTransition"; value: TaskTransition }
    | { $case: "userTaskTransition"; value: UserTaskTransition }
    | { $case: "nodeTransition"; value: LHTransition }
    | undefined;
}

export interface MetricScope {
  type?:
    | { $case: "wfSpec"; value: WfSpecId }
    | { $case: "taskDef"; value: TaskDefId }
    | { $case: "node"; value: NodeReference }
    | { $case: "global"; value: boolean }
    | undefined;
}

export interface NodeReference {
  wfSpec: WfSpecId | undefined;
  threadName?: string | undefined;
  nodeName?: string | undefined;
  taskDef?: TaskDefId | undefined;
}

export interface MetricSpec {
  id: string;
  createdAt: string | undefined;
  scope: MetricScope | undefined;
  transition: StatusTransition | undefined;
}

export interface WorkflowMetricId {
  /** If null, tenant-level aggregate */
  wfSpec?: WfSpecId | undefined;
}

export interface TaskMetricId {
  /** If null, tenant-level aggregate */
  taskDef?: TaskDefId | undefined;
}

export interface NodeMetricId {
  wfSpec: WfSpecId | undefined;
  nodeName: string;
  /** Position within the ThreadSpec for ordering */
  nodePosition: number;
}

export interface MetricWindowId {
  id?: { $case: "workflow"; value: WorkflowMetricId } | { $case: "task"; value: TaskMetricId } | {
    $case: "node";
    value: NodeMetricId;
  } | undefined;
  windowStart: string | undefined;
}

export interface CountAndTiming {
  count: number;
  minLatencyMs: number;
  maxLatencyMs: number;
  totalLatencyMs: number;
}

export interface MetricWindow {
  id: MetricWindowId | undefined;
  metrics: { [key: string]: CountAndTiming };
}

export interface MetricWindow_MetricsEntry {
  key: string;
  value: CountAndTiming | undefined;
}

export interface ListMetricsRequest {
  /** Metric window id contains object and start time */
  id:
    | MetricWindowId
    | undefined;
  /** Optional: if not set, server uses current time */
  endTime?: string | undefined;
}

export interface MetricList {
  windows: MetricWindow[];
}

function createBaseLHTransition(): LHTransition {
  return { fromStatus: LHStatus.STARTING, toStatus: LHStatus.STARTING };
}

export const LHTransition = {
  encode(message: LHTransition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromStatus !== LHStatus.STARTING) {
      writer.uint32(8).int32(lHStatusToNumber(message.fromStatus));
    }
    if (message.toStatus !== LHStatus.STARTING) {
      writer.uint32(16).int32(lHStatusToNumber(message.toStatus));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LHTransition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLHTransition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromStatus = lHStatusFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toStatus = lHStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LHTransition {
    return {
      fromStatus: isSet(object.fromStatus) ? lHStatusFromJSON(object.fromStatus) : LHStatus.STARTING,
      toStatus: isSet(object.toStatus) ? lHStatusFromJSON(object.toStatus) : LHStatus.STARTING,
    };
  },

  toJSON(message: LHTransition): unknown {
    const obj: any = {};
    if (message.fromStatus !== LHStatus.STARTING) {
      obj.fromStatus = lHStatusToJSON(message.fromStatus);
    }
    if (message.toStatus !== LHStatus.STARTING) {
      obj.toStatus = lHStatusToJSON(message.toStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<LHTransition>): LHTransition {
    return LHTransition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LHTransition>): LHTransition {
    const message = createBaseLHTransition();
    message.fromStatus = object.fromStatus ?? LHStatus.STARTING;
    message.toStatus = object.toStatus ?? LHStatus.STARTING;
    return message;
  },
};

function createBaseTaskTransition(): TaskTransition {
  return { fromStatus: TaskStatus.TASK_SCHEDULED, toStatus: TaskStatus.TASK_SCHEDULED };
}

export const TaskTransition = {
  encode(message: TaskTransition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromStatus !== TaskStatus.TASK_SCHEDULED) {
      writer.uint32(8).int32(taskStatusToNumber(message.fromStatus));
    }
    if (message.toStatus !== TaskStatus.TASK_SCHEDULED) {
      writer.uint32(16).int32(taskStatusToNumber(message.toStatus));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskTransition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskTransition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromStatus = taskStatusFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toStatus = taskStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskTransition {
    return {
      fromStatus: isSet(object.fromStatus) ? taskStatusFromJSON(object.fromStatus) : TaskStatus.TASK_SCHEDULED,
      toStatus: isSet(object.toStatus) ? taskStatusFromJSON(object.toStatus) : TaskStatus.TASK_SCHEDULED,
    };
  },

  toJSON(message: TaskTransition): unknown {
    const obj: any = {};
    if (message.fromStatus !== TaskStatus.TASK_SCHEDULED) {
      obj.fromStatus = taskStatusToJSON(message.fromStatus);
    }
    if (message.toStatus !== TaskStatus.TASK_SCHEDULED) {
      obj.toStatus = taskStatusToJSON(message.toStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskTransition>): TaskTransition {
    return TaskTransition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskTransition>): TaskTransition {
    const message = createBaseTaskTransition();
    message.fromStatus = object.fromStatus ?? TaskStatus.TASK_SCHEDULED;
    message.toStatus = object.toStatus ?? TaskStatus.TASK_SCHEDULED;
    return message;
  },
};

function createBaseUserTaskTransition(): UserTaskTransition {
  return { fromStatus: UserTaskRunStatus.UNASSIGNED, toStatus: UserTaskRunStatus.UNASSIGNED };
}

export const UserTaskTransition = {
  encode(message: UserTaskTransition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromStatus !== UserTaskRunStatus.UNASSIGNED) {
      writer.uint32(8).int32(userTaskRunStatusToNumber(message.fromStatus));
    }
    if (message.toStatus !== UserTaskRunStatus.UNASSIGNED) {
      writer.uint32(16).int32(userTaskRunStatusToNumber(message.toStatus));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskTransition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskTransition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromStatus = userTaskRunStatusFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toStatus = userTaskRunStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskTransition {
    return {
      fromStatus: isSet(object.fromStatus)
        ? userTaskRunStatusFromJSON(object.fromStatus)
        : UserTaskRunStatus.UNASSIGNED,
      toStatus: isSet(object.toStatus) ? userTaskRunStatusFromJSON(object.toStatus) : UserTaskRunStatus.UNASSIGNED,
    };
  },

  toJSON(message: UserTaskTransition): unknown {
    const obj: any = {};
    if (message.fromStatus !== UserTaskRunStatus.UNASSIGNED) {
      obj.fromStatus = userTaskRunStatusToJSON(message.fromStatus);
    }
    if (message.toStatus !== UserTaskRunStatus.UNASSIGNED) {
      obj.toStatus = userTaskRunStatusToJSON(message.toStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskTransition>): UserTaskTransition {
    return UserTaskTransition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskTransition>): UserTaskTransition {
    const message = createBaseUserTaskTransition();
    message.fromStatus = object.fromStatus ?? UserTaskRunStatus.UNASSIGNED;
    message.toStatus = object.toStatus ?? UserTaskRunStatus.UNASSIGNED;
    return message;
  },
};

function createBaseStatusTransition(): StatusTransition {
  return { transition: undefined };
}

export const StatusTransition = {
  encode(message: StatusTransition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.transition?.$case) {
      case "lhTransition":
        LHTransition.encode(message.transition.value, writer.uint32(10).fork()).ldelim();
        break;
      case "taskTransition":
        TaskTransition.encode(message.transition.value, writer.uint32(18).fork()).ldelim();
        break;
      case "userTaskTransition":
        UserTaskTransition.encode(message.transition.value, writer.uint32(26).fork()).ldelim();
        break;
      case "nodeTransition":
        LHTransition.encode(message.transition.value, writer.uint32(34).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusTransition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusTransition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transition = { $case: "lhTransition", value: LHTransition.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transition = { $case: "taskTransition", value: TaskTransition.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transition = {
            $case: "userTaskTransition",
            value: UserTaskTransition.decode(reader, reader.uint32()),
          };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transition = { $case: "nodeTransition", value: LHTransition.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusTransition {
    return {
      transition: isSet(object.lhTransition)
        ? { $case: "lhTransition", value: LHTransition.fromJSON(object.lhTransition) }
        : isSet(object.taskTransition)
        ? { $case: "taskTransition", value: TaskTransition.fromJSON(object.taskTransition) }
        : isSet(object.userTaskTransition)
        ? { $case: "userTaskTransition", value: UserTaskTransition.fromJSON(object.userTaskTransition) }
        : isSet(object.nodeTransition)
        ? { $case: "nodeTransition", value: LHTransition.fromJSON(object.nodeTransition) }
        : undefined,
    };
  },

  toJSON(message: StatusTransition): unknown {
    const obj: any = {};
    if (message.transition?.$case === "lhTransition") {
      obj.lhTransition = LHTransition.toJSON(message.transition.value);
    }
    if (message.transition?.$case === "taskTransition") {
      obj.taskTransition = TaskTransition.toJSON(message.transition.value);
    }
    if (message.transition?.$case === "userTaskTransition") {
      obj.userTaskTransition = UserTaskTransition.toJSON(message.transition.value);
    }
    if (message.transition?.$case === "nodeTransition") {
      obj.nodeTransition = LHTransition.toJSON(message.transition.value);
    }
    return obj;
  },

  create(base?: DeepPartial<StatusTransition>): StatusTransition {
    return StatusTransition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StatusTransition>): StatusTransition {
    const message = createBaseStatusTransition();
    if (
      object.transition?.$case === "lhTransition" &&
      object.transition?.value !== undefined &&
      object.transition?.value !== null
    ) {
      message.transition = { $case: "lhTransition", value: LHTransition.fromPartial(object.transition.value) };
    }
    if (
      object.transition?.$case === "taskTransition" &&
      object.transition?.value !== undefined &&
      object.transition?.value !== null
    ) {
      message.transition = { $case: "taskTransition", value: TaskTransition.fromPartial(object.transition.value) };
    }
    if (
      object.transition?.$case === "userTaskTransition" &&
      object.transition?.value !== undefined &&
      object.transition?.value !== null
    ) {
      message.transition = {
        $case: "userTaskTransition",
        value: UserTaskTransition.fromPartial(object.transition.value),
      };
    }
    if (
      object.transition?.$case === "nodeTransition" &&
      object.transition?.value !== undefined &&
      object.transition?.value !== null
    ) {
      message.transition = { $case: "nodeTransition", value: LHTransition.fromPartial(object.transition.value) };
    }
    return message;
  },
};

function createBaseMetricScope(): MetricScope {
  return { type: undefined };
}

export const MetricScope = {
  encode(message: MetricScope, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.type?.$case) {
      case "wfSpec":
        WfSpecId.encode(message.type.value, writer.uint32(10).fork()).ldelim();
        break;
      case "taskDef":
        TaskDefId.encode(message.type.value, writer.uint32(18).fork()).ldelim();
        break;
      case "node":
        NodeReference.encode(message.type.value, writer.uint32(26).fork()).ldelim();
        break;
      case "global":
        writer.uint32(32).bool(message.type.value);
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricScope {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricScope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = { $case: "wfSpec", value: WfSpecId.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = { $case: "taskDef", value: TaskDefId.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = { $case: "node", value: NodeReference.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = { $case: "global", value: reader.bool() };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricScope {
    return {
      type: isSet(object.wfSpec)
        ? { $case: "wfSpec", value: WfSpecId.fromJSON(object.wfSpec) }
        : isSet(object.taskDef)
        ? { $case: "taskDef", value: TaskDefId.fromJSON(object.taskDef) }
        : isSet(object.node)
        ? { $case: "node", value: NodeReference.fromJSON(object.node) }
        : isSet(object.global)
        ? { $case: "global", value: globalThis.Boolean(object.global) }
        : undefined,
    };
  },

  toJSON(message: MetricScope): unknown {
    const obj: any = {};
    if (message.type?.$case === "wfSpec") {
      obj.wfSpec = WfSpecId.toJSON(message.type.value);
    }
    if (message.type?.$case === "taskDef") {
      obj.taskDef = TaskDefId.toJSON(message.type.value);
    }
    if (message.type?.$case === "node") {
      obj.node = NodeReference.toJSON(message.type.value);
    }
    if (message.type?.$case === "global") {
      obj.global = message.type.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MetricScope>): MetricScope {
    return MetricScope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricScope>): MetricScope {
    const message = createBaseMetricScope();
    if (object.type?.$case === "wfSpec" && object.type?.value !== undefined && object.type?.value !== null) {
      message.type = { $case: "wfSpec", value: WfSpecId.fromPartial(object.type.value) };
    }
    if (object.type?.$case === "taskDef" && object.type?.value !== undefined && object.type?.value !== null) {
      message.type = { $case: "taskDef", value: TaskDefId.fromPartial(object.type.value) };
    }
    if (object.type?.$case === "node" && object.type?.value !== undefined && object.type?.value !== null) {
      message.type = { $case: "node", value: NodeReference.fromPartial(object.type.value) };
    }
    if (object.type?.$case === "global" && object.type?.value !== undefined && object.type?.value !== null) {
      message.type = { $case: "global", value: object.type.value };
    }
    return message;
  },
};

function createBaseNodeReference(): NodeReference {
  return { wfSpec: undefined, threadName: undefined, nodeName: undefined, taskDef: undefined };
}

export const NodeReference = {
  encode(message: NodeReference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpec !== undefined) {
      WfSpecId.encode(message.wfSpec, writer.uint32(10).fork()).ldelim();
    }
    if (message.threadName !== undefined) {
      writer.uint32(18).string(message.threadName);
    }
    if (message.nodeName !== undefined) {
      writer.uint32(26).string(message.nodeName);
    }
    if (message.taskDef !== undefined) {
      TaskDefId.encode(message.taskDef, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeReference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpec = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.threadName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodeName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.taskDef = TaskDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeReference {
    return {
      wfSpec: isSet(object.wfSpec) ? WfSpecId.fromJSON(object.wfSpec) : undefined,
      threadName: isSet(object.threadName) ? globalThis.String(object.threadName) : undefined,
      nodeName: isSet(object.nodeName) ? globalThis.String(object.nodeName) : undefined,
      taskDef: isSet(object.taskDef) ? TaskDefId.fromJSON(object.taskDef) : undefined,
    };
  },

  toJSON(message: NodeReference): unknown {
    const obj: any = {};
    if (message.wfSpec !== undefined) {
      obj.wfSpec = WfSpecId.toJSON(message.wfSpec);
    }
    if (message.threadName !== undefined) {
      obj.threadName = message.threadName;
    }
    if (message.nodeName !== undefined) {
      obj.nodeName = message.nodeName;
    }
    if (message.taskDef !== undefined) {
      obj.taskDef = TaskDefId.toJSON(message.taskDef);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeReference>): NodeReference {
    return NodeReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeReference>): NodeReference {
    const message = createBaseNodeReference();
    message.wfSpec = (object.wfSpec !== undefined && object.wfSpec !== null)
      ? WfSpecId.fromPartial(object.wfSpec)
      : undefined;
    message.threadName = object.threadName ?? undefined;
    message.nodeName = object.nodeName ?? undefined;
    message.taskDef = (object.taskDef !== undefined && object.taskDef !== null)
      ? TaskDefId.fromPartial(object.taskDef)
      : undefined;
    return message;
  },
};

function createBaseMetricSpec(): MetricSpec {
  return { id: "", createdAt: undefined, scope: undefined, transition: undefined };
}

export const MetricSpec = {
  encode(message: MetricSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).ldelim();
    }
    if (message.scope !== undefined) {
      MetricScope.encode(message.scope, writer.uint32(26).fork()).ldelim();
    }
    if (message.transition !== undefined) {
      StatusTransition.encode(message.transition, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricSpec {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.scope = MetricScope.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transition = StatusTransition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricSpec {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : undefined,
      scope: isSet(object.scope) ? MetricScope.fromJSON(object.scope) : undefined,
      transition: isSet(object.transition) ? StatusTransition.fromJSON(object.transition) : undefined,
    };
  },

  toJSON(message: MetricSpec): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt;
    }
    if (message.scope !== undefined) {
      obj.scope = MetricScope.toJSON(message.scope);
    }
    if (message.transition !== undefined) {
      obj.transition = StatusTransition.toJSON(message.transition);
    }
    return obj;
  },

  create(base?: DeepPartial<MetricSpec>): MetricSpec {
    return MetricSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricSpec>): MetricSpec {
    const message = createBaseMetricSpec();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.scope = (object.scope !== undefined && object.scope !== null)
      ? MetricScope.fromPartial(object.scope)
      : undefined;
    message.transition = (object.transition !== undefined && object.transition !== null)
      ? StatusTransition.fromPartial(object.transition)
      : undefined;
    return message;
  },
};

function createBaseWorkflowMetricId(): WorkflowMetricId {
  return { wfSpec: undefined };
}

export const WorkflowMetricId = {
  encode(message: WorkflowMetricId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpec !== undefined) {
      WfSpecId.encode(message.wfSpec, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowMetricId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowMetricId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpec = WfSpecId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowMetricId {
    return { wfSpec: isSet(object.wfSpec) ? WfSpecId.fromJSON(object.wfSpec) : undefined };
  },

  toJSON(message: WorkflowMetricId): unknown {
    const obj: any = {};
    if (message.wfSpec !== undefined) {
      obj.wfSpec = WfSpecId.toJSON(message.wfSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkflowMetricId>): WorkflowMetricId {
    return WorkflowMetricId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowMetricId>): WorkflowMetricId {
    const message = createBaseWorkflowMetricId();
    message.wfSpec = (object.wfSpec !== undefined && object.wfSpec !== null)
      ? WfSpecId.fromPartial(object.wfSpec)
      : undefined;
    return message;
  },
};

function createBaseTaskMetricId(): TaskMetricId {
  return { taskDef: undefined };
}

export const TaskMetricId = {
  encode(message: TaskMetricId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskDef !== undefined) {
      TaskDefId.encode(message.taskDef, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskMetricId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskMetricId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskDef = TaskDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskMetricId {
    return { taskDef: isSet(object.taskDef) ? TaskDefId.fromJSON(object.taskDef) : undefined };
  },

  toJSON(message: TaskMetricId): unknown {
    const obj: any = {};
    if (message.taskDef !== undefined) {
      obj.taskDef = TaskDefId.toJSON(message.taskDef);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskMetricId>): TaskMetricId {
    return TaskMetricId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskMetricId>): TaskMetricId {
    const message = createBaseTaskMetricId();
    message.taskDef = (object.taskDef !== undefined && object.taskDef !== null)
      ? TaskDefId.fromPartial(object.taskDef)
      : undefined;
    return message;
  },
};

function createBaseNodeMetricId(): NodeMetricId {
  return { wfSpec: undefined, nodeName: "", nodePosition: 0 };
}

export const NodeMetricId = {
  encode(message: NodeMetricId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpec !== undefined) {
      WfSpecId.encode(message.wfSpec, writer.uint32(10).fork()).ldelim();
    }
    if (message.nodeName !== "") {
      writer.uint32(18).string(message.nodeName);
    }
    if (message.nodePosition !== 0) {
      writer.uint32(24).int32(message.nodePosition);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeMetricId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeMetricId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpec = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nodePosition = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeMetricId {
    return {
      wfSpec: isSet(object.wfSpec) ? WfSpecId.fromJSON(object.wfSpec) : undefined,
      nodeName: isSet(object.nodeName) ? globalThis.String(object.nodeName) : "",
      nodePosition: isSet(object.nodePosition) ? globalThis.Number(object.nodePosition) : 0,
    };
  },

  toJSON(message: NodeMetricId): unknown {
    const obj: any = {};
    if (message.wfSpec !== undefined) {
      obj.wfSpec = WfSpecId.toJSON(message.wfSpec);
    }
    if (message.nodeName !== "") {
      obj.nodeName = message.nodeName;
    }
    if (message.nodePosition !== 0) {
      obj.nodePosition = Math.round(message.nodePosition);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeMetricId>): NodeMetricId {
    return NodeMetricId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeMetricId>): NodeMetricId {
    const message = createBaseNodeMetricId();
    message.wfSpec = (object.wfSpec !== undefined && object.wfSpec !== null)
      ? WfSpecId.fromPartial(object.wfSpec)
      : undefined;
    message.nodeName = object.nodeName ?? "";
    message.nodePosition = object.nodePosition ?? 0;
    return message;
  },
};

function createBaseMetricWindowId(): MetricWindowId {
  return { id: undefined, windowStart: undefined };
}

export const MetricWindowId = {
  encode(message: MetricWindowId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.id?.$case) {
      case "workflow":
        WorkflowMetricId.encode(message.id.value, writer.uint32(10).fork()).ldelim();
        break;
      case "task":
        TaskMetricId.encode(message.id.value, writer.uint32(18).fork()).ldelim();
        break;
      case "node":
        NodeMetricId.encode(message.id.value, writer.uint32(26).fork()).ldelim();
        break;
    }
    if (message.windowStart !== undefined) {
      Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricWindowId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricWindowId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = { $case: "workflow", value: WorkflowMetricId.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = { $case: "task", value: TaskMetricId.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = { $case: "node", value: NodeMetricId.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.windowStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricWindowId {
    return {
      id: isSet(object.workflow)
        ? { $case: "workflow", value: WorkflowMetricId.fromJSON(object.workflow) }
        : isSet(object.task)
        ? { $case: "task", value: TaskMetricId.fromJSON(object.task) }
        : isSet(object.node)
        ? { $case: "node", value: NodeMetricId.fromJSON(object.node) }
        : undefined,
      windowStart: isSet(object.windowStart) ? globalThis.String(object.windowStart) : undefined,
    };
  },

  toJSON(message: MetricWindowId): unknown {
    const obj: any = {};
    if (message.id?.$case === "workflow") {
      obj.workflow = WorkflowMetricId.toJSON(message.id.value);
    }
    if (message.id?.$case === "task") {
      obj.task = TaskMetricId.toJSON(message.id.value);
    }
    if (message.id?.$case === "node") {
      obj.node = NodeMetricId.toJSON(message.id.value);
    }
    if (message.windowStart !== undefined) {
      obj.windowStart = message.windowStart;
    }
    return obj;
  },

  create(base?: DeepPartial<MetricWindowId>): MetricWindowId {
    return MetricWindowId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricWindowId>): MetricWindowId {
    const message = createBaseMetricWindowId();
    if (object.id?.$case === "workflow" && object.id?.value !== undefined && object.id?.value !== null) {
      message.id = { $case: "workflow", value: WorkflowMetricId.fromPartial(object.id.value) };
    }
    if (object.id?.$case === "task" && object.id?.value !== undefined && object.id?.value !== null) {
      message.id = { $case: "task", value: TaskMetricId.fromPartial(object.id.value) };
    }
    if (object.id?.$case === "node" && object.id?.value !== undefined && object.id?.value !== null) {
      message.id = { $case: "node", value: NodeMetricId.fromPartial(object.id.value) };
    }
    message.windowStart = object.windowStart ?? undefined;
    return message;
  },
};

function createBaseCountAndTiming(): CountAndTiming {
  return { count: 0, minLatencyMs: 0, maxLatencyMs: 0, totalLatencyMs: 0 };
}

export const CountAndTiming = {
  encode(message: CountAndTiming, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== 0) {
      writer.uint32(8).int32(message.count);
    }
    if (message.minLatencyMs !== 0) {
      writer.uint32(16).int64(message.minLatencyMs);
    }
    if (message.maxLatencyMs !== 0) {
      writer.uint32(24).int64(message.maxLatencyMs);
    }
    if (message.totalLatencyMs !== 0) {
      writer.uint32(32).int64(message.totalLatencyMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CountAndTiming {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountAndTiming();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minLatencyMs = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxLatencyMs = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalLatencyMs = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CountAndTiming {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      minLatencyMs: isSet(object.minLatencyMs) ? globalThis.Number(object.minLatencyMs) : 0,
      maxLatencyMs: isSet(object.maxLatencyMs) ? globalThis.Number(object.maxLatencyMs) : 0,
      totalLatencyMs: isSet(object.totalLatencyMs) ? globalThis.Number(object.totalLatencyMs) : 0,
    };
  },

  toJSON(message: CountAndTiming): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.minLatencyMs !== 0) {
      obj.minLatencyMs = Math.round(message.minLatencyMs);
    }
    if (message.maxLatencyMs !== 0) {
      obj.maxLatencyMs = Math.round(message.maxLatencyMs);
    }
    if (message.totalLatencyMs !== 0) {
      obj.totalLatencyMs = Math.round(message.totalLatencyMs);
    }
    return obj;
  },

  create(base?: DeepPartial<CountAndTiming>): CountAndTiming {
    return CountAndTiming.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CountAndTiming>): CountAndTiming {
    const message = createBaseCountAndTiming();
    message.count = object.count ?? 0;
    message.minLatencyMs = object.minLatencyMs ?? 0;
    message.maxLatencyMs = object.maxLatencyMs ?? 0;
    message.totalLatencyMs = object.totalLatencyMs ?? 0;
    return message;
  },
};

function createBaseMetricWindow(): MetricWindow {
  return { id: undefined, metrics: {} };
}

export const MetricWindow = {
  encode(message: MetricWindow, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      MetricWindowId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.metrics).forEach(([key, value]) => {
      MetricWindow_MetricsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricWindow {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = MetricWindowId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = MetricWindow_MetricsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metrics[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricWindow {
    return {
      id: isSet(object.id) ? MetricWindowId.fromJSON(object.id) : undefined,
      metrics: isObject(object.metrics)
        ? Object.entries(object.metrics).reduce<{ [key: string]: CountAndTiming }>((acc, [key, value]) => {
          acc[key] = CountAndTiming.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MetricWindow): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = MetricWindowId.toJSON(message.id);
    }
    if (message.metrics) {
      const entries = Object.entries(message.metrics);
      if (entries.length > 0) {
        obj.metrics = {};
        entries.forEach(([k, v]) => {
          obj.metrics[k] = CountAndTiming.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MetricWindow>): MetricWindow {
    return MetricWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricWindow>): MetricWindow {
    const message = createBaseMetricWindow();
    message.id = (object.id !== undefined && object.id !== null) ? MetricWindowId.fromPartial(object.id) : undefined;
    message.metrics = Object.entries(object.metrics ?? {}).reduce<{ [key: string]: CountAndTiming }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = CountAndTiming.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMetricWindow_MetricsEntry(): MetricWindow_MetricsEntry {
  return { key: "", value: undefined };
}

export const MetricWindow_MetricsEntry = {
  encode(message: MetricWindow_MetricsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CountAndTiming.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricWindow_MetricsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricWindow_MetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CountAndTiming.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricWindow_MetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CountAndTiming.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MetricWindow_MetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CountAndTiming.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MetricWindow_MetricsEntry>): MetricWindow_MetricsEntry {
    return MetricWindow_MetricsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricWindow_MetricsEntry>): MetricWindow_MetricsEntry {
    const message = createBaseMetricWindow_MetricsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CountAndTiming.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseListMetricsRequest(): ListMetricsRequest {
  return { id: undefined, endTime: undefined };
}

export const ListMetricsRequest = {
  encode(message: ListMetricsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      MetricWindowId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListMetricsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = MetricWindowId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMetricsRequest {
    return {
      id: isSet(object.id) ? MetricWindowId.fromJSON(object.id) : undefined,
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : undefined,
    };
  },

  toJSON(message: ListMetricsRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = MetricWindowId.toJSON(message.id);
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMetricsRequest>): ListMetricsRequest {
    return ListMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMetricsRequest>): ListMetricsRequest {
    const message = createBaseListMetricsRequest();
    message.id = (object.id !== undefined && object.id !== null) ? MetricWindowId.fromPartial(object.id) : undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseMetricList(): MetricList {
  return { windows: [] };
}

export const MetricList = {
  encode(message: MetricList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.windows) {
      MetricWindow.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.windows.push(MetricWindow.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricList {
    return {
      windows: globalThis.Array.isArray(object?.windows)
        ? object.windows.map((e: any) => MetricWindow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetricList): unknown {
    const obj: any = {};
    if (message.windows?.length) {
      obj.windows = message.windows.map((e) => MetricWindow.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MetricList>): MetricList {
    return MetricList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricList>): MetricList {
    const message = createBaseMetricList();
    message.windows = object.windows?.map((e) => MetricWindow.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
