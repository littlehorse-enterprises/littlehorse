// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.32.1
// source: metrics.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "./google/protobuf/timestamp";
import { TaskDefId, WfSpecId } from "./object_id";

export interface WorkflowMetricId {
  /** If null, tenant-level aggregate */
  wfSpec?: WfSpecId | undefined;
}

export interface TaskMetricId {
  /** If null, tenant-level aggregate */
  taskDef?: TaskDefId | undefined;
}

export interface NodeMetricId {
  wfSpec: WfSpecId | undefined;
  nodeName: string;
  /** Position within the ThreadSpec for ordering */
  nodePosition: number;
}

export interface MetricWindowId {
  id?: { $case: "workflow"; value: WorkflowMetricId } | { $case: "task"; value: TaskMetricId } | {
    $case: "node";
    value: NodeMetricId;
  } | undefined;
  windowStart: string | undefined;
}

export interface CountAndTiming {
  count: number;
  minLatencyMs: number;
  maxLatencyMs: number;
  totalLatencyMs: number;
}

export interface MetricWindow {
  id: MetricWindowId | undefined;
  metrics: { [key: string]: CountAndTiming };
}

export interface MetricWindow_MetricsEntry {
  key: string;
  value: CountAndTiming | undefined;
}

export interface ListWfMetricsRequest {
  wfSpec: WfSpecId | undefined;
  windowStart?: string | undefined;
  windowEnd?: string | undefined;
}

export interface MetricsList {
  windows: MetricWindow[];
}

function createBaseWorkflowMetricId(): WorkflowMetricId {
  return { wfSpec: undefined };
}

export const WorkflowMetricId = {
  encode(message: WorkflowMetricId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpec !== undefined) {
      WfSpecId.encode(message.wfSpec, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowMetricId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowMetricId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpec = WfSpecId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowMetricId {
    return { wfSpec: isSet(object.wfSpec) ? WfSpecId.fromJSON(object.wfSpec) : undefined };
  },

  toJSON(message: WorkflowMetricId): unknown {
    const obj: any = {};
    if (message.wfSpec !== undefined) {
      obj.wfSpec = WfSpecId.toJSON(message.wfSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkflowMetricId>): WorkflowMetricId {
    return WorkflowMetricId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowMetricId>): WorkflowMetricId {
    const message = createBaseWorkflowMetricId();
    message.wfSpec = (object.wfSpec !== undefined && object.wfSpec !== null)
      ? WfSpecId.fromPartial(object.wfSpec)
      : undefined;
    return message;
  },
};

function createBaseTaskMetricId(): TaskMetricId {
  return { taskDef: undefined };
}

export const TaskMetricId = {
  encode(message: TaskMetricId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskDef !== undefined) {
      TaskDefId.encode(message.taskDef, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskMetricId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskMetricId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskDef = TaskDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskMetricId {
    return { taskDef: isSet(object.taskDef) ? TaskDefId.fromJSON(object.taskDef) : undefined };
  },

  toJSON(message: TaskMetricId): unknown {
    const obj: any = {};
    if (message.taskDef !== undefined) {
      obj.taskDef = TaskDefId.toJSON(message.taskDef);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskMetricId>): TaskMetricId {
    return TaskMetricId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskMetricId>): TaskMetricId {
    const message = createBaseTaskMetricId();
    message.taskDef = (object.taskDef !== undefined && object.taskDef !== null)
      ? TaskDefId.fromPartial(object.taskDef)
      : undefined;
    return message;
  },
};

function createBaseNodeMetricId(): NodeMetricId {
  return { wfSpec: undefined, nodeName: "", nodePosition: 0 };
}

export const NodeMetricId = {
  encode(message: NodeMetricId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpec !== undefined) {
      WfSpecId.encode(message.wfSpec, writer.uint32(10).fork()).ldelim();
    }
    if (message.nodeName !== "") {
      writer.uint32(18).string(message.nodeName);
    }
    if (message.nodePosition !== 0) {
      writer.uint32(24).int32(message.nodePosition);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeMetricId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeMetricId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpec = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nodePosition = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeMetricId {
    return {
      wfSpec: isSet(object.wfSpec) ? WfSpecId.fromJSON(object.wfSpec) : undefined,
      nodeName: isSet(object.nodeName) ? globalThis.String(object.nodeName) : "",
      nodePosition: isSet(object.nodePosition) ? globalThis.Number(object.nodePosition) : 0,
    };
  },

  toJSON(message: NodeMetricId): unknown {
    const obj: any = {};
    if (message.wfSpec !== undefined) {
      obj.wfSpec = WfSpecId.toJSON(message.wfSpec);
    }
    if (message.nodeName !== "") {
      obj.nodeName = message.nodeName;
    }
    if (message.nodePosition !== 0) {
      obj.nodePosition = Math.round(message.nodePosition);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeMetricId>): NodeMetricId {
    return NodeMetricId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeMetricId>): NodeMetricId {
    const message = createBaseNodeMetricId();
    message.wfSpec = (object.wfSpec !== undefined && object.wfSpec !== null)
      ? WfSpecId.fromPartial(object.wfSpec)
      : undefined;
    message.nodeName = object.nodeName ?? "";
    message.nodePosition = object.nodePosition ?? 0;
    return message;
  },
};

function createBaseMetricWindowId(): MetricWindowId {
  return { id: undefined, windowStart: undefined };
}

export const MetricWindowId = {
  encode(message: MetricWindowId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.id?.$case) {
      case "workflow":
        WorkflowMetricId.encode(message.id.value, writer.uint32(10).fork()).ldelim();
        break;
      case "task":
        TaskMetricId.encode(message.id.value, writer.uint32(18).fork()).ldelim();
        break;
      case "node":
        NodeMetricId.encode(message.id.value, writer.uint32(26).fork()).ldelim();
        break;
    }
    if (message.windowStart !== undefined) {
      Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricWindowId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricWindowId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = { $case: "workflow", value: WorkflowMetricId.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = { $case: "task", value: TaskMetricId.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = { $case: "node", value: NodeMetricId.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.windowStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricWindowId {
    return {
      id: isSet(object.workflow)
        ? { $case: "workflow", value: WorkflowMetricId.fromJSON(object.workflow) }
        : isSet(object.task)
        ? { $case: "task", value: TaskMetricId.fromJSON(object.task) }
        : isSet(object.node)
        ? { $case: "node", value: NodeMetricId.fromJSON(object.node) }
        : undefined,
      windowStart: isSet(object.windowStart) ? globalThis.String(object.windowStart) : undefined,
    };
  },

  toJSON(message: MetricWindowId): unknown {
    const obj: any = {};
    if (message.id?.$case === "workflow") {
      obj.workflow = WorkflowMetricId.toJSON(message.id.value);
    }
    if (message.id?.$case === "task") {
      obj.task = TaskMetricId.toJSON(message.id.value);
    }
    if (message.id?.$case === "node") {
      obj.node = NodeMetricId.toJSON(message.id.value);
    }
    if (message.windowStart !== undefined) {
      obj.windowStart = message.windowStart;
    }
    return obj;
  },

  create(base?: DeepPartial<MetricWindowId>): MetricWindowId {
    return MetricWindowId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricWindowId>): MetricWindowId {
    const message = createBaseMetricWindowId();
    if (object.id?.$case === "workflow" && object.id?.value !== undefined && object.id?.value !== null) {
      message.id = { $case: "workflow", value: WorkflowMetricId.fromPartial(object.id.value) };
    }
    if (object.id?.$case === "task" && object.id?.value !== undefined && object.id?.value !== null) {
      message.id = { $case: "task", value: TaskMetricId.fromPartial(object.id.value) };
    }
    if (object.id?.$case === "node" && object.id?.value !== undefined && object.id?.value !== null) {
      message.id = { $case: "node", value: NodeMetricId.fromPartial(object.id.value) };
    }
    message.windowStart = object.windowStart ?? undefined;
    return message;
  },
};

function createBaseCountAndTiming(): CountAndTiming {
  return { count: 0, minLatencyMs: 0, maxLatencyMs: 0, totalLatencyMs: 0 };
}

export const CountAndTiming = {
  encode(message: CountAndTiming, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== 0) {
      writer.uint32(8).int32(message.count);
    }
    if (message.minLatencyMs !== 0) {
      writer.uint32(16).int64(message.minLatencyMs);
    }
    if (message.maxLatencyMs !== 0) {
      writer.uint32(24).int64(message.maxLatencyMs);
    }
    if (message.totalLatencyMs !== 0) {
      writer.uint32(32).int64(message.totalLatencyMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CountAndTiming {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountAndTiming();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minLatencyMs = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxLatencyMs = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalLatencyMs = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CountAndTiming {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      minLatencyMs: isSet(object.minLatencyMs) ? globalThis.Number(object.minLatencyMs) : 0,
      maxLatencyMs: isSet(object.maxLatencyMs) ? globalThis.Number(object.maxLatencyMs) : 0,
      totalLatencyMs: isSet(object.totalLatencyMs) ? globalThis.Number(object.totalLatencyMs) : 0,
    };
  },

  toJSON(message: CountAndTiming): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.minLatencyMs !== 0) {
      obj.minLatencyMs = Math.round(message.minLatencyMs);
    }
    if (message.maxLatencyMs !== 0) {
      obj.maxLatencyMs = Math.round(message.maxLatencyMs);
    }
    if (message.totalLatencyMs !== 0) {
      obj.totalLatencyMs = Math.round(message.totalLatencyMs);
    }
    return obj;
  },

  create(base?: DeepPartial<CountAndTiming>): CountAndTiming {
    return CountAndTiming.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CountAndTiming>): CountAndTiming {
    const message = createBaseCountAndTiming();
    message.count = object.count ?? 0;
    message.minLatencyMs = object.minLatencyMs ?? 0;
    message.maxLatencyMs = object.maxLatencyMs ?? 0;
    message.totalLatencyMs = object.totalLatencyMs ?? 0;
    return message;
  },
};

function createBaseMetricWindow(): MetricWindow {
  return { id: undefined, metrics: {} };
}

export const MetricWindow = {
  encode(message: MetricWindow, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      MetricWindowId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.metrics).forEach(([key, value]) => {
      MetricWindow_MetricsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricWindow {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = MetricWindowId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = MetricWindow_MetricsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metrics[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricWindow {
    return {
      id: isSet(object.id) ? MetricWindowId.fromJSON(object.id) : undefined,
      metrics: isObject(object.metrics)
        ? Object.entries(object.metrics).reduce<{ [key: string]: CountAndTiming }>((acc, [key, value]) => {
          acc[key] = CountAndTiming.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MetricWindow): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = MetricWindowId.toJSON(message.id);
    }
    if (message.metrics) {
      const entries = Object.entries(message.metrics);
      if (entries.length > 0) {
        obj.metrics = {};
        entries.forEach(([k, v]) => {
          obj.metrics[k] = CountAndTiming.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MetricWindow>): MetricWindow {
    return MetricWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricWindow>): MetricWindow {
    const message = createBaseMetricWindow();
    message.id = (object.id !== undefined && object.id !== null) ? MetricWindowId.fromPartial(object.id) : undefined;
    message.metrics = Object.entries(object.metrics ?? {}).reduce<{ [key: string]: CountAndTiming }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = CountAndTiming.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMetricWindow_MetricsEntry(): MetricWindow_MetricsEntry {
  return { key: "", value: undefined };
}

export const MetricWindow_MetricsEntry = {
  encode(message: MetricWindow_MetricsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CountAndTiming.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricWindow_MetricsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricWindow_MetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CountAndTiming.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricWindow_MetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CountAndTiming.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MetricWindow_MetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CountAndTiming.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MetricWindow_MetricsEntry>): MetricWindow_MetricsEntry {
    return MetricWindow_MetricsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricWindow_MetricsEntry>): MetricWindow_MetricsEntry {
    const message = createBaseMetricWindow_MetricsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CountAndTiming.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseListWfMetricsRequest(): ListWfMetricsRequest {
  return { wfSpec: undefined, windowStart: undefined, windowEnd: undefined };
}

export const ListWfMetricsRequest = {
  encode(message: ListWfMetricsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpec !== undefined) {
      WfSpecId.encode(message.wfSpec, writer.uint32(10).fork()).ldelim();
    }
    if (message.windowStart !== undefined) {
      Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(18).fork()).ldelim();
    }
    if (message.windowEnd !== undefined) {
      Timestamp.encode(toTimestamp(message.windowEnd), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListWfMetricsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWfMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpec = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.windowStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.windowEnd = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWfMetricsRequest {
    return {
      wfSpec: isSet(object.wfSpec) ? WfSpecId.fromJSON(object.wfSpec) : undefined,
      windowStart: isSet(object.windowStart) ? globalThis.String(object.windowStart) : undefined,
      windowEnd: isSet(object.windowEnd) ? globalThis.String(object.windowEnd) : undefined,
    };
  },

  toJSON(message: ListWfMetricsRequest): unknown {
    const obj: any = {};
    if (message.wfSpec !== undefined) {
      obj.wfSpec = WfSpecId.toJSON(message.wfSpec);
    }
    if (message.windowStart !== undefined) {
      obj.windowStart = message.windowStart;
    }
    if (message.windowEnd !== undefined) {
      obj.windowEnd = message.windowEnd;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWfMetricsRequest>): ListWfMetricsRequest {
    return ListWfMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWfMetricsRequest>): ListWfMetricsRequest {
    const message = createBaseListWfMetricsRequest();
    message.wfSpec = (object.wfSpec !== undefined && object.wfSpec !== null)
      ? WfSpecId.fromPartial(object.wfSpec)
      : undefined;
    message.windowStart = object.windowStart ?? undefined;
    message.windowEnd = object.windowEnd ?? undefined;
    return message;
  },
};

function createBaseMetricsList(): MetricsList {
  return { windows: [] };
}

export const MetricsList = {
  encode(message: MetricsList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.windows) {
      MetricWindow.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.windows.push(MetricWindow.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricsList {
    return {
      windows: globalThis.Array.isArray(object?.windows)
        ? object.windows.map((e: any) => MetricWindow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetricsList): unknown {
    const obj: any = {};
    if (message.windows?.length) {
      obj.windows = message.windows.map((e) => MetricWindow.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MetricsList>): MetricsList {
    return MetricsList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricsList>): MetricsList {
    const message = createBaseMetricsList();
    message.windows = object.windows?.map((e) => MetricWindow.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
