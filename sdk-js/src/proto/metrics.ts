// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.32.1
// source: metrics.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  AggregationType,
  aggregationTypeFromJSON,
  aggregationTypeToJSON,
  aggregationTypeToNumber,
  MetricEntityType,
  metricEntityTypeFromJSON,
  metricEntityTypeToJSON,
  metricEntityTypeToNumber,
  MetricRecordingLevel,
  metricRecordingLevelFromJSON,
  metricRecordingLevelToJSON,
  metricRecordingLevelToNumber,
} from "./common_enums";
import { Duration } from "./google/protobuf/duration";
import { Timestamp } from "./google/protobuf/timestamp";
import { TaskDefId, WfSpecId } from "./object_id";

export interface StatusTransition {
  entity: MetricEntityType;
  fromStatus: string;
  toStatus: string;
}

export interface MetricScope {
  type?:
    | { $case: "wfSpec"; value: WfSpecId }
    | { $case: "taskDef"; value: TaskDefId }
    | { $case: "node"; value: NodeReference }
    | { $case: "global"; value: boolean }
    | undefined;
}

export interface NodeReference {
  wfSpec: WfSpecId | undefined;
  threadName?: string | undefined;
  nodeName?: string | undefined;
  taskDef?: TaskDefId | undefined;
}

export interface MetricSpec {
  id: string;
  createdAt: string | undefined;
  aggregationType: AggregationType;
  scope: MetricScope | undefined;
  transition: StatusTransition | undefined;
  windowLength: Duration | undefined;
}

export interface MetricsConfig {
  level: MetricRecordingLevel;
  retentionDays: number;
}

export interface WorkflowMetricId {
  /** If null, tenant-level aggregate */
  wfSpec?: WfSpecId | undefined;
}

export interface TaskMetricId {
  /** If null, tenant-level aggregate */
  taskDef?: TaskDefId | undefined;
}

export interface NodeMetricId {
  wfSpec: WfSpecId | undefined;
  nodeName: string;
  /** Position within the ThreadSpec for ordering */
  nodePosition: number;
}

export interface MetricWindowId {
  id?: { $case: "workflow"; value: WorkflowMetricId } | { $case: "task"; value: TaskMetricId } | {
    $case: "node";
    value: NodeMetricId;
  } | undefined;
  windowStart: string | undefined;
}

export interface CountAndTiming {
  count: number;
  minLatencyMs: number;
  maxLatencyMs: number;
  totalLatencyMs: number;
}

export interface MetricWindow {
  id: MetricWindowId | undefined;
  metrics: { [key: string]: CountAndTiming };
}

export interface MetricWindow_MetricsEntry {
  key: string;
  value: CountAndTiming | undefined;
}

export interface ListMetricsRequest {
  /** Metric window id contains object and start time */
  id:
    | MetricWindowId
    | undefined;
  /** Optional: if not set, server uses current time */
  endTime?: string | undefined;
}

export interface MetricList {
  windows: MetricWindow[];
}

export interface MetricLevelOverride {
  id: string;
  newLevel: MetricRecordingLevel;
  workflow: WorkflowMetricId | undefined;
}

export interface PutMetricLevelOverrideRequest {
  override: MetricLevelOverride | undefined;
}

export interface DeleteMetricLevelOverrideRequest {
  id: string;
}

export interface ListMetricLevelOverridesRequest {
  /** Optional filters */
  wfSpecFilter?: WfSpecId | undefined;
}

export interface MetricLevelOverridesList {
  overrides: MetricLevelOverride[];
}

function createBaseStatusTransition(): StatusTransition {
  return { entity: MetricEntityType.METRIC_WF_RUN, fromStatus: "", toStatus: "" };
}

export const StatusTransition = {
  encode(message: StatusTransition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entity !== MetricEntityType.METRIC_WF_RUN) {
      writer.uint32(8).int32(metricEntityTypeToNumber(message.entity));
    }
    if (message.fromStatus !== "") {
      writer.uint32(18).string(message.fromStatus);
    }
    if (message.toStatus !== "") {
      writer.uint32(26).string(message.toStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusTransition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusTransition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entity = metricEntityTypeFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fromStatus = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toStatus = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusTransition {
    return {
      entity: isSet(object.entity) ? metricEntityTypeFromJSON(object.entity) : MetricEntityType.METRIC_WF_RUN,
      fromStatus: isSet(object.fromStatus) ? globalThis.String(object.fromStatus) : "",
      toStatus: isSet(object.toStatus) ? globalThis.String(object.toStatus) : "",
    };
  },

  toJSON(message: StatusTransition): unknown {
    const obj: any = {};
    if (message.entity !== MetricEntityType.METRIC_WF_RUN) {
      obj.entity = metricEntityTypeToJSON(message.entity);
    }
    if (message.fromStatus !== "") {
      obj.fromStatus = message.fromStatus;
    }
    if (message.toStatus !== "") {
      obj.toStatus = message.toStatus;
    }
    return obj;
  },

  create(base?: DeepPartial<StatusTransition>): StatusTransition {
    return StatusTransition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StatusTransition>): StatusTransition {
    const message = createBaseStatusTransition();
    message.entity = object.entity ?? MetricEntityType.METRIC_WF_RUN;
    message.fromStatus = object.fromStatus ?? "";
    message.toStatus = object.toStatus ?? "";
    return message;
  },
};

function createBaseMetricScope(): MetricScope {
  return { type: undefined };
}

export const MetricScope = {
  encode(message: MetricScope, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.type?.$case) {
      case "wfSpec":
        WfSpecId.encode(message.type.value, writer.uint32(10).fork()).ldelim();
        break;
      case "taskDef":
        TaskDefId.encode(message.type.value, writer.uint32(18).fork()).ldelim();
        break;
      case "node":
        NodeReference.encode(message.type.value, writer.uint32(26).fork()).ldelim();
        break;
      case "global":
        writer.uint32(32).bool(message.type.value);
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricScope {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricScope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = { $case: "wfSpec", value: WfSpecId.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = { $case: "taskDef", value: TaskDefId.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = { $case: "node", value: NodeReference.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = { $case: "global", value: reader.bool() };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricScope {
    return {
      type: isSet(object.wfSpec)
        ? { $case: "wfSpec", value: WfSpecId.fromJSON(object.wfSpec) }
        : isSet(object.taskDef)
        ? { $case: "taskDef", value: TaskDefId.fromJSON(object.taskDef) }
        : isSet(object.node)
        ? { $case: "node", value: NodeReference.fromJSON(object.node) }
        : isSet(object.global)
        ? { $case: "global", value: globalThis.Boolean(object.global) }
        : undefined,
    };
  },

  toJSON(message: MetricScope): unknown {
    const obj: any = {};
    if (message.type?.$case === "wfSpec") {
      obj.wfSpec = WfSpecId.toJSON(message.type.value);
    }
    if (message.type?.$case === "taskDef") {
      obj.taskDef = TaskDefId.toJSON(message.type.value);
    }
    if (message.type?.$case === "node") {
      obj.node = NodeReference.toJSON(message.type.value);
    }
    if (message.type?.$case === "global") {
      obj.global = message.type.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MetricScope>): MetricScope {
    return MetricScope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricScope>): MetricScope {
    const message = createBaseMetricScope();
    if (object.type?.$case === "wfSpec" && object.type?.value !== undefined && object.type?.value !== null) {
      message.type = { $case: "wfSpec", value: WfSpecId.fromPartial(object.type.value) };
    }
    if (object.type?.$case === "taskDef" && object.type?.value !== undefined && object.type?.value !== null) {
      message.type = { $case: "taskDef", value: TaskDefId.fromPartial(object.type.value) };
    }
    if (object.type?.$case === "node" && object.type?.value !== undefined && object.type?.value !== null) {
      message.type = { $case: "node", value: NodeReference.fromPartial(object.type.value) };
    }
    if (object.type?.$case === "global" && object.type?.value !== undefined && object.type?.value !== null) {
      message.type = { $case: "global", value: object.type.value };
    }
    return message;
  },
};

function createBaseNodeReference(): NodeReference {
  return { wfSpec: undefined, threadName: undefined, nodeName: undefined, taskDef: undefined };
}

export const NodeReference = {
  encode(message: NodeReference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpec !== undefined) {
      WfSpecId.encode(message.wfSpec, writer.uint32(10).fork()).ldelim();
    }
    if (message.threadName !== undefined) {
      writer.uint32(18).string(message.threadName);
    }
    if (message.nodeName !== undefined) {
      writer.uint32(26).string(message.nodeName);
    }
    if (message.taskDef !== undefined) {
      TaskDefId.encode(message.taskDef, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeReference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpec = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.threadName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodeName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.taskDef = TaskDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeReference {
    return {
      wfSpec: isSet(object.wfSpec) ? WfSpecId.fromJSON(object.wfSpec) : undefined,
      threadName: isSet(object.threadName) ? globalThis.String(object.threadName) : undefined,
      nodeName: isSet(object.nodeName) ? globalThis.String(object.nodeName) : undefined,
      taskDef: isSet(object.taskDef) ? TaskDefId.fromJSON(object.taskDef) : undefined,
    };
  },

  toJSON(message: NodeReference): unknown {
    const obj: any = {};
    if (message.wfSpec !== undefined) {
      obj.wfSpec = WfSpecId.toJSON(message.wfSpec);
    }
    if (message.threadName !== undefined) {
      obj.threadName = message.threadName;
    }
    if (message.nodeName !== undefined) {
      obj.nodeName = message.nodeName;
    }
    if (message.taskDef !== undefined) {
      obj.taskDef = TaskDefId.toJSON(message.taskDef);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeReference>): NodeReference {
    return NodeReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeReference>): NodeReference {
    const message = createBaseNodeReference();
    message.wfSpec = (object.wfSpec !== undefined && object.wfSpec !== null)
      ? WfSpecId.fromPartial(object.wfSpec)
      : undefined;
    message.threadName = object.threadName ?? undefined;
    message.nodeName = object.nodeName ?? undefined;
    message.taskDef = (object.taskDef !== undefined && object.taskDef !== null)
      ? TaskDefId.fromPartial(object.taskDef)
      : undefined;
    return message;
  },
};

function createBaseMetricSpec(): MetricSpec {
  return {
    id: "",
    createdAt: undefined,
    aggregationType: AggregationType.COUNT,
    scope: undefined,
    transition: undefined,
    windowLength: undefined,
  };
}

export const MetricSpec = {
  encode(message: MetricSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).ldelim();
    }
    if (message.aggregationType !== AggregationType.COUNT) {
      writer.uint32(24).int32(aggregationTypeToNumber(message.aggregationType));
    }
    if (message.scope !== undefined) {
      MetricScope.encode(message.scope, writer.uint32(34).fork()).ldelim();
    }
    if (message.transition !== undefined) {
      StatusTransition.encode(message.transition, writer.uint32(42).fork()).ldelim();
    }
    if (message.windowLength !== undefined) {
      Duration.encode(message.windowLength, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricSpec {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.aggregationType = aggregationTypeFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.scope = MetricScope.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transition = StatusTransition.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.windowLength = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricSpec {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : undefined,
      aggregationType: isSet(object.aggregationType)
        ? aggregationTypeFromJSON(object.aggregationType)
        : AggregationType.COUNT,
      scope: isSet(object.scope) ? MetricScope.fromJSON(object.scope) : undefined,
      transition: isSet(object.transition) ? StatusTransition.fromJSON(object.transition) : undefined,
      windowLength: isSet(object.windowLength) ? Duration.fromJSON(object.windowLength) : undefined,
    };
  },

  toJSON(message: MetricSpec): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt;
    }
    if (message.aggregationType !== AggregationType.COUNT) {
      obj.aggregationType = aggregationTypeToJSON(message.aggregationType);
    }
    if (message.scope !== undefined) {
      obj.scope = MetricScope.toJSON(message.scope);
    }
    if (message.transition !== undefined) {
      obj.transition = StatusTransition.toJSON(message.transition);
    }
    if (message.windowLength !== undefined) {
      obj.windowLength = Duration.toJSON(message.windowLength);
    }
    return obj;
  },

  create(base?: DeepPartial<MetricSpec>): MetricSpec {
    return MetricSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricSpec>): MetricSpec {
    const message = createBaseMetricSpec();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.aggregationType = object.aggregationType ?? AggregationType.COUNT;
    message.scope = (object.scope !== undefined && object.scope !== null)
      ? MetricScope.fromPartial(object.scope)
      : undefined;
    message.transition = (object.transition !== undefined && object.transition !== null)
      ? StatusTransition.fromPartial(object.transition)
      : undefined;
    message.windowLength = (object.windowLength !== undefined && object.windowLength !== null)
      ? Duration.fromPartial(object.windowLength)
      : undefined;
    return message;
  },
};

function createBaseMetricsConfig(): MetricsConfig {
  return { level: MetricRecordingLevel.INFO, retentionDays: 0 };
}

export const MetricsConfig = {
  encode(message: MetricsConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.level !== MetricRecordingLevel.INFO) {
      writer.uint32(8).int32(metricRecordingLevelToNumber(message.level));
    }
    if (message.retentionDays !== 0) {
      writer.uint32(16).int32(message.retentionDays);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.level = metricRecordingLevelFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.retentionDays = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricsConfig {
    return {
      level: isSet(object.level) ? metricRecordingLevelFromJSON(object.level) : MetricRecordingLevel.INFO,
      retentionDays: isSet(object.retentionDays) ? globalThis.Number(object.retentionDays) : 0,
    };
  },

  toJSON(message: MetricsConfig): unknown {
    const obj: any = {};
    if (message.level !== MetricRecordingLevel.INFO) {
      obj.level = metricRecordingLevelToJSON(message.level);
    }
    if (message.retentionDays !== 0) {
      obj.retentionDays = Math.round(message.retentionDays);
    }
    return obj;
  },

  create(base?: DeepPartial<MetricsConfig>): MetricsConfig {
    return MetricsConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricsConfig>): MetricsConfig {
    const message = createBaseMetricsConfig();
    message.level = object.level ?? MetricRecordingLevel.INFO;
    message.retentionDays = object.retentionDays ?? 0;
    return message;
  },
};

function createBaseWorkflowMetricId(): WorkflowMetricId {
  return { wfSpec: undefined };
}

export const WorkflowMetricId = {
  encode(message: WorkflowMetricId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpec !== undefined) {
      WfSpecId.encode(message.wfSpec, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowMetricId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowMetricId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpec = WfSpecId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowMetricId {
    return { wfSpec: isSet(object.wfSpec) ? WfSpecId.fromJSON(object.wfSpec) : undefined };
  },

  toJSON(message: WorkflowMetricId): unknown {
    const obj: any = {};
    if (message.wfSpec !== undefined) {
      obj.wfSpec = WfSpecId.toJSON(message.wfSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkflowMetricId>): WorkflowMetricId {
    return WorkflowMetricId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowMetricId>): WorkflowMetricId {
    const message = createBaseWorkflowMetricId();
    message.wfSpec = (object.wfSpec !== undefined && object.wfSpec !== null)
      ? WfSpecId.fromPartial(object.wfSpec)
      : undefined;
    return message;
  },
};

function createBaseTaskMetricId(): TaskMetricId {
  return { taskDef: undefined };
}

export const TaskMetricId = {
  encode(message: TaskMetricId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskDef !== undefined) {
      TaskDefId.encode(message.taskDef, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskMetricId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskMetricId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskDef = TaskDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskMetricId {
    return { taskDef: isSet(object.taskDef) ? TaskDefId.fromJSON(object.taskDef) : undefined };
  },

  toJSON(message: TaskMetricId): unknown {
    const obj: any = {};
    if (message.taskDef !== undefined) {
      obj.taskDef = TaskDefId.toJSON(message.taskDef);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskMetricId>): TaskMetricId {
    return TaskMetricId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskMetricId>): TaskMetricId {
    const message = createBaseTaskMetricId();
    message.taskDef = (object.taskDef !== undefined && object.taskDef !== null)
      ? TaskDefId.fromPartial(object.taskDef)
      : undefined;
    return message;
  },
};

function createBaseNodeMetricId(): NodeMetricId {
  return { wfSpec: undefined, nodeName: "", nodePosition: 0 };
}

export const NodeMetricId = {
  encode(message: NodeMetricId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpec !== undefined) {
      WfSpecId.encode(message.wfSpec, writer.uint32(10).fork()).ldelim();
    }
    if (message.nodeName !== "") {
      writer.uint32(18).string(message.nodeName);
    }
    if (message.nodePosition !== 0) {
      writer.uint32(24).int32(message.nodePosition);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeMetricId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeMetricId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpec = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nodePosition = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeMetricId {
    return {
      wfSpec: isSet(object.wfSpec) ? WfSpecId.fromJSON(object.wfSpec) : undefined,
      nodeName: isSet(object.nodeName) ? globalThis.String(object.nodeName) : "",
      nodePosition: isSet(object.nodePosition) ? globalThis.Number(object.nodePosition) : 0,
    };
  },

  toJSON(message: NodeMetricId): unknown {
    const obj: any = {};
    if (message.wfSpec !== undefined) {
      obj.wfSpec = WfSpecId.toJSON(message.wfSpec);
    }
    if (message.nodeName !== "") {
      obj.nodeName = message.nodeName;
    }
    if (message.nodePosition !== 0) {
      obj.nodePosition = Math.round(message.nodePosition);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeMetricId>): NodeMetricId {
    return NodeMetricId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeMetricId>): NodeMetricId {
    const message = createBaseNodeMetricId();
    message.wfSpec = (object.wfSpec !== undefined && object.wfSpec !== null)
      ? WfSpecId.fromPartial(object.wfSpec)
      : undefined;
    message.nodeName = object.nodeName ?? "";
    message.nodePosition = object.nodePosition ?? 0;
    return message;
  },
};

function createBaseMetricWindowId(): MetricWindowId {
  return { id: undefined, windowStart: undefined };
}

export const MetricWindowId = {
  encode(message: MetricWindowId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.id?.$case) {
      case "workflow":
        WorkflowMetricId.encode(message.id.value, writer.uint32(10).fork()).ldelim();
        break;
      case "task":
        TaskMetricId.encode(message.id.value, writer.uint32(18).fork()).ldelim();
        break;
      case "node":
        NodeMetricId.encode(message.id.value, writer.uint32(26).fork()).ldelim();
        break;
    }
    if (message.windowStart !== undefined) {
      Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricWindowId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricWindowId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = { $case: "workflow", value: WorkflowMetricId.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = { $case: "task", value: TaskMetricId.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = { $case: "node", value: NodeMetricId.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.windowStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricWindowId {
    return {
      id: isSet(object.workflow)
        ? { $case: "workflow", value: WorkflowMetricId.fromJSON(object.workflow) }
        : isSet(object.task)
        ? { $case: "task", value: TaskMetricId.fromJSON(object.task) }
        : isSet(object.node)
        ? { $case: "node", value: NodeMetricId.fromJSON(object.node) }
        : undefined,
      windowStart: isSet(object.windowStart) ? globalThis.String(object.windowStart) : undefined,
    };
  },

  toJSON(message: MetricWindowId): unknown {
    const obj: any = {};
    if (message.id?.$case === "workflow") {
      obj.workflow = WorkflowMetricId.toJSON(message.id.value);
    }
    if (message.id?.$case === "task") {
      obj.task = TaskMetricId.toJSON(message.id.value);
    }
    if (message.id?.$case === "node") {
      obj.node = NodeMetricId.toJSON(message.id.value);
    }
    if (message.windowStart !== undefined) {
      obj.windowStart = message.windowStart;
    }
    return obj;
  },

  create(base?: DeepPartial<MetricWindowId>): MetricWindowId {
    return MetricWindowId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricWindowId>): MetricWindowId {
    const message = createBaseMetricWindowId();
    if (object.id?.$case === "workflow" && object.id?.value !== undefined && object.id?.value !== null) {
      message.id = { $case: "workflow", value: WorkflowMetricId.fromPartial(object.id.value) };
    }
    if (object.id?.$case === "task" && object.id?.value !== undefined && object.id?.value !== null) {
      message.id = { $case: "task", value: TaskMetricId.fromPartial(object.id.value) };
    }
    if (object.id?.$case === "node" && object.id?.value !== undefined && object.id?.value !== null) {
      message.id = { $case: "node", value: NodeMetricId.fromPartial(object.id.value) };
    }
    message.windowStart = object.windowStart ?? undefined;
    return message;
  },
};

function createBaseCountAndTiming(): CountAndTiming {
  return { count: 0, minLatencyMs: 0, maxLatencyMs: 0, totalLatencyMs: 0 };
}

export const CountAndTiming = {
  encode(message: CountAndTiming, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== 0) {
      writer.uint32(8).int32(message.count);
    }
    if (message.minLatencyMs !== 0) {
      writer.uint32(16).int64(message.minLatencyMs);
    }
    if (message.maxLatencyMs !== 0) {
      writer.uint32(24).int64(message.maxLatencyMs);
    }
    if (message.totalLatencyMs !== 0) {
      writer.uint32(32).int64(message.totalLatencyMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CountAndTiming {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountAndTiming();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minLatencyMs = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxLatencyMs = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalLatencyMs = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CountAndTiming {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      minLatencyMs: isSet(object.minLatencyMs) ? globalThis.Number(object.minLatencyMs) : 0,
      maxLatencyMs: isSet(object.maxLatencyMs) ? globalThis.Number(object.maxLatencyMs) : 0,
      totalLatencyMs: isSet(object.totalLatencyMs) ? globalThis.Number(object.totalLatencyMs) : 0,
    };
  },

  toJSON(message: CountAndTiming): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.minLatencyMs !== 0) {
      obj.minLatencyMs = Math.round(message.minLatencyMs);
    }
    if (message.maxLatencyMs !== 0) {
      obj.maxLatencyMs = Math.round(message.maxLatencyMs);
    }
    if (message.totalLatencyMs !== 0) {
      obj.totalLatencyMs = Math.round(message.totalLatencyMs);
    }
    return obj;
  },

  create(base?: DeepPartial<CountAndTiming>): CountAndTiming {
    return CountAndTiming.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CountAndTiming>): CountAndTiming {
    const message = createBaseCountAndTiming();
    message.count = object.count ?? 0;
    message.minLatencyMs = object.minLatencyMs ?? 0;
    message.maxLatencyMs = object.maxLatencyMs ?? 0;
    message.totalLatencyMs = object.totalLatencyMs ?? 0;
    return message;
  },
};

function createBaseMetricWindow(): MetricWindow {
  return { id: undefined, metrics: {} };
}

export const MetricWindow = {
  encode(message: MetricWindow, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      MetricWindowId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.metrics).forEach(([key, value]) => {
      MetricWindow_MetricsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricWindow {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = MetricWindowId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = MetricWindow_MetricsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metrics[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricWindow {
    return {
      id: isSet(object.id) ? MetricWindowId.fromJSON(object.id) : undefined,
      metrics: isObject(object.metrics)
        ? Object.entries(object.metrics).reduce<{ [key: string]: CountAndTiming }>((acc, [key, value]) => {
          acc[key] = CountAndTiming.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MetricWindow): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = MetricWindowId.toJSON(message.id);
    }
    if (message.metrics) {
      const entries = Object.entries(message.metrics);
      if (entries.length > 0) {
        obj.metrics = {};
        entries.forEach(([k, v]) => {
          obj.metrics[k] = CountAndTiming.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MetricWindow>): MetricWindow {
    return MetricWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricWindow>): MetricWindow {
    const message = createBaseMetricWindow();
    message.id = (object.id !== undefined && object.id !== null) ? MetricWindowId.fromPartial(object.id) : undefined;
    message.metrics = Object.entries(object.metrics ?? {}).reduce<{ [key: string]: CountAndTiming }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = CountAndTiming.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMetricWindow_MetricsEntry(): MetricWindow_MetricsEntry {
  return { key: "", value: undefined };
}

export const MetricWindow_MetricsEntry = {
  encode(message: MetricWindow_MetricsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CountAndTiming.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricWindow_MetricsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricWindow_MetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CountAndTiming.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricWindow_MetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CountAndTiming.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MetricWindow_MetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CountAndTiming.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MetricWindow_MetricsEntry>): MetricWindow_MetricsEntry {
    return MetricWindow_MetricsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricWindow_MetricsEntry>): MetricWindow_MetricsEntry {
    const message = createBaseMetricWindow_MetricsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CountAndTiming.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseListMetricsRequest(): ListMetricsRequest {
  return { id: undefined, endTime: undefined };
}

export const ListMetricsRequest = {
  encode(message: ListMetricsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      MetricWindowId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListMetricsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = MetricWindowId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMetricsRequest {
    return {
      id: isSet(object.id) ? MetricWindowId.fromJSON(object.id) : undefined,
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : undefined,
    };
  },

  toJSON(message: ListMetricsRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = MetricWindowId.toJSON(message.id);
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMetricsRequest>): ListMetricsRequest {
    return ListMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMetricsRequest>): ListMetricsRequest {
    const message = createBaseListMetricsRequest();
    message.id = (object.id !== undefined && object.id !== null) ? MetricWindowId.fromPartial(object.id) : undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseMetricList(): MetricList {
  return { windows: [] };
}

export const MetricList = {
  encode(message: MetricList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.windows) {
      MetricWindow.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.windows.push(MetricWindow.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricList {
    return {
      windows: globalThis.Array.isArray(object?.windows)
        ? object.windows.map((e: any) => MetricWindow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetricList): unknown {
    const obj: any = {};
    if (message.windows?.length) {
      obj.windows = message.windows.map((e) => MetricWindow.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MetricList>): MetricList {
    return MetricList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricList>): MetricList {
    const message = createBaseMetricList();
    message.windows = object.windows?.map((e) => MetricWindow.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetricLevelOverride(): MetricLevelOverride {
  return { id: "", newLevel: MetricRecordingLevel.INFO, workflow: undefined };
}

export const MetricLevelOverride = {
  encode(message: MetricLevelOverride, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.newLevel !== MetricRecordingLevel.INFO) {
      writer.uint32(16).int32(metricRecordingLevelToNumber(message.newLevel));
    }
    if (message.workflow !== undefined) {
      WorkflowMetricId.encode(message.workflow, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricLevelOverride {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricLevelOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.newLevel = metricRecordingLevelFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.workflow = WorkflowMetricId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricLevelOverride {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      newLevel: isSet(object.newLevel) ? metricRecordingLevelFromJSON(object.newLevel) : MetricRecordingLevel.INFO,
      workflow: isSet(object.workflow) ? WorkflowMetricId.fromJSON(object.workflow) : undefined,
    };
  },

  toJSON(message: MetricLevelOverride): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.newLevel !== MetricRecordingLevel.INFO) {
      obj.newLevel = metricRecordingLevelToJSON(message.newLevel);
    }
    if (message.workflow !== undefined) {
      obj.workflow = WorkflowMetricId.toJSON(message.workflow);
    }
    return obj;
  },

  create(base?: DeepPartial<MetricLevelOverride>): MetricLevelOverride {
    return MetricLevelOverride.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricLevelOverride>): MetricLevelOverride {
    const message = createBaseMetricLevelOverride();
    message.id = object.id ?? "";
    message.newLevel = object.newLevel ?? MetricRecordingLevel.INFO;
    message.workflow = (object.workflow !== undefined && object.workflow !== null)
      ? WorkflowMetricId.fromPartial(object.workflow)
      : undefined;
    return message;
  },
};

function createBasePutMetricLevelOverrideRequest(): PutMetricLevelOverrideRequest {
  return { override: undefined };
}

export const PutMetricLevelOverrideRequest = {
  encode(message: PutMetricLevelOverrideRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.override !== undefined) {
      MetricLevelOverride.encode(message.override, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutMetricLevelOverrideRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutMetricLevelOverrideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.override = MetricLevelOverride.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutMetricLevelOverrideRequest {
    return { override: isSet(object.override) ? MetricLevelOverride.fromJSON(object.override) : undefined };
  },

  toJSON(message: PutMetricLevelOverrideRequest): unknown {
    const obj: any = {};
    if (message.override !== undefined) {
      obj.override = MetricLevelOverride.toJSON(message.override);
    }
    return obj;
  },

  create(base?: DeepPartial<PutMetricLevelOverrideRequest>): PutMetricLevelOverrideRequest {
    return PutMetricLevelOverrideRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PutMetricLevelOverrideRequest>): PutMetricLevelOverrideRequest {
    const message = createBasePutMetricLevelOverrideRequest();
    message.override = (object.override !== undefined && object.override !== null)
      ? MetricLevelOverride.fromPartial(object.override)
      : undefined;
    return message;
  },
};

function createBaseDeleteMetricLevelOverrideRequest(): DeleteMetricLevelOverrideRequest {
  return { id: "" };
}

export const DeleteMetricLevelOverrideRequest = {
  encode(message: DeleteMetricLevelOverrideRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteMetricLevelOverrideRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMetricLevelOverrideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMetricLevelOverrideRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteMetricLevelOverrideRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteMetricLevelOverrideRequest>): DeleteMetricLevelOverrideRequest {
    return DeleteMetricLevelOverrideRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteMetricLevelOverrideRequest>): DeleteMetricLevelOverrideRequest {
    const message = createBaseDeleteMetricLevelOverrideRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListMetricLevelOverridesRequest(): ListMetricLevelOverridesRequest {
  return { wfSpecFilter: undefined };
}

export const ListMetricLevelOverridesRequest = {
  encode(message: ListMetricLevelOverridesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpecFilter !== undefined) {
      WfSpecId.encode(message.wfSpecFilter, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListMetricLevelOverridesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMetricLevelOverridesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpecFilter = WfSpecId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMetricLevelOverridesRequest {
    return { wfSpecFilter: isSet(object.wfSpecFilter) ? WfSpecId.fromJSON(object.wfSpecFilter) : undefined };
  },

  toJSON(message: ListMetricLevelOverridesRequest): unknown {
    const obj: any = {};
    if (message.wfSpecFilter !== undefined) {
      obj.wfSpecFilter = WfSpecId.toJSON(message.wfSpecFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<ListMetricLevelOverridesRequest>): ListMetricLevelOverridesRequest {
    return ListMetricLevelOverridesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMetricLevelOverridesRequest>): ListMetricLevelOverridesRequest {
    const message = createBaseListMetricLevelOverridesRequest();
    message.wfSpecFilter = (object.wfSpecFilter !== undefined && object.wfSpecFilter !== null)
      ? WfSpecId.fromPartial(object.wfSpecFilter)
      : undefined;
    return message;
  },
};

function createBaseMetricLevelOverridesList(): MetricLevelOverridesList {
  return { overrides: [] };
}

export const MetricLevelOverridesList = {
  encode(message: MetricLevelOverridesList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.overrides) {
      MetricLevelOverride.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricLevelOverridesList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricLevelOverridesList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.overrides.push(MetricLevelOverride.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricLevelOverridesList {
    return {
      overrides: globalThis.Array.isArray(object?.overrides)
        ? object.overrides.map((e: any) => MetricLevelOverride.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetricLevelOverridesList): unknown {
    const obj: any = {};
    if (message.overrides?.length) {
      obj.overrides = message.overrides.map((e) => MetricLevelOverride.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MetricLevelOverridesList>): MetricLevelOverridesList {
    return MetricLevelOverridesList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricLevelOverridesList>): MetricLevelOverridesList {
    const message = createBaseMetricLevelOverridesList();
    message.overrides = object.overrides?.map((e) => MetricLevelOverride.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
