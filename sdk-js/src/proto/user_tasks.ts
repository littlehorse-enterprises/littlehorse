// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v4.23.4
// source: user_tasks.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import {
  UserTaskRunStatus,
  userTaskRunStatusFromJSON,
  userTaskRunStatusToJSON,
  userTaskRunStatusToNumber,
  VariableType,
  variableTypeFromJSON,
  variableTypeToJSON,
  variableTypeToNumber,
} from "./common_enums";
import { Timestamp } from "./google/protobuf/timestamp";
import { NodeRunId, TaskRunId, UserTaskDefId, UserTaskRunId } from "./object_id";
import { VariableValue } from "./variable";

/** UserTaskDef is the metadata blueprint for UserTaskRuns. */
export interface UserTaskDef {
  /** The name of the `UserTaskDef` */
  name: string;
  /** The version of the `UserTaskDef`. Only simple versioning is supported. */
  version: number;
  /**
   * Metadata field that does not impact WfRun execution. Useful for providing
   * context on the UserTaskRun, for example when displaying it on a general-purpose
   * task manager application.
   */
  description?:
    | string
    | undefined;
  /**
   * These are the fields comprise the User Task. A User Task Manager application, or
   * any application used to complete a UserTaskRun, should inspect these fields and
   * display form entries for each one.
   */
  fields: UserTaskField[];
  /** The time the UserTaskRun was created. */
  createdAt: string | undefined;
}

/** A UserTaskField is a specific field of data to be entered into a UserTaskRun. */
export interface UserTaskField {
  /**
   * The name of the field. When a UserTaskRun is completed, the NodeOutput is a
   * single-level JSON_OBJ. Each key is the name of the field. Must be unique.
   */
  name: string;
  /** The type of the output. Must be a basic primitive type (STR, BOOL, INT, DOUBLE). */
  type: VariableType;
  /**
   * Optional description which can be displayed by the User Task UI application.
   * Does not affect WfRun execution.
   */
  description?:
    | string
    | undefined;
  /**
   * The name to be displayed by the User Task UI application. Does not affect
   * WfRun execution.
   */
  displayName: string;
  /** Whether this field is required for UserTaskRun completion. */
  required: boolean;
}

/**
 * A UserTaskRun is a running instance of a UserTaskDef. It is created when a
 * ThreadRun arrives at a Node of type `USER_TASK`.
 */
export interface UserTaskRun {
  /** The ID of the UserTaskRun. */
  id:
    | UserTaskRunId
    | undefined;
  /** The ID of the UserTaskDef that this UserTaskRun comes from. */
  userTaskDefId:
    | UserTaskDefId
    | undefined;
  /**
   * Denotes the UserTaskRun as belonging to a specific User Group.
   *
   * The `user_group` does not refer to a group that is stored in LittleHorse; rather, it
   * is the responsibility of the application to keep track of user/group identity and ensure
   * that the user_group does indeed exist.
   *
   * Either `user_id` or `user_group` or both are set at any time.
   */
  userGroup?:
    | string
    | undefined;
  /**
   * Denotes the UserTaskRun as assigned to a specific User ID. If this is set, then
   * the UserTaskRun is either in the ASSIGNED, DONE, or CANCELLED status.
   *
   * The `user_id` does not refer to a User that is stored in LittleHorse; rather, it
   * is the responsibility of the application to keep track of user identity and ensure
   * that the user_id does indeed exist.
   *
   * Either `user_id` or `user_group` or both are set at any time.
   */
  userId?:
    | string
    | undefined;
  /**
   * The results of the UserTaskRun. Empty if the UserTaskRun has not yet been completed.
   * Each key in this map is the `name` of a corresponding `UserTaskField` on the
   * UserTaskDef.
   */
  results: { [key: string]: VariableValue };
  /** Status of the UserTaskRun. Can be UNASSIGNED, ASSIGNED, DONE, or CANCELLED. */
  status: UserTaskRunStatus;
  /** A list of events that have happened. Used for auditing information. */
  events: UserTaskEvent[];
  /**
   * Notes about this UserTaskRun that are **specific to the WfRun**. These notes
   * are set by the WfSpec based on variables inside the specific `WfRun` and are
   * intended to be displayed on the User Task Manager application. They do not
   * affect WfRun execution.
   */
  notes?:
    | string
    | undefined;
  /** The time that the UserTaskRun was created/scheduled. */
  scheduledTime:
    | string
    | undefined;
  /** The NodeRun with which the UserTaskRun is associated. */
  nodeRunId:
    | NodeRunId
    | undefined;
  /**
   * Current observed epoch of the UserTaskRun, related to the number of times it has been
   * updated or re-assigned. Used internally to implement automated reassignment and reminder
   * tasks.
   */
  epoch: number;
}

export interface UserTaskRun_ResultsEntry {
  key: string;
  value: VariableValue | undefined;
}

/** Re-Assigns a UserTaskRun to a specific userId or userGroup. */
export interface AssignUserTaskRunRequest {
  /** The UserTaskRun to assign to a new user_id or user_group. */
  userTaskRunId:
    | UserTaskRunId
    | undefined;
  /**
   * If override_claim is set to false and the UserTaskRun is already assigned to
   * a user_id, then the request throws a FAILED_PRECONDITION error. If set to
   * true, then the old claim is overriden and the UserTaskRun is assigned to
   * the new user.
   */
  overrideClaim: boolean;
  /**
   * The new user_group to which the UserTaskRun is assigned. If not set, then
   * the user_group of the UserTaskRun is actively unset by this request. At least
   * one of the user_group and user_id must be set.
   */
  userGroup?:
    | string
    | undefined;
  /**
   * The new user_id to which the UserTaskRun is assigned. If not set, then
   * the user_id of the UserTaskRun is actively unset by this request. At least
   * one of the user_group and user_id must be set.
   */
  userId?: string | undefined;
}

/** Completes a UserTaskRun with provided values. */
export interface CompleteUserTaskRunRequest {
  /** The id of UserTaskRun to complete. */
  userTaskRunId:
    | UserTaskRunId
    | undefined;
  /**
   * A map from UserTaskField.name to a VariableValue containing the results of the
   * user filling out the form.
   */
  results: { [key: string]: VariableValue };
  /** The ID of the user who executed the task. */
  userId: string;
}

export interface CompleteUserTaskRunRequest_ResultsEntry {
  key: string;
  value: VariableValue | undefined;
}

/**
 * Saves the results of a UserTaskRun and logs who saved the content.<br/>
 *
 * <li> Throws FAILED_PRECONDITION if the UserTaskRun is in the `DONE` or `CANCELLED` state.</li>
 * <li> If `policy` is set to `FAIL_IF_CLAIMED_BY_OTHER`, returns `FAILED_PRECONDITION` if the
 * `user_id` field of the `UserTaskRun` does not match the `user_id` of the request.</li>
 */
export interface SaveUserTaskRunProgressRequest {
  /** The id of UserTaskRun to save. */
  userTaskRunId:
    | UserTaskRunId
    | undefined;
  /**
   * A map from UserTaskField.name to a VariableValue containing the results of the
   * user filling out the form.
   */
  results: { [key: string]: VariableValue };
  /** The ID of the user who saved the task. */
  userId: string;
  /** Configures how to handle `UserTaskRun` ownership when saving it. */
  policy: SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy;
}

/** Configures how to handle `UserTaskRun` ownership when saving it. */
export enum SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy {
  /**
   * FAIL_IF_CLAIMED_BY_OTHER - If the UserTaskRun is already assigned to a user_id, then the request throws a
   * FAILED_PRECONDITION error.
   */
  FAIL_IF_CLAIMED_BY_OTHER = "FAIL_IF_CLAIMED_BY_OTHER",
  /**
   * IGNORE_CLAIM - If the UserTaskRun is already assigned to a user_id, then the request will
   * leave the `UserTaskRun` assigned to the current user but still update the
   * `results` and log in the `events` who updated the results.
   */
  IGNORE_CLAIM = "IGNORE_CLAIM",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function saveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicyFromJSON(
  object: any,
): SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy {
  switch (object) {
    case 0:
    case "FAIL_IF_CLAIMED_BY_OTHER":
      return SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.FAIL_IF_CLAIMED_BY_OTHER;
    case 1:
    case "IGNORE_CLAIM":
      return SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.IGNORE_CLAIM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.UNRECOGNIZED;
  }
}

export function saveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicyToJSON(
  object: SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy,
): string {
  switch (object) {
    case SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.FAIL_IF_CLAIMED_BY_OTHER:
      return "FAIL_IF_CLAIMED_BY_OTHER";
    case SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.IGNORE_CLAIM:
      return "IGNORE_CLAIM";
    case SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function saveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicyToNumber(
  object: SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy,
): number {
  switch (object) {
    case SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.FAIL_IF_CLAIMED_BY_OTHER:
      return 0;
    case SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.IGNORE_CLAIM:
      return 1;
    case SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface SaveUserTaskRunProgressRequest_ResultsEntry {
  key: string;
  value: VariableValue | undefined;
}

/** Cancels a UserTaskRun. */
export interface CancelUserTaskRunRequest {
  /** The id of the `UserTaskRun` to cancel. */
  userTaskRunId: UserTaskRunId | undefined;
}

/** Adds a comment to a UserTaskRun. */
export interface PutUserTaskRunCommentRequest {
  /** The id of `UserTaskRun` to save. */
  userTaskRunId:
    | UserTaskRunId
    | undefined;
  /** The author of the comment being made on a `UserTaskRun` */
  userId: string;
  /** The comment being made on a `UserTaskRun` */
  comment: string;
}

/** Edits an existing comment on a UserTaskRun */
export interface EditUserTaskRunCommentRequest {
  /** This is the unique identifier for a comment */
  userCommentId: number;
  /** The id of `UserTaskRun` */
  userTaskRunId:
    | UserTaskRunId
    | undefined;
  /** The author of the comment being made on a `UserTaskRun` */
  userId: string;
  /** The comment being made on a `UserTaskRun` */
  comment: string;
}

/** Deletes a comment on a UserTaskRun */
export interface DeleteUserTaskRunCommentRequest {
  /** The id of `UserTaskRun` */
  userTaskRunId:
    | UserTaskRunId
    | undefined;
  /** The id of the comment you are deleting */
  userCommentId: number;
  /** The id of the user who deleted the comment */
  userId: string;
}

/**
 * All TaskRun's have a "trigger reference" which refers to the WfRun Element that
 * caused the TaskRun to be scheduled. For example, a TaskRun on a regular TASK_NODE
 * has a TaskNodeReference.
 *
 * The UserTaskTriggerReference serves as the "Trigger Reference" for a TaskRun that
 * was scheduled by a lifecycle hook on a UserTaskRun (eg. a reminder task).
 *
 * The UserTaskTriggerReference is most useful in the WorkerContext of the Task Worker
 * SDK, which allows the Task Method to determine where the TaskRun comes from.
 */
export interface UserTaskTriggerReference {
  /** Is the NodeRun that the UserTaskRun belongs to. */
  nodeRunId:
    | NodeRunId
    | undefined;
  /**
   * Is the index in the `events` field of the UserTaskRun that the TaskRun corresponds
   * to.
   */
  userTaskEventNumber: number;
  /**
   * Is the user_id that the UserTaskRun is assigned to. Unset if UserTaskRun is not
   * asigned to a specific user_id.
   */
  userId?:
    | string
    | undefined;
  /**
   * Is the user_group that the UserTaskRun is assigned to. Unset if UserTaskRun is not
   * asigned to a specific user_group.
   */
  userGroup?: string | undefined;
}

/**
 * This is an event stored in the audit log of a `UserTaskRun` purely for observability
 * purposes.
 */
export interface UserTaskEvent {
  /** the time the event occurred. */
  time: string | undefined;
  event?:
    | { $case: "taskExecuted"; value: UserTaskEvent_UTETaskExecuted }
    | { $case: "assigned"; value: UserTaskEvent_UTEAssigned }
    | { $case: "cancelled"; value: UserTaskEvent_UTECancelled }
    | { $case: "saved"; value: UserTaskEvent_UTESaved }
    | { $case: "commentAdded"; value: UserTaskEvent_UTECommented }
    | { $case: "commentEdited"; value: UserTaskEvent_UTECommented }
    | { $case: "commentDeleted"; value: UserTaskEvent_UTECommentDeleted }
    | { $case: "completed"; value: UserTaskEvent_UTECompleted }
    | undefined;
}

/** Empty message used to denote that the `UserTaskRun` was cancelled. */
export interface UserTaskEvent_UTECancelled {
  message: string;
}

/** Message to denote that a `TaskRun` was scheduled by a trigger for this UserTaskRun. */
export interface UserTaskEvent_UTETaskExecuted {
  /** The `TaskRunId` of the scheduled `TaskRun` */
  taskRun: TaskRunId | undefined;
}

/** Message to denote that the `UserTaskRun` was saved. */
export interface UserTaskEvent_UTESaved {
  /** The user_id of the user who saved the UserTaskRun. */
  userId: string;
  /** The results that were saved. */
  results: { [key: string]: VariableValue };
}

export interface UserTaskEvent_UTESaved_ResultsEntry {
  key: string;
  value: VariableValue | undefined;
}

/** Message denoting that the UserTaskRun was assigned. */
export interface UserTaskEvent_UTEAssigned {
  /** The user_id before the ownership change, if set. */
  oldUserId?:
    | string
    | undefined;
  /** The user_group before the ownership change, if set. */
  oldUserGroup?:
    | string
    | undefined;
  /** The user_id after the ownership change, if set. */
  newUserId?:
    | string
    | undefined;
  /** The user_group after the ownership change, if set. */
  newUserGroup?: string | undefined;
}

/** Message to denote that a comment has been added or edited on a userTaskRun */
export interface UserTaskEvent_UTECommented {
  /** The id of the user comment */
  userCommentId: number;
  /** This is the id of the user */
  userId: string;
  /**
   * This is the specific note/comment that a user wants to make
   * on a `UserTask`
   */
  comment: string;
}

/** Message to denote that a userTaskRun has been deleted */
export interface UserTaskEvent_UTECommentDeleted {
  /** The id of the comment that will be deleted */
  userCommentId: number;
  /** The id of the user who deleted the comment */
  userId: string;
}

/** Empty message denoting a `userTaskRunCompleted` */
export interface UserTaskEvent_UTECompleted {
}

function createBaseUserTaskDef(): UserTaskDef {
  return { name: "", version: 0, description: undefined, fields: [], createdAt: undefined };
}

export const UserTaskDef = {
  encode(message: UserTaskDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.fields) {
      UserTaskField.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fields.push(UserTaskField.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskDef {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => UserTaskField.fromJSON(e)) : [],
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : undefined,
    };
  },

  toJSON(message: UserTaskDef): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => UserTaskField.toJSON(e));
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskDef>): UserTaskDef {
    return UserTaskDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskDef>): UserTaskDef {
    const message = createBaseUserTaskDef();
    message.name = object.name ?? "";
    message.version = object.version ?? 0;
    message.description = object.description ?? undefined;
    message.fields = object.fields?.map((e) => UserTaskField.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseUserTaskField(): UserTaskField {
  return { name: "", type: VariableType.JSON_OBJ, description: undefined, displayName: "", required: false };
}

export const UserTaskField = {
  encode(message: UserTaskField, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== VariableType.JSON_OBJ) {
      writer.uint32(16).int32(variableTypeToNumber(message.type));
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.required !== false) {
      writer.uint32(40).bool(message.required);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskField {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = variableTypeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.required = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskField {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? variableTypeFromJSON(object.type) : VariableType.JSON_OBJ,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
    };
  },

  toJSON(message: UserTaskField): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== VariableType.JSON_OBJ) {
      obj.type = variableTypeToJSON(message.type);
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskField>): UserTaskField {
    return UserTaskField.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskField>): UserTaskField {
    const message = createBaseUserTaskField();
    message.name = object.name ?? "";
    message.type = object.type ?? VariableType.JSON_OBJ;
    message.description = object.description ?? undefined;
    message.displayName = object.displayName ?? "";
    message.required = object.required ?? false;
    return message;
  },
};

function createBaseUserTaskRun(): UserTaskRun {
  return {
    id: undefined,
    userTaskDefId: undefined,
    userGroup: undefined,
    userId: undefined,
    results: {},
    status: UserTaskRunStatus.UNASSIGNED,
    events: [],
    notes: undefined,
    scheduledTime: undefined,
    nodeRunId: undefined,
    epoch: 0,
  };
}

export const UserTaskRun = {
  encode(message: UserTaskRun, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      UserTaskRunId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.userTaskDefId !== undefined) {
      UserTaskDefId.encode(message.userTaskDefId, writer.uint32(18).fork()).ldelim();
    }
    if (message.userGroup !== undefined) {
      writer.uint32(26).string(message.userGroup);
    }
    if (message.userId !== undefined) {
      writer.uint32(34).string(message.userId);
    }
    Object.entries(message.results).forEach(([key, value]) => {
      UserTaskRun_ResultsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    if (message.status !== UserTaskRunStatus.UNASSIGNED) {
      writer.uint32(56).int32(userTaskRunStatusToNumber(message.status));
    }
    for (const v of message.events) {
      UserTaskEvent.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.notes !== undefined) {
      writer.uint32(74).string(message.notes);
    }
    if (message.scheduledTime !== undefined) {
      Timestamp.encode(toTimestamp(message.scheduledTime), writer.uint32(82).fork()).ldelim();
    }
    if (message.nodeRunId !== undefined) {
      NodeRunId.encode(message.nodeRunId, writer.uint32(90).fork()).ldelim();
    }
    if (message.epoch !== 0) {
      writer.uint32(96).int32(message.epoch);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskRun {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = UserTaskRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userTaskDefId = UserTaskDefId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userGroup = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = UserTaskRun_ResultsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.results[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.status = userTaskRunStatusFromJSON(reader.int32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.events.push(UserTaskEvent.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.scheduledTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.nodeRunId = NodeRunId.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.epoch = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskRun {
    return {
      id: isSet(object.id) ? UserTaskRunId.fromJSON(object.id) : undefined,
      userTaskDefId: isSet(object.userTaskDefId) ? UserTaskDefId.fromJSON(object.userTaskDefId) : undefined,
      userGroup: isSet(object.userGroup) ? globalThis.String(object.userGroup) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
      results: isObject(object.results)
        ? Object.entries(object.results).reduce<{ [key: string]: VariableValue }>((acc, [key, value]) => {
          acc[key] = VariableValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      status: isSet(object.status) ? userTaskRunStatusFromJSON(object.status) : UserTaskRunStatus.UNASSIGNED,
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => UserTaskEvent.fromJSON(e)) : [],
      notes: isSet(object.notes) ? globalThis.String(object.notes) : undefined,
      scheduledTime: isSet(object.scheduledTime) ? globalThis.String(object.scheduledTime) : undefined,
      nodeRunId: isSet(object.nodeRunId) ? NodeRunId.fromJSON(object.nodeRunId) : undefined,
      epoch: isSet(object.epoch) ? globalThis.Number(object.epoch) : 0,
    };
  },

  toJSON(message: UserTaskRun): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = UserTaskRunId.toJSON(message.id);
    }
    if (message.userTaskDefId !== undefined) {
      obj.userTaskDefId = UserTaskDefId.toJSON(message.userTaskDefId);
    }
    if (message.userGroup !== undefined) {
      obj.userGroup = message.userGroup;
    }
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    if (message.results) {
      const entries = Object.entries(message.results);
      if (entries.length > 0) {
        obj.results = {};
        entries.forEach(([k, v]) => {
          obj.results[k] = VariableValue.toJSON(v);
        });
      }
    }
    if (message.status !== UserTaskRunStatus.UNASSIGNED) {
      obj.status = userTaskRunStatusToJSON(message.status);
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => UserTaskEvent.toJSON(e));
    }
    if (message.notes !== undefined) {
      obj.notes = message.notes;
    }
    if (message.scheduledTime !== undefined) {
      obj.scheduledTime = message.scheduledTime;
    }
    if (message.nodeRunId !== undefined) {
      obj.nodeRunId = NodeRunId.toJSON(message.nodeRunId);
    }
    if (message.epoch !== 0) {
      obj.epoch = Math.round(message.epoch);
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskRun>): UserTaskRun {
    return UserTaskRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskRun>): UserTaskRun {
    const message = createBaseUserTaskRun();
    message.id = (object.id !== undefined && object.id !== null) ? UserTaskRunId.fromPartial(object.id) : undefined;
    message.userTaskDefId = (object.userTaskDefId !== undefined && object.userTaskDefId !== null)
      ? UserTaskDefId.fromPartial(object.userTaskDefId)
      : undefined;
    message.userGroup = object.userGroup ?? undefined;
    message.userId = object.userId ?? undefined;
    message.results = Object.entries(object.results ?? {}).reduce<{ [key: string]: VariableValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = VariableValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.status = object.status ?? UserTaskRunStatus.UNASSIGNED;
    message.events = object.events?.map((e) => UserTaskEvent.fromPartial(e)) || [];
    message.notes = object.notes ?? undefined;
    message.scheduledTime = object.scheduledTime ?? undefined;
    message.nodeRunId = (object.nodeRunId !== undefined && object.nodeRunId !== null)
      ? NodeRunId.fromPartial(object.nodeRunId)
      : undefined;
    message.epoch = object.epoch ?? 0;
    return message;
  },
};

function createBaseUserTaskRun_ResultsEntry(): UserTaskRun_ResultsEntry {
  return { key: "", value: undefined };
}

export const UserTaskRun_ResultsEntry = {
  encode(message: UserTaskRun_ResultsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      VariableValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskRun_ResultsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskRun_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = VariableValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskRun_ResultsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? VariableValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: UserTaskRun_ResultsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = VariableValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskRun_ResultsEntry>): UserTaskRun_ResultsEntry {
    return UserTaskRun_ResultsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskRun_ResultsEntry>): UserTaskRun_ResultsEntry {
    const message = createBaseUserTaskRun_ResultsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAssignUserTaskRunRequest(): AssignUserTaskRunRequest {
  return { userTaskRunId: undefined, overrideClaim: false, userGroup: undefined, userId: undefined };
}

export const AssignUserTaskRunRequest = {
  encode(message: AssignUserTaskRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userTaskRunId !== undefined) {
      UserTaskRunId.encode(message.userTaskRunId, writer.uint32(10).fork()).ldelim();
    }
    if (message.overrideClaim !== false) {
      writer.uint32(16).bool(message.overrideClaim);
    }
    if (message.userGroup !== undefined) {
      writer.uint32(26).string(message.userGroup);
    }
    if (message.userId !== undefined) {
      writer.uint32(34).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssignUserTaskRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignUserTaskRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userTaskRunId = UserTaskRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.overrideClaim = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userGroup = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignUserTaskRunRequest {
    return {
      userTaskRunId: isSet(object.userTaskRunId) ? UserTaskRunId.fromJSON(object.userTaskRunId) : undefined,
      overrideClaim: isSet(object.overrideClaim) ? globalThis.Boolean(object.overrideClaim) : false,
      userGroup: isSet(object.userGroup) ? globalThis.String(object.userGroup) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
    };
  },

  toJSON(message: AssignUserTaskRunRequest): unknown {
    const obj: any = {};
    if (message.userTaskRunId !== undefined) {
      obj.userTaskRunId = UserTaskRunId.toJSON(message.userTaskRunId);
    }
    if (message.overrideClaim !== false) {
      obj.overrideClaim = message.overrideClaim;
    }
    if (message.userGroup !== undefined) {
      obj.userGroup = message.userGroup;
    }
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    return obj;
  },

  create(base?: DeepPartial<AssignUserTaskRunRequest>): AssignUserTaskRunRequest {
    return AssignUserTaskRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssignUserTaskRunRequest>): AssignUserTaskRunRequest {
    const message = createBaseAssignUserTaskRunRequest();
    message.userTaskRunId = (object.userTaskRunId !== undefined && object.userTaskRunId !== null)
      ? UserTaskRunId.fromPartial(object.userTaskRunId)
      : undefined;
    message.overrideClaim = object.overrideClaim ?? false;
    message.userGroup = object.userGroup ?? undefined;
    message.userId = object.userId ?? undefined;
    return message;
  },
};

function createBaseCompleteUserTaskRunRequest(): CompleteUserTaskRunRequest {
  return { userTaskRunId: undefined, results: {}, userId: "" };
}

export const CompleteUserTaskRunRequest = {
  encode(message: CompleteUserTaskRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userTaskRunId !== undefined) {
      UserTaskRunId.encode(message.userTaskRunId, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.results).forEach(([key, value]) => {
      CompleteUserTaskRunRequest_ResultsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CompleteUserTaskRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteUserTaskRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userTaskRunId = UserTaskRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = CompleteUserTaskRunRequest_ResultsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.results[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteUserTaskRunRequest {
    return {
      userTaskRunId: isSet(object.userTaskRunId) ? UserTaskRunId.fromJSON(object.userTaskRunId) : undefined,
      results: isObject(object.results)
        ? Object.entries(object.results).reduce<{ [key: string]: VariableValue }>((acc, [key, value]) => {
          acc[key] = VariableValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: CompleteUserTaskRunRequest): unknown {
    const obj: any = {};
    if (message.userTaskRunId !== undefined) {
      obj.userTaskRunId = UserTaskRunId.toJSON(message.userTaskRunId);
    }
    if (message.results) {
      const entries = Object.entries(message.results);
      if (entries.length > 0) {
        obj.results = {};
        entries.forEach(([k, v]) => {
          obj.results[k] = VariableValue.toJSON(v);
        });
      }
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create(base?: DeepPartial<CompleteUserTaskRunRequest>): CompleteUserTaskRunRequest {
    return CompleteUserTaskRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteUserTaskRunRequest>): CompleteUserTaskRunRequest {
    const message = createBaseCompleteUserTaskRunRequest();
    message.userTaskRunId = (object.userTaskRunId !== undefined && object.userTaskRunId !== null)
      ? UserTaskRunId.fromPartial(object.userTaskRunId)
      : undefined;
    message.results = Object.entries(object.results ?? {}).reduce<{ [key: string]: VariableValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = VariableValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseCompleteUserTaskRunRequest_ResultsEntry(): CompleteUserTaskRunRequest_ResultsEntry {
  return { key: "", value: undefined };
}

export const CompleteUserTaskRunRequest_ResultsEntry = {
  encode(message: CompleteUserTaskRunRequest_ResultsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      VariableValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CompleteUserTaskRunRequest_ResultsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteUserTaskRunRequest_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = VariableValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteUserTaskRunRequest_ResultsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? VariableValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: CompleteUserTaskRunRequest_ResultsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = VariableValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CompleteUserTaskRunRequest_ResultsEntry>): CompleteUserTaskRunRequest_ResultsEntry {
    return CompleteUserTaskRunRequest_ResultsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteUserTaskRunRequest_ResultsEntry>): CompleteUserTaskRunRequest_ResultsEntry {
    const message = createBaseCompleteUserTaskRunRequest_ResultsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSaveUserTaskRunProgressRequest(): SaveUserTaskRunProgressRequest {
  return {
    userTaskRunId: undefined,
    results: {},
    userId: "",
    policy: SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.FAIL_IF_CLAIMED_BY_OTHER,
  };
}

export const SaveUserTaskRunProgressRequest = {
  encode(message: SaveUserTaskRunProgressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userTaskRunId !== undefined) {
      UserTaskRunId.encode(message.userTaskRunId, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.results).forEach(([key, value]) => {
      SaveUserTaskRunProgressRequest_ResultsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.policy !== SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.FAIL_IF_CLAIMED_BY_OTHER) {
      writer.uint32(32).int32(saveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicyToNumber(message.policy));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SaveUserTaskRunProgressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveUserTaskRunProgressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userTaskRunId = UserTaskRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = SaveUserTaskRunProgressRequest_ResultsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.results[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.policy = saveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicyFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveUserTaskRunProgressRequest {
    return {
      userTaskRunId: isSet(object.userTaskRunId) ? UserTaskRunId.fromJSON(object.userTaskRunId) : undefined,
      results: isObject(object.results)
        ? Object.entries(object.results).reduce<{ [key: string]: VariableValue }>((acc, [key, value]) => {
          acc[key] = VariableValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      policy: isSet(object.policy)
        ? saveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicyFromJSON(object.policy)
        : SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.FAIL_IF_CLAIMED_BY_OTHER,
    };
  },

  toJSON(message: SaveUserTaskRunProgressRequest): unknown {
    const obj: any = {};
    if (message.userTaskRunId !== undefined) {
      obj.userTaskRunId = UserTaskRunId.toJSON(message.userTaskRunId);
    }
    if (message.results) {
      const entries = Object.entries(message.results);
      if (entries.length > 0) {
        obj.results = {};
        entries.forEach(([k, v]) => {
          obj.results[k] = VariableValue.toJSON(v);
        });
      }
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.policy !== SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.FAIL_IF_CLAIMED_BY_OTHER) {
      obj.policy = saveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicyToJSON(message.policy);
    }
    return obj;
  },

  create(base?: DeepPartial<SaveUserTaskRunProgressRequest>): SaveUserTaskRunProgressRequest {
    return SaveUserTaskRunProgressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SaveUserTaskRunProgressRequest>): SaveUserTaskRunProgressRequest {
    const message = createBaseSaveUserTaskRunProgressRequest();
    message.userTaskRunId = (object.userTaskRunId !== undefined && object.userTaskRunId !== null)
      ? UserTaskRunId.fromPartial(object.userTaskRunId)
      : undefined;
    message.results = Object.entries(object.results ?? {}).reduce<{ [key: string]: VariableValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = VariableValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.userId = object.userId ?? "";
    message.policy = object.policy ??
      SaveUserTaskRunProgressRequest_SaveUserTaskRunAssignmentPolicy.FAIL_IF_CLAIMED_BY_OTHER;
    return message;
  },
};

function createBaseSaveUserTaskRunProgressRequest_ResultsEntry(): SaveUserTaskRunProgressRequest_ResultsEntry {
  return { key: "", value: undefined };
}

export const SaveUserTaskRunProgressRequest_ResultsEntry = {
  encode(message: SaveUserTaskRunProgressRequest_ResultsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      VariableValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SaveUserTaskRunProgressRequest_ResultsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveUserTaskRunProgressRequest_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = VariableValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveUserTaskRunProgressRequest_ResultsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? VariableValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SaveUserTaskRunProgressRequest_ResultsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = VariableValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SaveUserTaskRunProgressRequest_ResultsEntry>): SaveUserTaskRunProgressRequest_ResultsEntry {
    return SaveUserTaskRunProgressRequest_ResultsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SaveUserTaskRunProgressRequest_ResultsEntry>,
  ): SaveUserTaskRunProgressRequest_ResultsEntry {
    const message = createBaseSaveUserTaskRunProgressRequest_ResultsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCancelUserTaskRunRequest(): CancelUserTaskRunRequest {
  return { userTaskRunId: undefined };
}

export const CancelUserTaskRunRequest = {
  encode(message: CancelUserTaskRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userTaskRunId !== undefined) {
      UserTaskRunId.encode(message.userTaskRunId, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelUserTaskRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelUserTaskRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userTaskRunId = UserTaskRunId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelUserTaskRunRequest {
    return { userTaskRunId: isSet(object.userTaskRunId) ? UserTaskRunId.fromJSON(object.userTaskRunId) : undefined };
  },

  toJSON(message: CancelUserTaskRunRequest): unknown {
    const obj: any = {};
    if (message.userTaskRunId !== undefined) {
      obj.userTaskRunId = UserTaskRunId.toJSON(message.userTaskRunId);
    }
    return obj;
  },

  create(base?: DeepPartial<CancelUserTaskRunRequest>): CancelUserTaskRunRequest {
    return CancelUserTaskRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelUserTaskRunRequest>): CancelUserTaskRunRequest {
    const message = createBaseCancelUserTaskRunRequest();
    message.userTaskRunId = (object.userTaskRunId !== undefined && object.userTaskRunId !== null)
      ? UserTaskRunId.fromPartial(object.userTaskRunId)
      : undefined;
    return message;
  },
};

function createBasePutUserTaskRunCommentRequest(): PutUserTaskRunCommentRequest {
  return { userTaskRunId: undefined, userId: "", comment: "" };
}

export const PutUserTaskRunCommentRequest = {
  encode(message: PutUserTaskRunCommentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userTaskRunId !== undefined) {
      UserTaskRunId.encode(message.userTaskRunId, writer.uint32(10).fork()).ldelim();
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutUserTaskRunCommentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutUserTaskRunCommentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userTaskRunId = UserTaskRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutUserTaskRunCommentRequest {
    return {
      userTaskRunId: isSet(object.userTaskRunId) ? UserTaskRunId.fromJSON(object.userTaskRunId) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: PutUserTaskRunCommentRequest): unknown {
    const obj: any = {};
    if (message.userTaskRunId !== undefined) {
      obj.userTaskRunId = UserTaskRunId.toJSON(message.userTaskRunId);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<PutUserTaskRunCommentRequest>): PutUserTaskRunCommentRequest {
    return PutUserTaskRunCommentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PutUserTaskRunCommentRequest>): PutUserTaskRunCommentRequest {
    const message = createBasePutUserTaskRunCommentRequest();
    message.userTaskRunId = (object.userTaskRunId !== undefined && object.userTaskRunId !== null)
      ? UserTaskRunId.fromPartial(object.userTaskRunId)
      : undefined;
    message.userId = object.userId ?? "";
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseEditUserTaskRunCommentRequest(): EditUserTaskRunCommentRequest {
  return { userCommentId: 0, userTaskRunId: undefined, userId: "", comment: "" };
}

export const EditUserTaskRunCommentRequest = {
  encode(message: EditUserTaskRunCommentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userCommentId !== 0) {
      writer.uint32(8).int32(message.userCommentId);
    }
    if (message.userTaskRunId !== undefined) {
      UserTaskRunId.encode(message.userTaskRunId, writer.uint32(18).fork()).ldelim();
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EditUserTaskRunCommentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditUserTaskRunCommentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.userCommentId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userTaskRunId = UserTaskRunId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditUserTaskRunCommentRequest {
    return {
      userCommentId: isSet(object.userCommentId) ? globalThis.Number(object.userCommentId) : 0,
      userTaskRunId: isSet(object.userTaskRunId) ? UserTaskRunId.fromJSON(object.userTaskRunId) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: EditUserTaskRunCommentRequest): unknown {
    const obj: any = {};
    if (message.userCommentId !== 0) {
      obj.userCommentId = Math.round(message.userCommentId);
    }
    if (message.userTaskRunId !== undefined) {
      obj.userTaskRunId = UserTaskRunId.toJSON(message.userTaskRunId);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<EditUserTaskRunCommentRequest>): EditUserTaskRunCommentRequest {
    return EditUserTaskRunCommentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EditUserTaskRunCommentRequest>): EditUserTaskRunCommentRequest {
    const message = createBaseEditUserTaskRunCommentRequest();
    message.userCommentId = object.userCommentId ?? 0;
    message.userTaskRunId = (object.userTaskRunId !== undefined && object.userTaskRunId !== null)
      ? UserTaskRunId.fromPartial(object.userTaskRunId)
      : undefined;
    message.userId = object.userId ?? "";
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseDeleteUserTaskRunCommentRequest(): DeleteUserTaskRunCommentRequest {
  return { userTaskRunId: undefined, userCommentId: 0, userId: "" };
}

export const DeleteUserTaskRunCommentRequest = {
  encode(message: DeleteUserTaskRunCommentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userTaskRunId !== undefined) {
      UserTaskRunId.encode(message.userTaskRunId, writer.uint32(10).fork()).ldelim();
    }
    if (message.userCommentId !== 0) {
      writer.uint32(16).int32(message.userCommentId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserTaskRunCommentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserTaskRunCommentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userTaskRunId = UserTaskRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userCommentId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserTaskRunCommentRequest {
    return {
      userTaskRunId: isSet(object.userTaskRunId) ? UserTaskRunId.fromJSON(object.userTaskRunId) : undefined,
      userCommentId: isSet(object.userCommentId) ? globalThis.Number(object.userCommentId) : 0,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: DeleteUserTaskRunCommentRequest): unknown {
    const obj: any = {};
    if (message.userTaskRunId !== undefined) {
      obj.userTaskRunId = UserTaskRunId.toJSON(message.userTaskRunId);
    }
    if (message.userCommentId !== 0) {
      obj.userCommentId = Math.round(message.userCommentId);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteUserTaskRunCommentRequest>): DeleteUserTaskRunCommentRequest {
    return DeleteUserTaskRunCommentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteUserTaskRunCommentRequest>): DeleteUserTaskRunCommentRequest {
    const message = createBaseDeleteUserTaskRunCommentRequest();
    message.userTaskRunId = (object.userTaskRunId !== undefined && object.userTaskRunId !== null)
      ? UserTaskRunId.fromPartial(object.userTaskRunId)
      : undefined;
    message.userCommentId = object.userCommentId ?? 0;
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseUserTaskTriggerReference(): UserTaskTriggerReference {
  return { nodeRunId: undefined, userTaskEventNumber: 0, userId: undefined, userGroup: undefined };
}

export const UserTaskTriggerReference = {
  encode(message: UserTaskTriggerReference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeRunId !== undefined) {
      NodeRunId.encode(message.nodeRunId, writer.uint32(10).fork()).ldelim();
    }
    if (message.userTaskEventNumber !== 0) {
      writer.uint32(16).int32(message.userTaskEventNumber);
    }
    if (message.userId !== undefined) {
      writer.uint32(26).string(message.userId);
    }
    if (message.userGroup !== undefined) {
      writer.uint32(34).string(message.userGroup);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskTriggerReference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskTriggerReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeRunId = NodeRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userTaskEventNumber = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userGroup = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskTriggerReference {
    return {
      nodeRunId: isSet(object.nodeRunId) ? NodeRunId.fromJSON(object.nodeRunId) : undefined,
      userTaskEventNumber: isSet(object.userTaskEventNumber) ? globalThis.Number(object.userTaskEventNumber) : 0,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
      userGroup: isSet(object.userGroup) ? globalThis.String(object.userGroup) : undefined,
    };
  },

  toJSON(message: UserTaskTriggerReference): unknown {
    const obj: any = {};
    if (message.nodeRunId !== undefined) {
      obj.nodeRunId = NodeRunId.toJSON(message.nodeRunId);
    }
    if (message.userTaskEventNumber !== 0) {
      obj.userTaskEventNumber = Math.round(message.userTaskEventNumber);
    }
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    if (message.userGroup !== undefined) {
      obj.userGroup = message.userGroup;
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskTriggerReference>): UserTaskTriggerReference {
    return UserTaskTriggerReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskTriggerReference>): UserTaskTriggerReference {
    const message = createBaseUserTaskTriggerReference();
    message.nodeRunId = (object.nodeRunId !== undefined && object.nodeRunId !== null)
      ? NodeRunId.fromPartial(object.nodeRunId)
      : undefined;
    message.userTaskEventNumber = object.userTaskEventNumber ?? 0;
    message.userId = object.userId ?? undefined;
    message.userGroup = object.userGroup ?? undefined;
    return message;
  },
};

function createBaseUserTaskEvent(): UserTaskEvent {
  return { time: undefined, event: undefined };
}

export const UserTaskEvent = {
  encode(message: UserTaskEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(10).fork()).ldelim();
    }
    switch (message.event?.$case) {
      case "taskExecuted":
        UserTaskEvent_UTETaskExecuted.encode(message.event.value, writer.uint32(18).fork()).ldelim();
        break;
      case "assigned":
        UserTaskEvent_UTEAssigned.encode(message.event.value, writer.uint32(26).fork()).ldelim();
        break;
      case "cancelled":
        UserTaskEvent_UTECancelled.encode(message.event.value, writer.uint32(34).fork()).ldelim();
        break;
      case "saved":
        UserTaskEvent_UTESaved.encode(message.event.value, writer.uint32(42).fork()).ldelim();
        break;
      case "commentAdded":
        UserTaskEvent_UTECommented.encode(message.event.value, writer.uint32(50).fork()).ldelim();
        break;
      case "commentEdited":
        UserTaskEvent_UTECommented.encode(message.event.value, writer.uint32(58).fork()).ldelim();
        break;
      case "commentDeleted":
        UserTaskEvent_UTECommentDeleted.encode(message.event.value, writer.uint32(66).fork()).ldelim();
        break;
      case "completed":
        UserTaskEvent_UTECompleted.encode(message.event.value, writer.uint32(74).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.event = {
            $case: "taskExecuted",
            value: UserTaskEvent_UTETaskExecuted.decode(reader, reader.uint32()),
          };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.event = { $case: "assigned", value: UserTaskEvent_UTEAssigned.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.event = { $case: "cancelled", value: UserTaskEvent_UTECancelled.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.event = { $case: "saved", value: UserTaskEvent_UTESaved.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.event = { $case: "commentAdded", value: UserTaskEvent_UTECommented.decode(reader, reader.uint32()) };
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.event = { $case: "commentEdited", value: UserTaskEvent_UTECommented.decode(reader, reader.uint32()) };
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.event = {
            $case: "commentDeleted",
            value: UserTaskEvent_UTECommentDeleted.decode(reader, reader.uint32()),
          };
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.event = { $case: "completed", value: UserTaskEvent_UTECompleted.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskEvent {
    return {
      time: isSet(object.time) ? globalThis.String(object.time) : undefined,
      event: isSet(object.taskExecuted)
        ? { $case: "taskExecuted", value: UserTaskEvent_UTETaskExecuted.fromJSON(object.taskExecuted) }
        : isSet(object.assigned)
        ? { $case: "assigned", value: UserTaskEvent_UTEAssigned.fromJSON(object.assigned) }
        : isSet(object.cancelled)
        ? { $case: "cancelled", value: UserTaskEvent_UTECancelled.fromJSON(object.cancelled) }
        : isSet(object.saved)
        ? { $case: "saved", value: UserTaskEvent_UTESaved.fromJSON(object.saved) }
        : isSet(object.commentAdded)
        ? { $case: "commentAdded", value: UserTaskEvent_UTECommented.fromJSON(object.commentAdded) }
        : isSet(object.commentEdited)
        ? { $case: "commentEdited", value: UserTaskEvent_UTECommented.fromJSON(object.commentEdited) }
        : isSet(object.commentDeleted)
        ? { $case: "commentDeleted", value: UserTaskEvent_UTECommentDeleted.fromJSON(object.commentDeleted) }
        : isSet(object.completed)
        ? { $case: "completed", value: UserTaskEvent_UTECompleted.fromJSON(object.completed) }
        : undefined,
    };
  },

  toJSON(message: UserTaskEvent): unknown {
    const obj: any = {};
    if (message.time !== undefined) {
      obj.time = message.time;
    }
    if (message.event?.$case === "taskExecuted") {
      obj.taskExecuted = UserTaskEvent_UTETaskExecuted.toJSON(message.event.value);
    }
    if (message.event?.$case === "assigned") {
      obj.assigned = UserTaskEvent_UTEAssigned.toJSON(message.event.value);
    }
    if (message.event?.$case === "cancelled") {
      obj.cancelled = UserTaskEvent_UTECancelled.toJSON(message.event.value);
    }
    if (message.event?.$case === "saved") {
      obj.saved = UserTaskEvent_UTESaved.toJSON(message.event.value);
    }
    if (message.event?.$case === "commentAdded") {
      obj.commentAdded = UserTaskEvent_UTECommented.toJSON(message.event.value);
    }
    if (message.event?.$case === "commentEdited") {
      obj.commentEdited = UserTaskEvent_UTECommented.toJSON(message.event.value);
    }
    if (message.event?.$case === "commentDeleted") {
      obj.commentDeleted = UserTaskEvent_UTECommentDeleted.toJSON(message.event.value);
    }
    if (message.event?.$case === "completed") {
      obj.completed = UserTaskEvent_UTECompleted.toJSON(message.event.value);
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskEvent>): UserTaskEvent {
    return UserTaskEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskEvent>): UserTaskEvent {
    const message = createBaseUserTaskEvent();
    message.time = object.time ?? undefined;
    if (object.event?.$case === "taskExecuted" && object.event?.value !== undefined && object.event?.value !== null) {
      message.event = { $case: "taskExecuted", value: UserTaskEvent_UTETaskExecuted.fromPartial(object.event.value) };
    }
    if (object.event?.$case === "assigned" && object.event?.value !== undefined && object.event?.value !== null) {
      message.event = { $case: "assigned", value: UserTaskEvent_UTEAssigned.fromPartial(object.event.value) };
    }
    if (object.event?.$case === "cancelled" && object.event?.value !== undefined && object.event?.value !== null) {
      message.event = { $case: "cancelled", value: UserTaskEvent_UTECancelled.fromPartial(object.event.value) };
    }
    if (object.event?.$case === "saved" && object.event?.value !== undefined && object.event?.value !== null) {
      message.event = { $case: "saved", value: UserTaskEvent_UTESaved.fromPartial(object.event.value) };
    }
    if (object.event?.$case === "commentAdded" && object.event?.value !== undefined && object.event?.value !== null) {
      message.event = { $case: "commentAdded", value: UserTaskEvent_UTECommented.fromPartial(object.event.value) };
    }
    if (object.event?.$case === "commentEdited" && object.event?.value !== undefined && object.event?.value !== null) {
      message.event = { $case: "commentEdited", value: UserTaskEvent_UTECommented.fromPartial(object.event.value) };
    }
    if (object.event?.$case === "commentDeleted" && object.event?.value !== undefined && object.event?.value !== null) {
      message.event = {
        $case: "commentDeleted",
        value: UserTaskEvent_UTECommentDeleted.fromPartial(object.event.value),
      };
    }
    if (object.event?.$case === "completed" && object.event?.value !== undefined && object.event?.value !== null) {
      message.event = { $case: "completed", value: UserTaskEvent_UTECompleted.fromPartial(object.event.value) };
    }
    return message;
  },
};

function createBaseUserTaskEvent_UTECancelled(): UserTaskEvent_UTECancelled {
  return { message: "" };
}

export const UserTaskEvent_UTECancelled = {
  encode(message: UserTaskEvent_UTECancelled, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskEvent_UTECancelled {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskEvent_UTECancelled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskEvent_UTECancelled {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: UserTaskEvent_UTECancelled): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskEvent_UTECancelled>): UserTaskEvent_UTECancelled {
    return UserTaskEvent_UTECancelled.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskEvent_UTECancelled>): UserTaskEvent_UTECancelled {
    const message = createBaseUserTaskEvent_UTECancelled();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseUserTaskEvent_UTETaskExecuted(): UserTaskEvent_UTETaskExecuted {
  return { taskRun: undefined };
}

export const UserTaskEvent_UTETaskExecuted = {
  encode(message: UserTaskEvent_UTETaskExecuted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskRun !== undefined) {
      TaskRunId.encode(message.taskRun, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskEvent_UTETaskExecuted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskEvent_UTETaskExecuted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskRun = TaskRunId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskEvent_UTETaskExecuted {
    return { taskRun: isSet(object.taskRun) ? TaskRunId.fromJSON(object.taskRun) : undefined };
  },

  toJSON(message: UserTaskEvent_UTETaskExecuted): unknown {
    const obj: any = {};
    if (message.taskRun !== undefined) {
      obj.taskRun = TaskRunId.toJSON(message.taskRun);
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskEvent_UTETaskExecuted>): UserTaskEvent_UTETaskExecuted {
    return UserTaskEvent_UTETaskExecuted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskEvent_UTETaskExecuted>): UserTaskEvent_UTETaskExecuted {
    const message = createBaseUserTaskEvent_UTETaskExecuted();
    message.taskRun = (object.taskRun !== undefined && object.taskRun !== null)
      ? TaskRunId.fromPartial(object.taskRun)
      : undefined;
    return message;
  },
};

function createBaseUserTaskEvent_UTESaved(): UserTaskEvent_UTESaved {
  return { userId: "", results: {} };
}

export const UserTaskEvent_UTESaved = {
  encode(message: UserTaskEvent_UTESaved, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    Object.entries(message.results).forEach(([key, value]) => {
      UserTaskEvent_UTESaved_ResultsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskEvent_UTESaved {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskEvent_UTESaved();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = UserTaskEvent_UTESaved_ResultsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.results[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskEvent_UTESaved {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      results: isObject(object.results)
        ? Object.entries(object.results).reduce<{ [key: string]: VariableValue }>((acc, [key, value]) => {
          acc[key] = VariableValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UserTaskEvent_UTESaved): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.results) {
      const entries = Object.entries(message.results);
      if (entries.length > 0) {
        obj.results = {};
        entries.forEach(([k, v]) => {
          obj.results[k] = VariableValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskEvent_UTESaved>): UserTaskEvent_UTESaved {
    return UserTaskEvent_UTESaved.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskEvent_UTESaved>): UserTaskEvent_UTESaved {
    const message = createBaseUserTaskEvent_UTESaved();
    message.userId = object.userId ?? "";
    message.results = Object.entries(object.results ?? {}).reduce<{ [key: string]: VariableValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = VariableValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseUserTaskEvent_UTESaved_ResultsEntry(): UserTaskEvent_UTESaved_ResultsEntry {
  return { key: "", value: undefined };
}

export const UserTaskEvent_UTESaved_ResultsEntry = {
  encode(message: UserTaskEvent_UTESaved_ResultsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      VariableValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskEvent_UTESaved_ResultsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskEvent_UTESaved_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = VariableValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskEvent_UTESaved_ResultsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? VariableValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: UserTaskEvent_UTESaved_ResultsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = VariableValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskEvent_UTESaved_ResultsEntry>): UserTaskEvent_UTESaved_ResultsEntry {
    return UserTaskEvent_UTESaved_ResultsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskEvent_UTESaved_ResultsEntry>): UserTaskEvent_UTESaved_ResultsEntry {
    const message = createBaseUserTaskEvent_UTESaved_ResultsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseUserTaskEvent_UTEAssigned(): UserTaskEvent_UTEAssigned {
  return { oldUserId: undefined, oldUserGroup: undefined, newUserId: undefined, newUserGroup: undefined };
}

export const UserTaskEvent_UTEAssigned = {
  encode(message: UserTaskEvent_UTEAssigned, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.oldUserId !== undefined) {
      writer.uint32(10).string(message.oldUserId);
    }
    if (message.oldUserGroup !== undefined) {
      writer.uint32(18).string(message.oldUserGroup);
    }
    if (message.newUserId !== undefined) {
      writer.uint32(26).string(message.newUserId);
    }
    if (message.newUserGroup !== undefined) {
      writer.uint32(34).string(message.newUserGroup);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskEvent_UTEAssigned {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskEvent_UTEAssigned();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.oldUserId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.oldUserGroup = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.newUserId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.newUserGroup = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskEvent_UTEAssigned {
    return {
      oldUserId: isSet(object.oldUserId) ? globalThis.String(object.oldUserId) : undefined,
      oldUserGroup: isSet(object.oldUserGroup) ? globalThis.String(object.oldUserGroup) : undefined,
      newUserId: isSet(object.newUserId) ? globalThis.String(object.newUserId) : undefined,
      newUserGroup: isSet(object.newUserGroup) ? globalThis.String(object.newUserGroup) : undefined,
    };
  },

  toJSON(message: UserTaskEvent_UTEAssigned): unknown {
    const obj: any = {};
    if (message.oldUserId !== undefined) {
      obj.oldUserId = message.oldUserId;
    }
    if (message.oldUserGroup !== undefined) {
      obj.oldUserGroup = message.oldUserGroup;
    }
    if (message.newUserId !== undefined) {
      obj.newUserId = message.newUserId;
    }
    if (message.newUserGroup !== undefined) {
      obj.newUserGroup = message.newUserGroup;
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskEvent_UTEAssigned>): UserTaskEvent_UTEAssigned {
    return UserTaskEvent_UTEAssigned.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskEvent_UTEAssigned>): UserTaskEvent_UTEAssigned {
    const message = createBaseUserTaskEvent_UTEAssigned();
    message.oldUserId = object.oldUserId ?? undefined;
    message.oldUserGroup = object.oldUserGroup ?? undefined;
    message.newUserId = object.newUserId ?? undefined;
    message.newUserGroup = object.newUserGroup ?? undefined;
    return message;
  },
};

function createBaseUserTaskEvent_UTECommented(): UserTaskEvent_UTECommented {
  return { userCommentId: 0, userId: "", comment: "" };
}

export const UserTaskEvent_UTECommented = {
  encode(message: UserTaskEvent_UTECommented, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userCommentId !== 0) {
      writer.uint32(8).int32(message.userCommentId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskEvent_UTECommented {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskEvent_UTECommented();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.userCommentId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskEvent_UTECommented {
    return {
      userCommentId: isSet(object.userCommentId) ? globalThis.Number(object.userCommentId) : 0,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: UserTaskEvent_UTECommented): unknown {
    const obj: any = {};
    if (message.userCommentId !== 0) {
      obj.userCommentId = Math.round(message.userCommentId);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskEvent_UTECommented>): UserTaskEvent_UTECommented {
    return UserTaskEvent_UTECommented.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskEvent_UTECommented>): UserTaskEvent_UTECommented {
    const message = createBaseUserTaskEvent_UTECommented();
    message.userCommentId = object.userCommentId ?? 0;
    message.userId = object.userId ?? "";
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseUserTaskEvent_UTECommentDeleted(): UserTaskEvent_UTECommentDeleted {
  return { userCommentId: 0, userId: "" };
}

export const UserTaskEvent_UTECommentDeleted = {
  encode(message: UserTaskEvent_UTECommentDeleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userCommentId !== 0) {
      writer.uint32(8).int32(message.userCommentId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskEvent_UTECommentDeleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskEvent_UTECommentDeleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.userCommentId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskEvent_UTECommentDeleted {
    return {
      userCommentId: isSet(object.userCommentId) ? globalThis.Number(object.userCommentId) : 0,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: UserTaskEvent_UTECommentDeleted): unknown {
    const obj: any = {};
    if (message.userCommentId !== 0) {
      obj.userCommentId = Math.round(message.userCommentId);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskEvent_UTECommentDeleted>): UserTaskEvent_UTECommentDeleted {
    return UserTaskEvent_UTECommentDeleted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskEvent_UTECommentDeleted>): UserTaskEvent_UTECommentDeleted {
    const message = createBaseUserTaskEvent_UTECommentDeleted();
    message.userCommentId = object.userCommentId ?? 0;
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseUserTaskEvent_UTECompleted(): UserTaskEvent_UTECompleted {
  return {};
}

export const UserTaskEvent_UTECompleted = {
  encode(_: UserTaskEvent_UTECompleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskEvent_UTECompleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskEvent_UTECompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UserTaskEvent_UTECompleted {
    return {};
  },

  toJSON(_: UserTaskEvent_UTECompleted): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UserTaskEvent_UTECompleted>): UserTaskEvent_UTECompleted {
    return UserTaskEvent_UTECompleted.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UserTaskEvent_UTECompleted>): UserTaskEvent_UTECompleted {
    const message = createBaseUserTaskEvent_UTECompleted();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
