// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v4.23.4
// source: common_wfspec.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { VariableType, variableTypeFromJSON, variableTypeToJSON, variableTypeToNumber } from "./common_enums";
import { StructDefId, TaskDefId } from "./object_id";
import { VariableValue } from "./variable";

/** Enumerates the available operations to mutate a variable in a WfRun. */
export enum VariableMutationType {
  /** ASSIGN - Set the variable specified by the LHS to the value of the RHS. */
  ASSIGN = "ASSIGN",
  /** ADD - Add the RHS to the LHS. */
  ADD = "ADD",
  /** EXTEND - Append the RHS to the LHS (valid if the LHS is a STR or JSON_ARR) */
  EXTEND = "EXTEND",
  /** SUBTRACT - Subtract the RHS from the LHS (both must be INT or DOUBLE) */
  SUBTRACT = "SUBTRACT",
  /** MULTIPLY - Multiply the LHS by the RHS (both must be INT or DOUBLE) */
  MULTIPLY = "MULTIPLY",
  /** DIVIDE - Divide the LHS by the RHS (both must be INT or DOUBLE) */
  DIVIDE = "DIVIDE",
  /** REMOVE_IF_PRESENT - Remove any occurrences of RHS from LHS (LHS must be JSON_ARR) */
  REMOVE_IF_PRESENT = "REMOVE_IF_PRESENT",
  /** REMOVE_INDEX - Remove item at index RHS from LHS (LHS must be JSON_ARR) */
  REMOVE_INDEX = "REMOVE_INDEX",
  /** REMOVE_KEY - Remove the key specified by RHS from the LHS (LHS must be JSON_OBJ) */
  REMOVE_KEY = "REMOVE_KEY",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function variableMutationTypeFromJSON(object: any): VariableMutationType {
  switch (object) {
    case 0:
    case "ASSIGN":
      return VariableMutationType.ASSIGN;
    case 1:
    case "ADD":
      return VariableMutationType.ADD;
    case 2:
    case "EXTEND":
      return VariableMutationType.EXTEND;
    case 3:
    case "SUBTRACT":
      return VariableMutationType.SUBTRACT;
    case 4:
    case "MULTIPLY":
      return VariableMutationType.MULTIPLY;
    case 5:
    case "DIVIDE":
      return VariableMutationType.DIVIDE;
    case 6:
    case "REMOVE_IF_PRESENT":
      return VariableMutationType.REMOVE_IF_PRESENT;
    case 7:
    case "REMOVE_INDEX":
      return VariableMutationType.REMOVE_INDEX;
    case 8:
    case "REMOVE_KEY":
      return VariableMutationType.REMOVE_KEY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VariableMutationType.UNRECOGNIZED;
  }
}

export function variableMutationTypeToJSON(object: VariableMutationType): string {
  switch (object) {
    case VariableMutationType.ASSIGN:
      return "ASSIGN";
    case VariableMutationType.ADD:
      return "ADD";
    case VariableMutationType.EXTEND:
      return "EXTEND";
    case VariableMutationType.SUBTRACT:
      return "SUBTRACT";
    case VariableMutationType.MULTIPLY:
      return "MULTIPLY";
    case VariableMutationType.DIVIDE:
      return "DIVIDE";
    case VariableMutationType.REMOVE_IF_PRESENT:
      return "REMOVE_IF_PRESENT";
    case VariableMutationType.REMOVE_INDEX:
      return "REMOVE_INDEX";
    case VariableMutationType.REMOVE_KEY:
      return "REMOVE_KEY";
    case VariableMutationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function variableMutationTypeToNumber(object: VariableMutationType): number {
  switch (object) {
    case VariableMutationType.ASSIGN:
      return 0;
    case VariableMutationType.ADD:
      return 1;
    case VariableMutationType.EXTEND:
      return 2;
    case VariableMutationType.SUBTRACT:
      return 3;
    case VariableMutationType.MULTIPLY:
      return 4;
    case VariableMutationType.DIVIDE:
      return 5;
    case VariableMutationType.REMOVE_IF_PRESENT:
      return 6;
    case VariableMutationType.REMOVE_INDEX:
      return 7;
    case VariableMutationType.REMOVE_KEY:
      return 8;
    case VariableMutationType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Operator for comparing two values to create a boolean expression. */
export enum Comparator {
  /** LESS_THAN - Equivalent to `<`. Only valid for primitive types (no JSON_OBJ or JSON_ARR). */
  LESS_THAN = "LESS_THAN",
  /** GREATER_THAN - Equivalent to `>`. Only valid for primitive types (no JSON_OBJ or JSON_ARR). */
  GREATER_THAN = "GREATER_THAN",
  /** LESS_THAN_EQ - Equivalent to `<=`. Only valid for primitive types (no JSON_OBJ or JSON_ARR). */
  LESS_THAN_EQ = "LESS_THAN_EQ",
  /** GREATER_THAN_EQ - Equivalent to `>=`. Only valid for primitive types (no JSON_OBJ or JSON_ARR). */
  GREATER_THAN_EQ = "GREATER_THAN_EQ",
  /**
   * EQUALS - This is valid for any variable type, and is similar to .equals() in Java.
   *
   * One note: if the RHS is a different type from the LHS, then LittleHorse will
   * try to cast the RHS to the same type as the LHS. If the cast fails, then the
   * ThreadRun fails with a VAR_SUB_ERROR.
   */
  EQUALS = "EQUALS",
  /** NOT_EQUALS - This is the inverse of `EQUALS` */
  NOT_EQUALS = "NOT_EQUALS",
  /**
   * IN - Only valid if the RHS is a JSON_OBJ or JSON_ARR. Valid for any type on the LHS.
   *
   * For the JSON_OBJ type, this returns true if the LHS is equal to a *KEY* in the
   * RHS. For the JSON_ARR type, it returns true if one of the elements of the RHS
   * is equal to the LHS.
   */
  IN = "IN",
  /** NOT_IN - The inverse of IN. */
  NOT_IN = "NOT_IN",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function comparatorFromJSON(object: any): Comparator {
  switch (object) {
    case 0:
    case "LESS_THAN":
      return Comparator.LESS_THAN;
    case 1:
    case "GREATER_THAN":
      return Comparator.GREATER_THAN;
    case 2:
    case "LESS_THAN_EQ":
      return Comparator.LESS_THAN_EQ;
    case 3:
    case "GREATER_THAN_EQ":
      return Comparator.GREATER_THAN_EQ;
    case 4:
    case "EQUALS":
      return Comparator.EQUALS;
    case 5:
    case "NOT_EQUALS":
      return Comparator.NOT_EQUALS;
    case 6:
    case "IN":
      return Comparator.IN;
    case 7:
    case "NOT_IN":
      return Comparator.NOT_IN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Comparator.UNRECOGNIZED;
  }
}

export function comparatorToJSON(object: Comparator): string {
  switch (object) {
    case Comparator.LESS_THAN:
      return "LESS_THAN";
    case Comparator.GREATER_THAN:
      return "GREATER_THAN";
    case Comparator.LESS_THAN_EQ:
      return "LESS_THAN_EQ";
    case Comparator.GREATER_THAN_EQ:
      return "GREATER_THAN_EQ";
    case Comparator.EQUALS:
      return "EQUALS";
    case Comparator.NOT_EQUALS:
      return "NOT_EQUALS";
    case Comparator.IN:
      return "IN";
    case Comparator.NOT_IN:
      return "NOT_IN";
    case Comparator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function comparatorToNumber(object: Comparator): number {
  switch (object) {
    case Comparator.LESS_THAN:
      return 0;
    case Comparator.GREATER_THAN:
      return 1;
    case Comparator.LESS_THAN_EQ:
      return 2;
    case Comparator.GREATER_THAN_EQ:
      return 3;
    case Comparator.EQUALS:
      return 4;
    case Comparator.NOT_EQUALS:
      return 5;
    case Comparator.IN:
      return 6;
    case Comparator.NOT_IN:
      return 7;
    case Comparator.UNRECOGNIZED:
    default:
      return -1;
  }
}

/**
 * A VariableAssignment is used within a WfSpec to determine how a value should be
 * assigned in the context of a specific WfRun. For example, in a TASK node, you
 * use a VariableAssignment for each input parameter to determine how the value
 * is set.
 *
 * Note that the VariableAssignment is normally handled by the SDK; you shouldn't
 * have to worry about this in daily LittleHorse usage.
 */
export interface VariableAssignment {
  /**
   * If you provide a `variable_name` and the specified variable is JSON_OBJ or
   * JSON_ARR type, then you may also provide a json_path which makes the VariableAssignment
   * resolve to the specified field.
   */
  jsonPath?: string | undefined;
  source?:
    | { $case: "variableName"; value: string }
    | { $case: "literalValue"; value: VariableValue }
    | { $case: "formatString"; value: VariableAssignment_FormatString }
    | { $case: "nodeOutput"; value: VariableAssignment_NodeOutputReference }
    | { $case: "expression"; value: VariableAssignment_Expression }
    | undefined;
}

/** A FormatString formats a template String with values from the WfRun. */
export interface VariableAssignment_FormatString {
  /**
   * A VariableAssignment which must resolve to a String that has format args.
   * A valid string is "This is a format string with three args: {0}, {1}, {2}"
   */
  format:
    | VariableAssignment
    | undefined;
  /** VariableAssignments which fill out the args. */
  args: VariableAssignment[];
}

/**
 * A NodeOutputReference allows you to assign a value by getting the output of
 * a NodeRun from a specified Node. If there are multiple NodeRun's of the specified
 * Node (for example, if there is a loop in the ThreadSpec), then the most recent
 * NodeRun is used. Can only specify a Node that is in the same ThreadSpec.
 */
export interface VariableAssignment_NodeOutputReference {
  /** The name of the Node to pull output from. */
  nodeName: string;
}

/** An Expression allows you to combine multiple values into one. */
export interface VariableAssignment_Expression {
  /** The left-hand-side of the expression. */
  lhs:
    | VariableAssignment
    | undefined;
  /** The operator in the expression. */
  operation: VariableMutationType;
  /** The right-hand-side of the expression. */
  rhs: VariableAssignment | undefined;
}

/**
 * A VariableMutation defines a modification made to one of a ThreadRun's variables.
 * The LHS determines the variable that is modified; the operation determines how
 * it is modified, and the RHS is the input to the operation.
 *
 * Day-to-day users of LittleHorse generally don't interact with this structure unless
 * they are writing their own WfSpec SDK.
 */
export interface VariableMutation {
  /** The name of the variable to mutate */
  lhsName: string;
  /**
   * For JSON_ARR and JSON_OBJ variables, this allows you to optionally mutate
   * a specific sub-field of the variable.
   */
  lhsJsonPath?:
    | string
    | undefined;
  /** Defines the operation that we are executing. */
  operation: VariableMutationType;
  rhsValue?: { $case: "rhsAssignment"; value: VariableAssignment } | { $case: "literalValue"; value: VariableValue } | {
    $case: "nodeOutput";
    value: VariableMutation_NodeOutputSource;
  } | undefined;
}

/** Specifies to use the output of a NodeRun as the RHS. */
export interface VariableMutation_NodeOutputSource {
  /** Use this specific field from a JSON output */
  jsonpath?: string | undefined;
}

/** Declares a Variable; used in a ThreadSpec and a TaskDef. */
export interface VariableDef {
  /**
   * DEPRECATED: The Type of the variable.
   *
   * After 0.13.2, this has been replaced by the nested `TypeDefinition` field.
   * We retain this field for compatibility purposes but clients should not use
   * it going forward. To be removed in a future release.
   */
  type?:
    | VariableType
    | undefined;
  /** The name of the variable. */
  name: string;
  /**
   * Optional default value if the variable isn't set; for example, in a ThreadRun
   * if you start a ThreadRun or WfRun without passing a variable in, then this is
   * used.
   */
  defaultValue?:
    | VariableValue
    | undefined;
  /**
   * DEPRECATED: If true, the variable value will show as a masked string.
   *
   * After 0.13.2, this has been replaced by the nested `TypeDefinition` field.
   * We retain this field for compatibility purposes but clients should not use
   * it going forward. To be removed in a future release.
   */
  maskedValue?:
    | boolean
    | undefined;
  /**
   * Type Information for this variable.
   *
   * This is the default as of 0.13.2 and will become the only supported way
   * (i.e. it will be no longer `optional`).
   */
  typeDef?: TypeDefinition | undefined;
}

/**
 * Defines the type of a value in LittleHorse. Can be used for Task Parameters,
 * Task return types, External Event types, ThreadSpec variables, etc.
 */
export interface TypeDefinition {
  definedType?:
    | { $case: "primitiveType"; value: VariableType }
    | { $case: "structDefId"; value: StructDefId }
    | { $case: "inlineArrayDef"; value: InlineArrayDef }
    | undefined;
  /** Set to true if values of this type contain sensitive information and must be masked. */
  masked: boolean;
}

/**
 * Utility used among metadata objects to define their output type. For example, used in
 * TaskDef and ExternalEventDef to represent the output.
 */
export interface ReturnType {
  /**
   * The type of the output. If it is not present, it is interpred as the output type
   * being void: the TaskRun output/ExternalEvent/WorkflowEvent is always empty / NULL.
   */
  returnType?: TypeDefinition | undefined;
}

/**
 * A UTActionTrigger triggers an action upon certain lifecycle hooks
 * in a User Task. Actions include:
 * - re-assign the User Task Run
 * - cancel the User Task Run
 * - execute a Reminder Task
 *
 * Hooks include:
 * - Upon creation of the UserTaskRun
 * - Upon rescheduling the UserTaskRun
 */
export interface UTActionTrigger {
  action?:
    | { $case: "task"; value: UTActionTrigger_UTATask }
    | { $case: "cancel"; value: UTActionTrigger_UTACancel }
    | { $case: "reassign"; value: UTActionTrigger_UTAReassign }
    | undefined;
  /**
   * The Action is triggered some time after the Hook matures. The delay is controlled
   * by this field.
   */
  delaySeconds:
    | VariableAssignment
    | undefined;
  /** The hook on which this UserTaskAction is scheduled. */
  hook: UTActionTrigger_UTHook;
}

/** Enumerates the different lifecycle hooks that can cause the timer to start running. */
export enum UTActionTrigger_UTHook {
  /**
   * ON_ARRIVAL - The hook should be scheduled `delay_seconds` after the UserTaskRun is created. This
   * hook only causes the action to be scheduled once.
   */
  ON_ARRIVAL = "ON_ARRIVAL",
  /**
   * ON_TASK_ASSIGNED - The hook should be scheduled `delay_seconds` after the ownership of the UserTaskRun
   * changes. This hook causes the Action to be scheduled one or more times. The first
   * time is scheduled when the UserTaskRun is created, since we treat the change from
   * "UserTaskRun is nonexistent" to "UserTaskRun is owned by a userId or userGroup" as
   * a change in ownership.
   */
  ON_TASK_ASSIGNED = "ON_TASK_ASSIGNED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function uTActionTrigger_UTHookFromJSON(object: any): UTActionTrigger_UTHook {
  switch (object) {
    case 0:
    case "ON_ARRIVAL":
      return UTActionTrigger_UTHook.ON_ARRIVAL;
    case 1:
    case "ON_TASK_ASSIGNED":
      return UTActionTrigger_UTHook.ON_TASK_ASSIGNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UTActionTrigger_UTHook.UNRECOGNIZED;
  }
}

export function uTActionTrigger_UTHookToJSON(object: UTActionTrigger_UTHook): string {
  switch (object) {
    case UTActionTrigger_UTHook.ON_ARRIVAL:
      return "ON_ARRIVAL";
    case UTActionTrigger_UTHook.ON_TASK_ASSIGNED:
      return "ON_TASK_ASSIGNED";
    case UTActionTrigger_UTHook.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function uTActionTrigger_UTHookToNumber(object: UTActionTrigger_UTHook): number {
  switch (object) {
    case UTActionTrigger_UTHook.ON_ARRIVAL:
      return 0;
    case UTActionTrigger_UTHook.ON_TASK_ASSIGNED:
      return 1;
    case UTActionTrigger_UTHook.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** A UserTaskAction that causes a UserTaskRun to be CANCELLED when it fires. */
export interface UTActionTrigger_UTACancel {
}

/** A UserTaskAction that causes a TaskRun to be scheduled when it fires. */
export interface UTActionTrigger_UTATask {
  /** The specification of the Task to schedule. */
  task:
    | TaskNode
    | undefined;
  /** EXPERIMENTAL: Any variables in the ThreadRun which we should mutate. */
  mutations: VariableMutation[];
}

/** A UserTaskAction that causes a UserTaskRun to be reassigned when it fires. */
export interface UTActionTrigger_UTAReassign {
  /**
   * A variable assignment that resolves to a STR representing the new user_id. If
   * not set, the user_id of the UserTaskRun will be un-set.
   */
  userId?:
    | VariableAssignment
    | undefined;
  /**
   * A variable assignment that resolves to a STR representing the new user_group. If
   * not set, the user_group of the UserTaskRun will be un-set.
   */
  userGroup?: VariableAssignment | undefined;
}

/**
 * Defines an Exponential backoff policy for TaskRun retries. The delay for a retry
 * attempt `N` is defined as:
 *
 * min(base_interval_ms * (multiplier ^(N-1)), max_delay_ms)
 *
 * Note that timers in LittleHorse have a resolution of about 500-1000 milliseconds,
 * so timing is not exact.
 */
export interface ExponentialBackoffRetryPolicy {
  /**
   * Base delay in ms for the first retry. Note that in LittleHorse, timers have a
   * resolution of 500-1000 milliseconds. Must be greater than zero.
   */
  baseIntervalMs: number;
  /** Maximum delay in milliseconds between retries. */
  maxDelayMs: number;
  /**
   * The multiplier to use in calculating the retry backoff policy. We recommend
   * starting with 2.0. Must be at least 1.0.
   */
  multiplier: number;
}

/** Defines a TaskRun execution. Used in a Node and also in the UserTask Trigger Actions. */
export interface TaskNode {
  taskToExecute?:
    | { $case: "taskDefId"; value: TaskDefId }
    | { $case: "dynamicTask"; value: VariableAssignment }
    | undefined;
  /**
   * How long until LittleHorse determines that the Task Worker had a technical ERROR if
   * the worker does not yet reply to the Server. This is determined on a per-Attempt
   * basis.
   */
  timeoutSeconds: number;
  /**
   * Configures the amount of retries allowed on this TaskNode.
   *
   * Retryable errors include:
   * - TASK_TIMEOUT: the TaskRun was started but the scheduler didn't hear back from the
   *   Task Worker in time.
   * - TASK_FAILED: the Task Worker reported an unexpected *technical* ERROR when executing
   *   the Task Function.
   *
   * Other result codes are not retryable (including TASK_OUTPUT_SERDE_ERROR,
   * TASK_INPUT_VAR_SUB_ERROR, and TASK_EXCEPTION).
   */
  retries: number;
  /** If this field is set, then retries will use Exponential Backoff. */
  exponentialBackoff?:
    | ExponentialBackoffRetryPolicy
    | undefined;
  /** Input variables into the TaskDef. */
  variables: VariableAssignment[];
}

/** An `InlineStructDef` is the actual representation of the Schema. */
export interface InlineStructDef {
  /** The fields in this schema. */
  fields: { [key: string]: StructFieldDef };
}

export interface InlineStructDef_FieldsEntry {
  key: string;
  value: StructFieldDef | undefined;
}

export interface InlineArrayDef {
  elementType: TypeDefinition | undefined;
}

/** A `SchemaFieldDef` defines a field inside a `StructDef`. */
export interface StructFieldDef {
  /** The type of the field. */
  fieldType:
    | TypeDefinition
    | undefined;
  /**
   * The default value of the field, which should match the Field Type. If not
   * provided, then the field is treated as required.
   */
  defaultValue?: VariableValue | undefined;
}

function createBaseVariableAssignment(): VariableAssignment {
  return { jsonPath: undefined, source: undefined };
}

export const VariableAssignment = {
  encode(message: VariableAssignment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.jsonPath !== undefined) {
      writer.uint32(10).string(message.jsonPath);
    }
    switch (message.source?.$case) {
      case "variableName":
        writer.uint32(18).string(message.source.value);
        break;
      case "literalValue":
        VariableValue.encode(message.source.value, writer.uint32(26).fork()).ldelim();
        break;
      case "formatString":
        VariableAssignment_FormatString.encode(message.source.value, writer.uint32(34).fork()).ldelim();
        break;
      case "nodeOutput":
        VariableAssignment_NodeOutputReference.encode(message.source.value, writer.uint32(42).fork()).ldelim();
        break;
      case "expression":
        VariableAssignment_Expression.encode(message.source.value, writer.uint32(50).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VariableAssignment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariableAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jsonPath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = { $case: "variableName", value: reader.string() };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.source = { $case: "literalValue", value: VariableValue.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.source = {
            $case: "formatString",
            value: VariableAssignment_FormatString.decode(reader, reader.uint32()),
          };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.source = {
            $case: "nodeOutput",
            value: VariableAssignment_NodeOutputReference.decode(reader, reader.uint32()),
          };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.source = {
            $case: "expression",
            value: VariableAssignment_Expression.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariableAssignment {
    return {
      jsonPath: isSet(object.jsonPath) ? globalThis.String(object.jsonPath) : undefined,
      source: isSet(object.variableName)
        ? { $case: "variableName", value: globalThis.String(object.variableName) }
        : isSet(object.literalValue)
        ? { $case: "literalValue", value: VariableValue.fromJSON(object.literalValue) }
        : isSet(object.formatString)
        ? { $case: "formatString", value: VariableAssignment_FormatString.fromJSON(object.formatString) }
        : isSet(object.nodeOutput)
        ? { $case: "nodeOutput", value: VariableAssignment_NodeOutputReference.fromJSON(object.nodeOutput) }
        : isSet(object.expression)
        ? { $case: "expression", value: VariableAssignment_Expression.fromJSON(object.expression) }
        : undefined,
    };
  },

  toJSON(message: VariableAssignment): unknown {
    const obj: any = {};
    if (message.jsonPath !== undefined) {
      obj.jsonPath = message.jsonPath;
    }
    if (message.source?.$case === "variableName") {
      obj.variableName = message.source.value;
    }
    if (message.source?.$case === "literalValue") {
      obj.literalValue = VariableValue.toJSON(message.source.value);
    }
    if (message.source?.$case === "formatString") {
      obj.formatString = VariableAssignment_FormatString.toJSON(message.source.value);
    }
    if (message.source?.$case === "nodeOutput") {
      obj.nodeOutput = VariableAssignment_NodeOutputReference.toJSON(message.source.value);
    }
    if (message.source?.$case === "expression") {
      obj.expression = VariableAssignment_Expression.toJSON(message.source.value);
    }
    return obj;
  },

  create(base?: DeepPartial<VariableAssignment>): VariableAssignment {
    return VariableAssignment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariableAssignment>): VariableAssignment {
    const message = createBaseVariableAssignment();
    message.jsonPath = object.jsonPath ?? undefined;
    if (
      object.source?.$case === "variableName" && object.source?.value !== undefined && object.source?.value !== null
    ) {
      message.source = { $case: "variableName", value: object.source.value };
    }
    if (
      object.source?.$case === "literalValue" && object.source?.value !== undefined && object.source?.value !== null
    ) {
      message.source = { $case: "literalValue", value: VariableValue.fromPartial(object.source.value) };
    }
    if (
      object.source?.$case === "formatString" && object.source?.value !== undefined && object.source?.value !== null
    ) {
      message.source = {
        $case: "formatString",
        value: VariableAssignment_FormatString.fromPartial(object.source.value),
      };
    }
    if (object.source?.$case === "nodeOutput" && object.source?.value !== undefined && object.source?.value !== null) {
      message.source = {
        $case: "nodeOutput",
        value: VariableAssignment_NodeOutputReference.fromPartial(object.source.value),
      };
    }
    if (object.source?.$case === "expression" && object.source?.value !== undefined && object.source?.value !== null) {
      message.source = { $case: "expression", value: VariableAssignment_Expression.fromPartial(object.source.value) };
    }
    return message;
  },
};

function createBaseVariableAssignment_FormatString(): VariableAssignment_FormatString {
  return { format: undefined, args: [] };
}

export const VariableAssignment_FormatString = {
  encode(message: VariableAssignment_FormatString, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.format !== undefined) {
      VariableAssignment.encode(message.format, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.args) {
      VariableAssignment.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VariableAssignment_FormatString {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariableAssignment_FormatString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.format = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.args.push(VariableAssignment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariableAssignment_FormatString {
    return {
      format: isSet(object.format) ? VariableAssignment.fromJSON(object.format) : undefined,
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => VariableAssignment.fromJSON(e)) : [],
    };
  },

  toJSON(message: VariableAssignment_FormatString): unknown {
    const obj: any = {};
    if (message.format !== undefined) {
      obj.format = VariableAssignment.toJSON(message.format);
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => VariableAssignment.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VariableAssignment_FormatString>): VariableAssignment_FormatString {
    return VariableAssignment_FormatString.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariableAssignment_FormatString>): VariableAssignment_FormatString {
    const message = createBaseVariableAssignment_FormatString();
    message.format = (object.format !== undefined && object.format !== null)
      ? VariableAssignment.fromPartial(object.format)
      : undefined;
    message.args = object.args?.map((e) => VariableAssignment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVariableAssignment_NodeOutputReference(): VariableAssignment_NodeOutputReference {
  return { nodeName: "" };
}

export const VariableAssignment_NodeOutputReference = {
  encode(message: VariableAssignment_NodeOutputReference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeName !== "") {
      writer.uint32(10).string(message.nodeName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VariableAssignment_NodeOutputReference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariableAssignment_NodeOutputReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariableAssignment_NodeOutputReference {
    return { nodeName: isSet(object.nodeName) ? globalThis.String(object.nodeName) : "" };
  },

  toJSON(message: VariableAssignment_NodeOutputReference): unknown {
    const obj: any = {};
    if (message.nodeName !== "") {
      obj.nodeName = message.nodeName;
    }
    return obj;
  },

  create(base?: DeepPartial<VariableAssignment_NodeOutputReference>): VariableAssignment_NodeOutputReference {
    return VariableAssignment_NodeOutputReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariableAssignment_NodeOutputReference>): VariableAssignment_NodeOutputReference {
    const message = createBaseVariableAssignment_NodeOutputReference();
    message.nodeName = object.nodeName ?? "";
    return message;
  },
};

function createBaseVariableAssignment_Expression(): VariableAssignment_Expression {
  return { lhs: undefined, operation: VariableMutationType.ASSIGN, rhs: undefined };
}

export const VariableAssignment_Expression = {
  encode(message: VariableAssignment_Expression, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lhs !== undefined) {
      VariableAssignment.encode(message.lhs, writer.uint32(10).fork()).ldelim();
    }
    if (message.operation !== VariableMutationType.ASSIGN) {
      writer.uint32(16).int32(variableMutationTypeToNumber(message.operation));
    }
    if (message.rhs !== undefined) {
      VariableAssignment.encode(message.rhs, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VariableAssignment_Expression {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariableAssignment_Expression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lhs = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.operation = variableMutationTypeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rhs = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariableAssignment_Expression {
    return {
      lhs: isSet(object.lhs) ? VariableAssignment.fromJSON(object.lhs) : undefined,
      operation: isSet(object.operation) ? variableMutationTypeFromJSON(object.operation) : VariableMutationType.ASSIGN,
      rhs: isSet(object.rhs) ? VariableAssignment.fromJSON(object.rhs) : undefined,
    };
  },

  toJSON(message: VariableAssignment_Expression): unknown {
    const obj: any = {};
    if (message.lhs !== undefined) {
      obj.lhs = VariableAssignment.toJSON(message.lhs);
    }
    if (message.operation !== VariableMutationType.ASSIGN) {
      obj.operation = variableMutationTypeToJSON(message.operation);
    }
    if (message.rhs !== undefined) {
      obj.rhs = VariableAssignment.toJSON(message.rhs);
    }
    return obj;
  },

  create(base?: DeepPartial<VariableAssignment_Expression>): VariableAssignment_Expression {
    return VariableAssignment_Expression.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariableAssignment_Expression>): VariableAssignment_Expression {
    const message = createBaseVariableAssignment_Expression();
    message.lhs = (object.lhs !== undefined && object.lhs !== null)
      ? VariableAssignment.fromPartial(object.lhs)
      : undefined;
    message.operation = object.operation ?? VariableMutationType.ASSIGN;
    message.rhs = (object.rhs !== undefined && object.rhs !== null)
      ? VariableAssignment.fromPartial(object.rhs)
      : undefined;
    return message;
  },
};

function createBaseVariableMutation(): VariableMutation {
  return { lhsName: "", lhsJsonPath: undefined, operation: VariableMutationType.ASSIGN, rhsValue: undefined };
}

export const VariableMutation = {
  encode(message: VariableMutation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lhsName !== "") {
      writer.uint32(10).string(message.lhsName);
    }
    if (message.lhsJsonPath !== undefined) {
      writer.uint32(18).string(message.lhsJsonPath);
    }
    if (message.operation !== VariableMutationType.ASSIGN) {
      writer.uint32(24).int32(variableMutationTypeToNumber(message.operation));
    }
    switch (message.rhsValue?.$case) {
      case "rhsAssignment":
        VariableAssignment.encode(message.rhsValue.value, writer.uint32(34).fork()).ldelim();
        break;
      case "literalValue":
        VariableValue.encode(message.rhsValue.value, writer.uint32(42).fork()).ldelim();
        break;
      case "nodeOutput":
        VariableMutation_NodeOutputSource.encode(message.rhsValue.value, writer.uint32(50).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VariableMutation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariableMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lhsName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lhsJsonPath = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.operation = variableMutationTypeFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rhsValue = { $case: "rhsAssignment", value: VariableAssignment.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rhsValue = { $case: "literalValue", value: VariableValue.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rhsValue = {
            $case: "nodeOutput",
            value: VariableMutation_NodeOutputSource.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariableMutation {
    return {
      lhsName: isSet(object.lhsName) ? globalThis.String(object.lhsName) : "",
      lhsJsonPath: isSet(object.lhsJsonPath) ? globalThis.String(object.lhsJsonPath) : undefined,
      operation: isSet(object.operation) ? variableMutationTypeFromJSON(object.operation) : VariableMutationType.ASSIGN,
      rhsValue: isSet(object.rhsAssignment)
        ? { $case: "rhsAssignment", value: VariableAssignment.fromJSON(object.rhsAssignment) }
        : isSet(object.literalValue)
        ? { $case: "literalValue", value: VariableValue.fromJSON(object.literalValue) }
        : isSet(object.nodeOutput)
        ? { $case: "nodeOutput", value: VariableMutation_NodeOutputSource.fromJSON(object.nodeOutput) }
        : undefined,
    };
  },

  toJSON(message: VariableMutation): unknown {
    const obj: any = {};
    if (message.lhsName !== "") {
      obj.lhsName = message.lhsName;
    }
    if (message.lhsJsonPath !== undefined) {
      obj.lhsJsonPath = message.lhsJsonPath;
    }
    if (message.operation !== VariableMutationType.ASSIGN) {
      obj.operation = variableMutationTypeToJSON(message.operation);
    }
    if (message.rhsValue?.$case === "rhsAssignment") {
      obj.rhsAssignment = VariableAssignment.toJSON(message.rhsValue.value);
    }
    if (message.rhsValue?.$case === "literalValue") {
      obj.literalValue = VariableValue.toJSON(message.rhsValue.value);
    }
    if (message.rhsValue?.$case === "nodeOutput") {
      obj.nodeOutput = VariableMutation_NodeOutputSource.toJSON(message.rhsValue.value);
    }
    return obj;
  },

  create(base?: DeepPartial<VariableMutation>): VariableMutation {
    return VariableMutation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariableMutation>): VariableMutation {
    const message = createBaseVariableMutation();
    message.lhsName = object.lhsName ?? "";
    message.lhsJsonPath = object.lhsJsonPath ?? undefined;
    message.operation = object.operation ?? VariableMutationType.ASSIGN;
    if (
      object.rhsValue?.$case === "rhsAssignment" &&
      object.rhsValue?.value !== undefined &&
      object.rhsValue?.value !== null
    ) {
      message.rhsValue = { $case: "rhsAssignment", value: VariableAssignment.fromPartial(object.rhsValue.value) };
    }
    if (
      object.rhsValue?.$case === "literalValue" &&
      object.rhsValue?.value !== undefined &&
      object.rhsValue?.value !== null
    ) {
      message.rhsValue = { $case: "literalValue", value: VariableValue.fromPartial(object.rhsValue.value) };
    }
    if (
      object.rhsValue?.$case === "nodeOutput" && object.rhsValue?.value !== undefined && object.rhsValue?.value !== null
    ) {
      message.rhsValue = {
        $case: "nodeOutput",
        value: VariableMutation_NodeOutputSource.fromPartial(object.rhsValue.value),
      };
    }
    return message;
  },
};

function createBaseVariableMutation_NodeOutputSource(): VariableMutation_NodeOutputSource {
  return { jsonpath: undefined };
}

export const VariableMutation_NodeOutputSource = {
  encode(message: VariableMutation_NodeOutputSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.jsonpath !== undefined) {
      writer.uint32(82).string(message.jsonpath);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VariableMutation_NodeOutputSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariableMutation_NodeOutputSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10:
          if (tag !== 82) {
            break;
          }

          message.jsonpath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariableMutation_NodeOutputSource {
    return { jsonpath: isSet(object.jsonpath) ? globalThis.String(object.jsonpath) : undefined };
  },

  toJSON(message: VariableMutation_NodeOutputSource): unknown {
    const obj: any = {};
    if (message.jsonpath !== undefined) {
      obj.jsonpath = message.jsonpath;
    }
    return obj;
  },

  create(base?: DeepPartial<VariableMutation_NodeOutputSource>): VariableMutation_NodeOutputSource {
    return VariableMutation_NodeOutputSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariableMutation_NodeOutputSource>): VariableMutation_NodeOutputSource {
    const message = createBaseVariableMutation_NodeOutputSource();
    message.jsonpath = object.jsonpath ?? undefined;
    return message;
  },
};

function createBaseVariableDef(): VariableDef {
  return { type: undefined, name: "", defaultValue: undefined, maskedValue: undefined, typeDef: undefined };
}

export const VariableDef = {
  encode(message: VariableDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== undefined) {
      writer.uint32(8).int32(variableTypeToNumber(message.type));
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.defaultValue !== undefined) {
      VariableValue.encode(message.defaultValue, writer.uint32(26).fork()).ldelim();
    }
    if (message.maskedValue !== undefined) {
      writer.uint32(32).bool(message.maskedValue);
    }
    if (message.typeDef !== undefined) {
      TypeDefinition.encode(message.typeDef, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VariableDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariableDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = variableTypeFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.defaultValue = VariableValue.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maskedValue = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.typeDef = TypeDefinition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariableDef {
    return {
      type: isSet(object.type) ? variableTypeFromJSON(object.type) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      defaultValue: isSet(object.defaultValue) ? VariableValue.fromJSON(object.defaultValue) : undefined,
      maskedValue: isSet(object.maskedValue) ? globalThis.Boolean(object.maskedValue) : undefined,
      typeDef: isSet(object.typeDef) ? TypeDefinition.fromJSON(object.typeDef) : undefined,
    };
  },

  toJSON(message: VariableDef): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = variableTypeToJSON(message.type);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = VariableValue.toJSON(message.defaultValue);
    }
    if (message.maskedValue !== undefined) {
      obj.maskedValue = message.maskedValue;
    }
    if (message.typeDef !== undefined) {
      obj.typeDef = TypeDefinition.toJSON(message.typeDef);
    }
    return obj;
  },

  create(base?: DeepPartial<VariableDef>): VariableDef {
    return VariableDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariableDef>): VariableDef {
    const message = createBaseVariableDef();
    message.type = object.type ?? undefined;
    message.name = object.name ?? "";
    message.defaultValue = (object.defaultValue !== undefined && object.defaultValue !== null)
      ? VariableValue.fromPartial(object.defaultValue)
      : undefined;
    message.maskedValue = object.maskedValue ?? undefined;
    message.typeDef = (object.typeDef !== undefined && object.typeDef !== null)
      ? TypeDefinition.fromPartial(object.typeDef)
      : undefined;
    return message;
  },
};

function createBaseTypeDefinition(): TypeDefinition {
  return { definedType: undefined, masked: false };
}

export const TypeDefinition = {
  encode(message: TypeDefinition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.definedType?.$case) {
      case "primitiveType":
        writer.uint32(8).int32(variableTypeToNumber(message.definedType.value));
        break;
      case "structDefId":
        StructDefId.encode(message.definedType.value, writer.uint32(42).fork()).ldelim();
        break;
      case "inlineArrayDef":
        InlineArrayDef.encode(message.definedType.value, writer.uint32(50).fork()).ldelim();
        break;
    }
    if (message.masked !== false) {
      writer.uint32(32).bool(message.masked);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TypeDefinition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypeDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.definedType = { $case: "primitiveType", value: variableTypeFromJSON(reader.int32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.definedType = { $case: "structDefId", value: StructDefId.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.definedType = { $case: "inlineArrayDef", value: InlineArrayDef.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.masked = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypeDefinition {
    return {
      definedType: isSet(object.primitiveType)
        ? { $case: "primitiveType", value: variableTypeFromJSON(object.primitiveType) }
        : isSet(object.structDefId)
        ? { $case: "structDefId", value: StructDefId.fromJSON(object.structDefId) }
        : isSet(object.inlineArrayDef)
        ? { $case: "inlineArrayDef", value: InlineArrayDef.fromJSON(object.inlineArrayDef) }
        : undefined,
      masked: isSet(object.masked) ? globalThis.Boolean(object.masked) : false,
    };
  },

  toJSON(message: TypeDefinition): unknown {
    const obj: any = {};
    if (message.definedType?.$case === "primitiveType") {
      obj.primitiveType = variableTypeToJSON(message.definedType.value);
    }
    if (message.definedType?.$case === "structDefId") {
      obj.structDefId = StructDefId.toJSON(message.definedType.value);
    }
    if (message.definedType?.$case === "inlineArrayDef") {
      obj.inlineArrayDef = InlineArrayDef.toJSON(message.definedType.value);
    }
    if (message.masked !== false) {
      obj.masked = message.masked;
    }
    return obj;
  },

  create(base?: DeepPartial<TypeDefinition>): TypeDefinition {
    return TypeDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TypeDefinition>): TypeDefinition {
    const message = createBaseTypeDefinition();
    if (
      object.definedType?.$case === "primitiveType" &&
      object.definedType?.value !== undefined &&
      object.definedType?.value !== null
    ) {
      message.definedType = { $case: "primitiveType", value: object.definedType.value };
    }
    if (
      object.definedType?.$case === "structDefId" &&
      object.definedType?.value !== undefined &&
      object.definedType?.value !== null
    ) {
      message.definedType = { $case: "structDefId", value: StructDefId.fromPartial(object.definedType.value) };
    }
    if (
      object.definedType?.$case === "inlineArrayDef" &&
      object.definedType?.value !== undefined &&
      object.definedType?.value !== null
    ) {
      message.definedType = { $case: "inlineArrayDef", value: InlineArrayDef.fromPartial(object.definedType.value) };
    }
    message.masked = object.masked ?? false;
    return message;
  },
};

function createBaseReturnType(): ReturnType {
  return { returnType: undefined };
}

export const ReturnType = {
  encode(message: ReturnType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.returnType !== undefined) {
      TypeDefinition.encode(message.returnType, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReturnType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReturnType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.returnType = TypeDefinition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReturnType {
    return { returnType: isSet(object.returnType) ? TypeDefinition.fromJSON(object.returnType) : undefined };
  },

  toJSON(message: ReturnType): unknown {
    const obj: any = {};
    if (message.returnType !== undefined) {
      obj.returnType = TypeDefinition.toJSON(message.returnType);
    }
    return obj;
  },

  create(base?: DeepPartial<ReturnType>): ReturnType {
    return ReturnType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReturnType>): ReturnType {
    const message = createBaseReturnType();
    message.returnType = (object.returnType !== undefined && object.returnType !== null)
      ? TypeDefinition.fromPartial(object.returnType)
      : undefined;
    return message;
  },
};

function createBaseUTActionTrigger(): UTActionTrigger {
  return { action: undefined, delaySeconds: undefined, hook: UTActionTrigger_UTHook.ON_ARRIVAL };
}

export const UTActionTrigger = {
  encode(message: UTActionTrigger, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.action?.$case) {
      case "task":
        UTActionTrigger_UTATask.encode(message.action.value, writer.uint32(10).fork()).ldelim();
        break;
      case "cancel":
        UTActionTrigger_UTACancel.encode(message.action.value, writer.uint32(18).fork()).ldelim();
        break;
      case "reassign":
        UTActionTrigger_UTAReassign.encode(message.action.value, writer.uint32(26).fork()).ldelim();
        break;
    }
    if (message.delaySeconds !== undefined) {
      VariableAssignment.encode(message.delaySeconds, writer.uint32(42).fork()).ldelim();
    }
    if (message.hook !== UTActionTrigger_UTHook.ON_ARRIVAL) {
      writer.uint32(48).int32(uTActionTrigger_UTHookToNumber(message.hook));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UTActionTrigger {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTActionTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.action = { $case: "task", value: UTActionTrigger_UTATask.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.action = { $case: "cancel", value: UTActionTrigger_UTACancel.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.action = { $case: "reassign", value: UTActionTrigger_UTAReassign.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.delaySeconds = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.hook = uTActionTrigger_UTHookFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UTActionTrigger {
    return {
      action: isSet(object.task)
        ? { $case: "task", value: UTActionTrigger_UTATask.fromJSON(object.task) }
        : isSet(object.cancel)
        ? { $case: "cancel", value: UTActionTrigger_UTACancel.fromJSON(object.cancel) }
        : isSet(object.reassign)
        ? { $case: "reassign", value: UTActionTrigger_UTAReassign.fromJSON(object.reassign) }
        : undefined,
      delaySeconds: isSet(object.delaySeconds) ? VariableAssignment.fromJSON(object.delaySeconds) : undefined,
      hook: isSet(object.hook) ? uTActionTrigger_UTHookFromJSON(object.hook) : UTActionTrigger_UTHook.ON_ARRIVAL,
    };
  },

  toJSON(message: UTActionTrigger): unknown {
    const obj: any = {};
    if (message.action?.$case === "task") {
      obj.task = UTActionTrigger_UTATask.toJSON(message.action.value);
    }
    if (message.action?.$case === "cancel") {
      obj.cancel = UTActionTrigger_UTACancel.toJSON(message.action.value);
    }
    if (message.action?.$case === "reassign") {
      obj.reassign = UTActionTrigger_UTAReassign.toJSON(message.action.value);
    }
    if (message.delaySeconds !== undefined) {
      obj.delaySeconds = VariableAssignment.toJSON(message.delaySeconds);
    }
    if (message.hook !== UTActionTrigger_UTHook.ON_ARRIVAL) {
      obj.hook = uTActionTrigger_UTHookToJSON(message.hook);
    }
    return obj;
  },

  create(base?: DeepPartial<UTActionTrigger>): UTActionTrigger {
    return UTActionTrigger.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UTActionTrigger>): UTActionTrigger {
    const message = createBaseUTActionTrigger();
    if (object.action?.$case === "task" && object.action?.value !== undefined && object.action?.value !== null) {
      message.action = { $case: "task", value: UTActionTrigger_UTATask.fromPartial(object.action.value) };
    }
    if (object.action?.$case === "cancel" && object.action?.value !== undefined && object.action?.value !== null) {
      message.action = { $case: "cancel", value: UTActionTrigger_UTACancel.fromPartial(object.action.value) };
    }
    if (object.action?.$case === "reassign" && object.action?.value !== undefined && object.action?.value !== null) {
      message.action = { $case: "reassign", value: UTActionTrigger_UTAReassign.fromPartial(object.action.value) };
    }
    message.delaySeconds = (object.delaySeconds !== undefined && object.delaySeconds !== null)
      ? VariableAssignment.fromPartial(object.delaySeconds)
      : undefined;
    message.hook = object.hook ?? UTActionTrigger_UTHook.ON_ARRIVAL;
    return message;
  },
};

function createBaseUTActionTrigger_UTACancel(): UTActionTrigger_UTACancel {
  return {};
}

export const UTActionTrigger_UTACancel = {
  encode(_: UTActionTrigger_UTACancel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UTActionTrigger_UTACancel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTActionTrigger_UTACancel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UTActionTrigger_UTACancel {
    return {};
  },

  toJSON(_: UTActionTrigger_UTACancel): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UTActionTrigger_UTACancel>): UTActionTrigger_UTACancel {
    return UTActionTrigger_UTACancel.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UTActionTrigger_UTACancel>): UTActionTrigger_UTACancel {
    const message = createBaseUTActionTrigger_UTACancel();
    return message;
  },
};

function createBaseUTActionTrigger_UTATask(): UTActionTrigger_UTATask {
  return { task: undefined, mutations: [] };
}

export const UTActionTrigger_UTATask = {
  encode(message: UTActionTrigger_UTATask, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.task !== undefined) {
      TaskNode.encode(message.task, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.mutations) {
      VariableMutation.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UTActionTrigger_UTATask {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTActionTrigger_UTATask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.task = TaskNode.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mutations.push(VariableMutation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UTActionTrigger_UTATask {
    return {
      task: isSet(object.task) ? TaskNode.fromJSON(object.task) : undefined,
      mutations: globalThis.Array.isArray(object?.mutations)
        ? object.mutations.map((e: any) => VariableMutation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UTActionTrigger_UTATask): unknown {
    const obj: any = {};
    if (message.task !== undefined) {
      obj.task = TaskNode.toJSON(message.task);
    }
    if (message.mutations?.length) {
      obj.mutations = message.mutations.map((e) => VariableMutation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UTActionTrigger_UTATask>): UTActionTrigger_UTATask {
    return UTActionTrigger_UTATask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UTActionTrigger_UTATask>): UTActionTrigger_UTATask {
    const message = createBaseUTActionTrigger_UTATask();
    message.task = (object.task !== undefined && object.task !== null) ? TaskNode.fromPartial(object.task) : undefined;
    message.mutations = object.mutations?.map((e) => VariableMutation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUTActionTrigger_UTAReassign(): UTActionTrigger_UTAReassign {
  return { userId: undefined, userGroup: undefined };
}

export const UTActionTrigger_UTAReassign = {
  encode(message: UTActionTrigger_UTAReassign, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== undefined) {
      VariableAssignment.encode(message.userId, writer.uint32(10).fork()).ldelim();
    }
    if (message.userGroup !== undefined) {
      VariableAssignment.encode(message.userGroup, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UTActionTrigger_UTAReassign {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTActionTrigger_UTAReassign();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userGroup = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UTActionTrigger_UTAReassign {
    return {
      userId: isSet(object.userId) ? VariableAssignment.fromJSON(object.userId) : undefined,
      userGroup: isSet(object.userGroup) ? VariableAssignment.fromJSON(object.userGroup) : undefined,
    };
  },

  toJSON(message: UTActionTrigger_UTAReassign): unknown {
    const obj: any = {};
    if (message.userId !== undefined) {
      obj.userId = VariableAssignment.toJSON(message.userId);
    }
    if (message.userGroup !== undefined) {
      obj.userGroup = VariableAssignment.toJSON(message.userGroup);
    }
    return obj;
  },

  create(base?: DeepPartial<UTActionTrigger_UTAReassign>): UTActionTrigger_UTAReassign {
    return UTActionTrigger_UTAReassign.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UTActionTrigger_UTAReassign>): UTActionTrigger_UTAReassign {
    const message = createBaseUTActionTrigger_UTAReassign();
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? VariableAssignment.fromPartial(object.userId)
      : undefined;
    message.userGroup = (object.userGroup !== undefined && object.userGroup !== null)
      ? VariableAssignment.fromPartial(object.userGroup)
      : undefined;
    return message;
  },
};

function createBaseExponentialBackoffRetryPolicy(): ExponentialBackoffRetryPolicy {
  return { baseIntervalMs: 0, maxDelayMs: 0, multiplier: 0 };
}

export const ExponentialBackoffRetryPolicy = {
  encode(message: ExponentialBackoffRetryPolicy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseIntervalMs !== 0) {
      writer.uint32(8).int32(message.baseIntervalMs);
    }
    if (message.maxDelayMs !== 0) {
      writer.uint32(16).int64(message.maxDelayMs);
    }
    if (message.multiplier !== 0) {
      writer.uint32(29).float(message.multiplier);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExponentialBackoffRetryPolicy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExponentialBackoffRetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.baseIntervalMs = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxDelayMs = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.multiplier = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExponentialBackoffRetryPolicy {
    return {
      baseIntervalMs: isSet(object.baseIntervalMs) ? globalThis.Number(object.baseIntervalMs) : 0,
      maxDelayMs: isSet(object.maxDelayMs) ? globalThis.Number(object.maxDelayMs) : 0,
      multiplier: isSet(object.multiplier) ? globalThis.Number(object.multiplier) : 0,
    };
  },

  toJSON(message: ExponentialBackoffRetryPolicy): unknown {
    const obj: any = {};
    if (message.baseIntervalMs !== 0) {
      obj.baseIntervalMs = Math.round(message.baseIntervalMs);
    }
    if (message.maxDelayMs !== 0) {
      obj.maxDelayMs = Math.round(message.maxDelayMs);
    }
    if (message.multiplier !== 0) {
      obj.multiplier = message.multiplier;
    }
    return obj;
  },

  create(base?: DeepPartial<ExponentialBackoffRetryPolicy>): ExponentialBackoffRetryPolicy {
    return ExponentialBackoffRetryPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExponentialBackoffRetryPolicy>): ExponentialBackoffRetryPolicy {
    const message = createBaseExponentialBackoffRetryPolicy();
    message.baseIntervalMs = object.baseIntervalMs ?? 0;
    message.maxDelayMs = object.maxDelayMs ?? 0;
    message.multiplier = object.multiplier ?? 0;
    return message;
  },
};

function createBaseTaskNode(): TaskNode {
  return { taskToExecute: undefined, timeoutSeconds: 0, retries: 0, exponentialBackoff: undefined, variables: [] };
}

export const TaskNode = {
  encode(message: TaskNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.taskToExecute?.$case) {
      case "taskDefId":
        TaskDefId.encode(message.taskToExecute.value, writer.uint32(10).fork()).ldelim();
        break;
      case "dynamicTask":
        VariableAssignment.encode(message.taskToExecute.value, writer.uint32(50).fork()).ldelim();
        break;
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(16).int32(message.timeoutSeconds);
    }
    if (message.retries !== 0) {
      writer.uint32(24).int32(message.retries);
    }
    if (message.exponentialBackoff !== undefined) {
      ExponentialBackoffRetryPolicy.encode(message.exponentialBackoff, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.variables) {
      VariableAssignment.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskToExecute = { $case: "taskDefId", value: TaskDefId.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.taskToExecute = { $case: "dynamicTask", value: VariableAssignment.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeoutSeconds = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.retries = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.exponentialBackoff = ExponentialBackoffRetryPolicy.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.variables.push(VariableAssignment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskNode {
    return {
      taskToExecute: isSet(object.taskDefId)
        ? { $case: "taskDefId", value: TaskDefId.fromJSON(object.taskDefId) }
        : isSet(object.dynamicTask)
        ? { $case: "dynamicTask", value: VariableAssignment.fromJSON(object.dynamicTask) }
        : undefined,
      timeoutSeconds: isSet(object.timeoutSeconds) ? globalThis.Number(object.timeoutSeconds) : 0,
      retries: isSet(object.retries) ? globalThis.Number(object.retries) : 0,
      exponentialBackoff: isSet(object.exponentialBackoff)
        ? ExponentialBackoffRetryPolicy.fromJSON(object.exponentialBackoff)
        : undefined,
      variables: globalThis.Array.isArray(object?.variables)
        ? object.variables.map((e: any) => VariableAssignment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TaskNode): unknown {
    const obj: any = {};
    if (message.taskToExecute?.$case === "taskDefId") {
      obj.taskDefId = TaskDefId.toJSON(message.taskToExecute.value);
    }
    if (message.taskToExecute?.$case === "dynamicTask") {
      obj.dynamicTask = VariableAssignment.toJSON(message.taskToExecute.value);
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    if (message.retries !== 0) {
      obj.retries = Math.round(message.retries);
    }
    if (message.exponentialBackoff !== undefined) {
      obj.exponentialBackoff = ExponentialBackoffRetryPolicy.toJSON(message.exponentialBackoff);
    }
    if (message.variables?.length) {
      obj.variables = message.variables.map((e) => VariableAssignment.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TaskNode>): TaskNode {
    return TaskNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskNode>): TaskNode {
    const message = createBaseTaskNode();
    if (
      object.taskToExecute?.$case === "taskDefId" &&
      object.taskToExecute?.value !== undefined &&
      object.taskToExecute?.value !== null
    ) {
      message.taskToExecute = { $case: "taskDefId", value: TaskDefId.fromPartial(object.taskToExecute.value) };
    }
    if (
      object.taskToExecute?.$case === "dynamicTask" &&
      object.taskToExecute?.value !== undefined &&
      object.taskToExecute?.value !== null
    ) {
      message.taskToExecute = {
        $case: "dynamicTask",
        value: VariableAssignment.fromPartial(object.taskToExecute.value),
      };
    }
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    message.retries = object.retries ?? 0;
    message.exponentialBackoff = (object.exponentialBackoff !== undefined && object.exponentialBackoff !== null)
      ? ExponentialBackoffRetryPolicy.fromPartial(object.exponentialBackoff)
      : undefined;
    message.variables = object.variables?.map((e) => VariableAssignment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInlineStructDef(): InlineStructDef {
  return { fields: {} };
}

export const InlineStructDef = {
  encode(message: InlineStructDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.fields).forEach(([key, value]) => {
      InlineStructDef_FieldsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InlineStructDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInlineStructDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = InlineStructDef_FieldsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.fields[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InlineStructDef {
    return {
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: StructFieldDef }>((acc, [key, value]) => {
          acc[key] = StructFieldDef.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: InlineStructDef): unknown {
    const obj: any = {};
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = StructFieldDef.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<InlineStructDef>): InlineStructDef {
    return InlineStructDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InlineStructDef>): InlineStructDef {
    const message = createBaseInlineStructDef();
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: StructFieldDef }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = StructFieldDef.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseInlineStructDef_FieldsEntry(): InlineStructDef_FieldsEntry {
  return { key: "", value: undefined };
}

export const InlineStructDef_FieldsEntry = {
  encode(message: InlineStructDef_FieldsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      StructFieldDef.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InlineStructDef_FieldsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInlineStructDef_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = StructFieldDef.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InlineStructDef_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? StructFieldDef.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: InlineStructDef_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = StructFieldDef.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<InlineStructDef_FieldsEntry>): InlineStructDef_FieldsEntry {
    return InlineStructDef_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InlineStructDef_FieldsEntry>): InlineStructDef_FieldsEntry {
    const message = createBaseInlineStructDef_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? StructFieldDef.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseInlineArrayDef(): InlineArrayDef {
  return { elementType: undefined };
}

export const InlineArrayDef = {
  encode(message: InlineArrayDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.elementType !== undefined) {
      TypeDefinition.encode(message.elementType, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InlineArrayDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInlineArrayDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.elementType = TypeDefinition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InlineArrayDef {
    return { elementType: isSet(object.elementType) ? TypeDefinition.fromJSON(object.elementType) : undefined };
  },

  toJSON(message: InlineArrayDef): unknown {
    const obj: any = {};
    if (message.elementType !== undefined) {
      obj.elementType = TypeDefinition.toJSON(message.elementType);
    }
    return obj;
  },

  create(base?: DeepPartial<InlineArrayDef>): InlineArrayDef {
    return InlineArrayDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InlineArrayDef>): InlineArrayDef {
    const message = createBaseInlineArrayDef();
    message.elementType = (object.elementType !== undefined && object.elementType !== null)
      ? TypeDefinition.fromPartial(object.elementType)
      : undefined;
    return message;
  },
};

function createBaseStructFieldDef(): StructFieldDef {
  return { fieldType: undefined, defaultValue: undefined };
}

export const StructFieldDef = {
  encode(message: StructFieldDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fieldType !== undefined) {
      TypeDefinition.encode(message.fieldType, writer.uint32(10).fork()).ldelim();
    }
    if (message.defaultValue !== undefined) {
      VariableValue.encode(message.defaultValue, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StructFieldDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructFieldDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldType = TypeDefinition.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.defaultValue = VariableValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructFieldDef {
    return {
      fieldType: isSet(object.fieldType) ? TypeDefinition.fromJSON(object.fieldType) : undefined,
      defaultValue: isSet(object.defaultValue) ? VariableValue.fromJSON(object.defaultValue) : undefined,
    };
  },

  toJSON(message: StructFieldDef): unknown {
    const obj: any = {};
    if (message.fieldType !== undefined) {
      obj.fieldType = TypeDefinition.toJSON(message.fieldType);
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = VariableValue.toJSON(message.defaultValue);
    }
    return obj;
  },

  create(base?: DeepPartial<StructFieldDef>): StructFieldDef {
    return StructFieldDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructFieldDef>): StructFieldDef {
    const message = createBaseStructFieldDef();
    message.fieldType = (object.fieldType !== undefined && object.fieldType !== null)
      ? TypeDefinition.fromPartial(object.fieldType)
      : undefined;
    message.defaultValue = (object.defaultValue !== undefined && object.defaultValue !== null)
      ? VariableValue.fromPartial(object.defaultValue)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
