// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v6.30.1
// source: service.proto

/* eslint-disable */
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import _m0 from "protobufjs/minimal";
import { DeletePrincipalRequest, Principal, PutPrincipalRequest, PutTenantRequest, Tenant } from "./acls";
import {
  LHStatus,
  lHStatusFromJSON,
  lHStatusToNumber,
  MetricsWindowLength,
  metricsWindowLengthFromJSON,
  metricsWindowLengthToNumber,
  TaskStatus,
  taskStatusFromJSON,
  taskStatusToNumber,
  VariableType,
  variableTypeFromJSON,
  variableTypeToNumber,
} from "./common_enums";
import { VariableDef } from "./common_wfspec";
import { ExternalEvent, ExternalEventDef, ExternalEventRetentionPolicy } from "./external_event";
import { Empty } from "./google/protobuf/empty";
import { Timestamp } from "./google/protobuf/timestamp";
import { NodeRun } from "./node_run";
import {
  ExternalEventDefId,
  ExternalEventId,
  NodeRunId,
  PrincipalId,
  ScheduledWfRunId,
  TaskDefId,
  TaskRunId,
  TaskWorkerGroupId,
  TenantId,
  UserTaskDefId,
  UserTaskRunId,
  VariableId,
  WfRunId,
  WfSpecId,
  WorkflowEventDefId,
  WorkflowEventId,
} from "./object_id";
import { ScheduledWfRun } from "./scheduled_wf_run";
import { TaskDef, TaskDefOutputSchema } from "./task_def";
import { LHTaskError, LHTaskException, TaskRun, TaskRunSource, VarNameAndVal } from "./task_run";
import {
  AssignUserTaskRunRequest,
  CancelUserTaskRunRequest,
  CompleteUserTaskRunRequest,
  SaveUserTaskRunProgressRequest,
  UserTaskDef,
  UserTaskField,
  UserTaskRun,
  UserTaskRunStatus,
  userTaskRunStatusFromJSON,
  userTaskRunStatusToNumber,
} from "./user_tasks";
import { Variable, VariableValue } from "./variable";
import { WfRun } from "./wf_run";
import {
  ThreadSpec,
  WfSpec,
  WfSpec_ParentWfSpecReference,
  WfSpecVersionMigration,
  WorkflowRetentionPolicy,
} from "./wf_spec";
import { WorkflowEvent, WorkflowEventDef } from "./workflow_event";

/**
 * This enum controls the behavior of a PutWfSpecRequest when a WfSpec with the same
 * name previously exists.
 */
export enum AllowedUpdateType {
  /**
   * ALL_UPDATES - Allows any update: both minor (revsion) changes and breaking (majorVersion) changes
   * are accepted
   */
  ALL_UPDATES = "ALL_UPDATES",
  /**
   * MINOR_REVISION_UPDATES - Allows only backwards-compatible changes that do not change the required input variables
   * or the searchable variables in the WfSpec.
   */
  MINOR_REVISION_UPDATES = "MINOR_REVISION_UPDATES",
  /** NO_UPDATES - Rejects any changes to the WfSpec. */
  NO_UPDATES = "NO_UPDATES",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function allowedUpdateTypeFromJSON(object: any): AllowedUpdateType {
  switch (object) {
    case 0:
    case "ALL_UPDATES":
      return AllowedUpdateType.ALL_UPDATES;
    case 1:
    case "MINOR_REVISION_UPDATES":
      return AllowedUpdateType.MINOR_REVISION_UPDATES;
    case 2:
    case "NO_UPDATES":
      return AllowedUpdateType.NO_UPDATES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AllowedUpdateType.UNRECOGNIZED;
  }
}

export function allowedUpdateTypeToNumber(object: AllowedUpdateType): number {
  switch (object) {
    case AllowedUpdateType.ALL_UPDATES:
      return 0;
    case AllowedUpdateType.MINOR_REVISION_UPDATES:
      return 1;
    case AllowedUpdateType.NO_UPDATES:
      return 2;
    case AllowedUpdateType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Returns the UserTaskDef with a given name and the highest version number. */
export interface GetLatestUserTaskDefRequest {
  /** The name of the UserTaskDef to search for. */
  name: string;
}

/**
 * Creates a WfSpec. Generally, this request is generated by the Workflow object in
 * our various SDK's.
 */
export interface PutWfSpecRequest {
  /** The name of the resulting WfSpec. */
  name: string;
  /** Map from name the ThreadSpec. */
  threadSpecs: { [key: string]: ThreadSpec };
  /** The name of the ThreadSpec to be used as the workflow entrypoint. */
  entrypointThreadName: string;
  /**
   * Optional policy to determine how long a WfRun is retained in the data store after
   * it is completed or terminated.
   */
  retentionPolicy?:
    | WorkflowRetentionPolicy
    | undefined;
  /**
   * Parent WfSpec Reference. If this is set, then all WfRun's for this WfSpec *MUST* be
   * Child WfRun's of the specified WfSpec.
   */
  parentWfSpec?:
    | WfSpec_ParentWfSpecReference
    | undefined;
  /**
   * Configures the behavior of this individual request. Can be used to prevent
   * breaking changes to the WfSpec, prevent any changes to the WfSpec, or allow
   * all changes to the WfSpec.
   */
  allowedUpdates: AllowedUpdateType;
}

export interface PutWfSpecRequest_ThreadSpecsEntry {
  key: string;
  value: ThreadSpec | undefined;
}

/** Creates a TaskDef. */
export interface PutTaskDefRequest {
  /** The name of the TaskDef to create. */
  name: string;
  /**
   * Variables required to execute the TaskDef. Normally, these are automatically
   * generated by the Task Worker SDK.
   */
  inputVars: VariableDef[];
  /** Schema that validates the TaskDef's output */
  outputSchema?: TaskDefOutputSchema | undefined;
}

/** Creates a WorkflowEventDef */
export interface PutWorkflowEventDefRequest {
  /** The name of the resulting WorkflowEventDef. */
  name: string;
  /** The type of 'content' thrown with a WorkflowEvent based on this WorkflowEventDef. */
  type: VariableType;
}

/** Creates a UserTaskDef. */
export interface PutUserTaskDefRequest {
  /** The name of the UserTaskDef to create. */
  name: string;
  /**
   * The fields that should be presented to the user on the screen in order to fill
   * out the User Task. Note that these fields also define a data contract for the
   * result of the UserTaskDef.
   */
  fields: UserTaskField[];
  /**
   * Optional metadata field to store user-defined data. Does not impact workflow
   * execution. Fine to store up to a few KB of text here.
   */
  description?: string | undefined;
}

/** Field to create an ExternalEventDef. */
export interface PutExternalEventDefRequest {
  /** The name of the resulting ExternalEventDef. */
  name: string;
  /**
   * Policy to determine how long an ExternalEvent is retained after creation if it
   * is not yet claimed by a WfRun. Note that once a WfRun has been matched with the
   * ExternalEvent, the ExternalEvent is deleted if/when that WfRun is deleted.
   * If not set, then ExternalEvent's are not deleted if they are not matched with
   * a WfRun.
   *
   * A future version of LittleHorse will allow changing the retention_policy, which
   * will trigger a cleanup of old `ExternalEvent`s.
   */
  retentionPolicy: ExternalEventRetentionPolicy | undefined;
}

/** Request used to create an ExternalEvent. */
export interface PutExternalEventRequest {
  /** The ID of the WfRun that this Event is sent to. */
  wfRunId:
    | WfRunId
    | undefined;
  /** The ID of the ExternalEventDef that this event implements. */
  externalEventDefId:
    | ExternalEventDefId
    | undefined;
  /**
   * Note that an ExternalEventId is a three-part ID:
   * 1. WfRunId
   * 2. ExternalEventDef Name
   * 3. A guid
   * The guid from part 3) can be optionally provided to the PutExternalEventRequest
   * in order to make it idempotent. It is a best practice to do so.
   */
  guid?:
    | string
    | undefined;
  /** The content of this event. */
  content:
    | VariableValue
    | undefined;
  /** Optionally specify that this ExternalEvent may only be claimed by a specific ThreadRun. */
  threadRunNumber?:
    | number
    | undefined;
  /**
   * Optionally specify that this ExternalEvent may only be claimed by a specific NodeRun.
   * In order for this to be set, you must also set thread_run_number.
   */
  nodeRunPosition?: number | undefined;
}

/** Deletes an ExternalEvent. */
export interface DeleteExternalEventRequest {
  /** The ID of the ExternalEvent to delete. */
  id: ExternalEventId | undefined;
}

/** Delete an existing ScheduledWfRun, returns INVALID_ARGUMENT if object does not exist */
export interface DeleteScheduledWfRunRequest {
  /** Id of the `ScheduledWfRun` to be deleted */
  id: ScheduledWfRunId | undefined;
}

/** Deletes a WfRun. */
export interface DeleteWfRunRequest {
  /** The ID of the WfRun to delete. */
  id: WfRunId | undefined;
}

/** Deletes a TaskDef. */
export interface DeleteTaskDefRequest {
  /** The ID of the TaskDef to delete. */
  id: TaskDefId | undefined;
}

/** Deletes a UserTaskDef. */
export interface DeleteUserTaskDefRequest {
  /** The ID of the UserTaskDef to delete. */
  id: UserTaskDefId | undefined;
}

/** Deletes a WfSpec */
export interface DeleteWfSpecRequest {
  /** The ID of the WfSpec to delete */
  id: WfSpecId | undefined;
}

/** Deletes an ExternalEventDef */
export interface DeleteExternalEventDefRequest {
  /** The ID of the ExternalEventDef to delete. */
  id: ExternalEventDefId | undefined;
}

/** Deletes an WorkflowEventDef */
export interface DeleteWorkflowEventDefRequest {
  /** The ID of the WorkflowEventDef to delete. */
  id: WorkflowEventDefId | undefined;
}

/** Create a Workflow Run. */
export interface RunWfRequest {
  /** The name of the WfSpec to run. */
  wfSpecName: string;
  /**
   * Optionally specify the major version of the WfSpec to run. This guarantees that
   * the "signature" of the WfSpec (i.e. the required input variables, and searchable
   * variables) will not change for this app.
   */
  majorVersion?:
    | number
    | undefined;
  /**
   * Optionally specify the specific revision of the WfSpec to run. It is not recommended
   * to use this in practice, as the WfSpec logic should be de-coupled from the applications
   * that run WfRun's.
   */
  revision?:
    | number
    | undefined;
  /**
   * A map from Variable Name to Values for those variables. The provided variables are
   * passed as input to the Entrypoint ThreadRun.
   */
  variables: { [key: string]: VariableValue };
  /**
   * You can optionally specify the ID of this WfRun. This is a recommended best practice
   * as it also makes your request idempotent and allows you to easily find the WfRun at
   * a later time.
   */
  id?: string | undefined;
  parentWfRunId?: WfRunId | undefined;
}

export interface RunWfRequest_VariablesEntry {
  key: string;
  value: VariableValue | undefined;
}

/** Schedule WfRuns based on a specific cron UNIX expression */
export interface ScheduleWfRequest {
  /** Specific ID */
  id?:
    | string
    | undefined;
  /** The name of the WfSpec to run. */
  wfSpecName: string;
  /**
   * Optionally specify the major version of the WfSpec to run. This guarantees that
   * the "signature" of the WfSpec (i.e. the required input variables, and searchable
   * variables) will not change for this app.
   */
  majorVersion?:
    | number
    | undefined;
  /**
   * Optionally specify the specific revision of the WfSpec to run. It is not recommended
   * to use this in practice, as the WfSpec logic should be de-coupled from the applications
   * that run WfRun's.
   */
  revision?:
    | number
    | undefined;
  /**
   * A map from Variable Name to Values for those variables. The provided variables are
   * passed as input to the Entrypoint ThreadRun.
   */
  variables: { [key: string]: VariableValue };
  /** Parent WfRunId associated with all the generated WfRuns */
  parentWfRunId?:
    | WfRunId
    | undefined;
  /** UNIX expression used to specify the schedule for executing WfRuns */
  cronExpression: string;
}

export interface ScheduleWfRequest_VariablesEntry {
  key: string;
  value: VariableValue | undefined;
}

/**
 * Used by a SearchWfRunRequest to filter WfRun's and only return those whose Variable's
 * match a certain filter.
 */
export interface VariableMatch {
  /** The name of the variable to inspect. */
  varName: string;
  /** The value that the Variable must have in order to satisfy this VariableMatch */
  value: VariableValue | undefined;
}

/**
 * Request to await until a WorkflowEvent of a certain WorkflowEventDef on a certain WfRun
 * is thrown. Relies upon native GRPC deadlines to configure timeouts.
 */
export interface AwaitWorkflowEventRequest {
  /** The ID of the WfRun which must throw the WorkflowEvent. */
  wfRunId:
    | WfRunId
    | undefined;
  /**
   * The IDs of the WorkflowEventDef that must be thrown. The request will return the first matching
   * WorkflowEvent thrown. If event_def_ids is empty, then the request will return the first
   * WorkflowEvent thrown by the WfRun.
   */
  eventDefIds: WorkflowEventDefId[];
  /**
   * Since a single WfRun may throw multiple WorkflowEvent's with the same WorkflowEventDefId, it
   * is necessary to provide a client the ability to "ignore" WorkflowEvent's that have already been
   * 'awaited'. Any WorkflowEvent specified by this field is ignored by the rpc.
   */
  workflowEventsToIgnore: WorkflowEventId[];
}

/** A request used to retrieve a list of WfRunId's by certain criteria. */
export interface SearchWfRunRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** The WfSpec whose WfRun's we are searching for. This is required. */
  wfSpecName: string;
  /** Specifies to return only WfRun's from this WfSpec Major Version. */
  wfSpecMajorVersion?:
    | number
    | undefined;
  /**
   * Specifies to return only WfRun's from this WfSpec Revision. Can only be set if
   * wf_spec_major_version is also set.
   */
  wfSpecRevision?:
    | number
    | undefined;
  /** Specifies to return only WfRun's matching this status. */
  status?:
    | LHStatus
    | undefined;
  /** Specifies to return only WfRun's that started after this time */
  earliestStart?:
    | string
    | undefined;
  /** Specifies to return only WfRun's that started before this time */
  latestStart?:
    | string
    | undefined;
  /**
   * Allows filtering WfRun's based on the value of the Variables. This ONLY
   * works for the Variables in the entrypiont threadrun (that is, variables
   * where the threadRunNumber == 0).
   */
  variableFilters: VariableMatch[];
}

/** List of WfRun Id's */
export interface WfRunIdList {
  /** The resulting object id's. */
  results: WfRunId[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/** Searches for TaskRuns by various criteria. */
export interface SearchTaskRunRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Specifies the TaskDef of TaskRun's to return. This is required. */
  taskDefName: string;
  /** Specifies to only return TaskRun's matching this status. */
  status?:
    | TaskStatus
    | undefined;
  /** Specifies to only return TaskRun's that were scheduled after this time. */
  earliestStart?:
    | string
    | undefined;
  /** Specifies to only return TaskRun's that were scheduled before this time. */
  latestStart?: string | undefined;
}

/** List of TaskRun ID's. */
export interface TaskRunIdList {
  /** The resulting object id's. */
  results: TaskRunId[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/** Search for NodeRun's by certain criteria. */
export interface SearchNodeRunRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Only return NodeRun's created after this time. */
  earliestStart?:
    | string
    | undefined;
  /** Only return NodeRun's created before this time. */
  latestStart?:
    | string
    | undefined;
  /** Specifies the type of NodeRun to search for. */
  nodeType: SearchNodeRunRequest_NodeType;
  /** Specifies the status of NodeRun to search for. */
  status: LHStatus;
}

/** This enum denotes the type of a NodeRun. */
export enum SearchNodeRunRequest_NodeType {
  /** TASK - TASK node schedules a TaskRun */
  TASK = "TASK",
  /** EXTERNAL_EVENT - EXTERNAL_EVENT blocks the ThreadRun until a specified ExternalEvent arrives */
  EXTERNAL_EVENT = "EXTERNAL_EVENT",
  /** ENTRYPOINT - ENTRYPOINT kicks off a ThreadRun */
  ENTRYPOINT = "ENTRYPOINT",
  /** EXIT - EXIT completes a ThreadRun */
  EXIT = "EXIT",
  /** START_THREAD - START_THREAD creates a Child ThreadRun */
  START_THREAD = "START_THREAD",
  /** WAIT_THREADS - WAIT_THREADS waits for one or more child ThreadRuns to complete */
  WAIT_THREADS = "WAIT_THREADS",
  /** SLEEP - SLEEP makes the ThreadRun sleep for a specified time */
  SLEEP = "SLEEP",
  /** USER_TASK - USER_TASK creates a UserTaskRun and blocks until the UserTaskRun is completed. */
  USER_TASK = "USER_TASK",
  /** START_MULTIPLE_THREADS - START_MULTIPLE_THREADS iterates over a list and starts a Child Thread for each item */
  START_MULTIPLE_THREADS = "START_MULTIPLE_THREADS",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function searchNodeRunRequest_NodeTypeFromJSON(object: any): SearchNodeRunRequest_NodeType {
  switch (object) {
    case 0:
    case "TASK":
      return SearchNodeRunRequest_NodeType.TASK;
    case 1:
    case "EXTERNAL_EVENT":
      return SearchNodeRunRequest_NodeType.EXTERNAL_EVENT;
    case 2:
    case "ENTRYPOINT":
      return SearchNodeRunRequest_NodeType.ENTRYPOINT;
    case 3:
    case "EXIT":
      return SearchNodeRunRequest_NodeType.EXIT;
    case 4:
    case "START_THREAD":
      return SearchNodeRunRequest_NodeType.START_THREAD;
    case 5:
    case "WAIT_THREADS":
      return SearchNodeRunRequest_NodeType.WAIT_THREADS;
    case 6:
    case "SLEEP":
      return SearchNodeRunRequest_NodeType.SLEEP;
    case 7:
    case "USER_TASK":
      return SearchNodeRunRequest_NodeType.USER_TASK;
    case 8:
    case "START_MULTIPLE_THREADS":
      return SearchNodeRunRequest_NodeType.START_MULTIPLE_THREADS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchNodeRunRequest_NodeType.UNRECOGNIZED;
  }
}

export function searchNodeRunRequest_NodeTypeToNumber(object: SearchNodeRunRequest_NodeType): number {
  switch (object) {
    case SearchNodeRunRequest_NodeType.TASK:
      return 0;
    case SearchNodeRunRequest_NodeType.EXTERNAL_EVENT:
      return 1;
    case SearchNodeRunRequest_NodeType.ENTRYPOINT:
      return 2;
    case SearchNodeRunRequest_NodeType.EXIT:
      return 3;
    case SearchNodeRunRequest_NodeType.START_THREAD:
      return 4;
    case SearchNodeRunRequest_NodeType.WAIT_THREADS:
      return 5;
    case SearchNodeRunRequest_NodeType.SLEEP:
      return 6;
    case SearchNodeRunRequest_NodeType.USER_TASK:
      return 7;
    case SearchNodeRunRequest_NodeType.START_MULTIPLE_THREADS:
      return 8;
    case SearchNodeRunRequest_NodeType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** List of NodeRun Id's. */
export interface NodeRunIdList {
  /** The resulting object id's. */
  results: NodeRunId[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/**
 * Search for UserTaskRun's matching certain criteria. The attributes are additive,
 * you may specify any combination of fields in this request. Only UserTaskRun's
 * matching all criteria will be returned.
 */
export interface SearchUserTaskRunRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Status of UserTaskRun's to return. */
  status?:
    | UserTaskRunStatus
    | undefined;
  /** UserTaskDef name to search for. */
  userTaskDefName?:
    | string
    | undefined;
  /** Search for UserTaskRun's assigned to this user id. */
  userId?:
    | string
    | undefined;
  /** Search for UserTaskRun's assigned to this user group. */
  userGroup?:
    | string
    | undefined;
  /** Search for UserTaskRun's that were created after this time. */
  earliestStart?:
    | string
    | undefined;
  /** Search for UserTaskRun's that were created before this time. */
  latestStart?: string | undefined;
}

/** A list of UserTaskRun Id's */
export interface UserTaskRunIdList {
  /** The resulting object id's. */
  results: UserTaskRunId[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/**
 * Search for Variables by their value. This request is also highly useful to search for
 * WfRun's based on the value of Variable's that are not in the Entrypoint ThreadRun,
 * and also when you are using LittleHorse as a data store and need to perform a search.
 *
 * You may only search for a Variable that has an index specified on it. This may be done
 * via th `.searchable()` method on our SDK's.
 *
 * Note that we do not yet support searching JSON_OBJ or JSON_ARR fields, but you may
 * still mark those fields as searchable. We will soon add the ability to query those
 * fields via the indices.
 */
export interface SearchVariableRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Specifies the value that the variable must be. Exact match is required. */
  value:
    | VariableValue
    | undefined;
  /** Specifies major version of the WfSpec for the associated WfRun. */
  wfSpecMajorVersion?:
    | number
    | undefined;
  /** Specifies the revision of the WfSpec for the associated WfRun. */
  wfSpecRevision?:
    | number
    | undefined;
  /** Specifies the name of the variable to search for. This is required. */
  varName: string;
  /** Specifies the name of the WfSpec for the associated WfRun's. This is required. */
  wfSpecName: string;
}

/** This is a list of Variable ID's. */
export interface VariableIdList {
  /** The resulting object id's. */
  results: VariableId[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/** Search for TaskDef's based on certain criteria. */
export interface SearchTaskDefRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Optionally specify to only return TaskDef's with a specific prefix. */
  prefix?: string | undefined;
}

/** List of TaskDef Id's. */
export interface TaskDefIdList {
  /** The resulting object id's. */
  results: TaskDefId[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/** Search for UserTaskDef's. */
export interface SearchUserTaskDefRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Return all UserTaskDef's with a specific prefix. */
  prefix?:
    | string
    | undefined;
  /** Return all UserTaskDef's with a specific name. */
  name?: string | undefined;
}

/** List of UserTaskDef Id's. */
export interface UserTaskDefIdList {
  /** The resulting object id's. */
  results: UserTaskDefId[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/** Search for WfSpec's. */
export interface SearchWfSpecRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Return WfSpec's with a specific name. */
  name?:
    | string
    | undefined;
  /** Return WfSpec's with a specific prefix. */
  prefix?:
    | string
    | undefined;
  /** Return all WfSpec's that make use of a given TaskDef. */
  taskDefName?: string | undefined;
}

/** List of WfSpec Id's. */
export interface WfSpecIdList {
  /** The resulting object id's. */
  results: WfSpecId[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/** Search for ExternalEventDefs based on certain criteria. */
export interface SearchExternalEventDefRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Optionally search only for ExternalEventDef's whose name starts with this prefix. */
  prefix?: string | undefined;
}

/** List of ExternalEventDef Id's. */
export interface ExternalEventDefIdList {
  /** The resulting object id's. */
  results: ExternalEventDefId[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/** Search for WorkflowEventDefs based on certain criteria. */
export interface SearchWorkflowEventDefRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Optionally search only for WorkflowEventDef's whose name starts with this prefix. */
  prefix?: string | undefined;
}

/** List of WorkflowEventDef Id's. */
export interface WorkflowEventDefIdList {
  /** The resulting object id's. */
  results: WorkflowEventDefId[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/** Search for all available TenantIds for current Principal */
export interface SearchTenantRequest {
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?: Buffer | undefined;
}

export interface TenantIdList {
  /** The resulting object id's. */
  results: TenantId[];
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?: Buffer | undefined;
}

/** Search for Principals based on certain criteria. */
export interface SearchPrincipalRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Specifies to return only Principals's created after this time */
  earliestStart?:
    | string
    | undefined;
  /** Specifies to return only Principals's created before this time */
  latestStart?:
    | string
    | undefined;
  /** List only Principals that are admins */
  isAdmin?:
    | boolean
    | undefined;
  /** List Principals associated with this Tenant ID */
  tenantId?: string | undefined;
}

export interface PrincipalIdList {
  /** The resulting object id's. */
  results: PrincipalId[];
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?: Buffer | undefined;
}

/**
 * Search for ExternalEvents based on certain criteria.
 *
 * Required field ExternalEventDefId specifies which ExternalEventDef
 * to search for ExternalEvents under.
 *
 * At this time, it is not possible to make a search for all ExternalEvents.
 */
export interface SearchExternalEventRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Specifies to return only ExternalEvents created after this time */
  earliestStart?:
    | string
    | undefined;
  /** Specifies to return only ExternalEvents created before this time */
  latestStart?:
    | string
    | undefined;
  /**
   * Search for ExternalEvents by their ExternalEventDefId
   *
   * * Note: If ExternalEventDefId is not provided or does not exist,
   *         gRPC status code 'INVALID_ARGUMENT' will be returned.
   */
  externalEventDefId:
    | ExternalEventDefId
    | undefined;
  /** Optionally search for only ExternalEvents that are claimed or not. */
  isClaimed?: boolean | undefined;
}

/** List of ExternalEvent Id's */
export interface ExternalEventIdList {
  /** The resulting object id's. */
  results: ExternalEventId[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/**
 * Search for WorkflowEvents based on certain criteria.
 *
 * Required field WorkflowEventDefId specifies which WorkflowEventDef
 * to search for WorkflowEvents under.
 */
export interface SearchWorkflowEventRequest {
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?:
    | number
    | undefined;
  /** Specifies to return only WorkflowEvent created after this time */
  earliestStart?:
    | string
    | undefined;
  /** Specifies to return only WorkflowEvent created before this time */
  latestStart?:
    | string
    | undefined;
  /**
   * Search for WorkflowEvents by their WorkflowEventDefId
   *
   * * Note: If WorkflowEventDefId is not provided or does not exist,
   *         gRPC status code 'INVALID_ARGUMENT' will be returned.
   */
  workflowEventDefId: WorkflowEventDefId | undefined;
}

/** List of WorkflowEvent Id's */
export interface WorkflowEventIdList {
  /** The resulting object id's. */
  results: WorkflowEventId[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/**
 * List all NodeRun's for a given WfRun. Note that List requests return actual NodeRun Objects,
 * not NodeRunId's.
 */
export interface ListNodeRunsRequest {
  /** The WfRun for whom we list NodeRun's. */
  wfRunId:
    | WfRunId
    | undefined;
  /** Optionally specify the thread run number to filter NodeRun's by. */
  threadRunNumber?:
    | number
    | undefined;
  /** Bookmark for cursor-based pagination; pass if applicable. */
  bookmark?:
    | Buffer
    | undefined;
  /** Maximum results to return in one request. */
  limit?: number | undefined;
}

/** A list of NodeRun Objects. */
export interface NodeRunList {
  /** A list of NodeRun Objects. */
  results: NodeRun[];
  /**
   * The bookmark can be used for cursor-based pagination. If it is null, the server
   * has returned all results. If it is set, you can pass it into your next request
   * to resume searching where your previous request left off.
   */
  bookmark?: Buffer | undefined;
}

/**
 * List all Variables for a specific WfRun. Note that List requests return actual Variable Objects,
 * not VariableId's.
 */
export interface ListVariablesRequest {
  /** The WfRun for whom we will list Variables. */
  wfRunId: WfRunId | undefined;
}

/** A list of Variables. */
export interface VariableList {
  /** A list of Variable objects. */
  results: Variable[];
}

/**
 * List all ExternalEvents for a specific WfRunId. Note that List Requests return actual
 * ExternalEvent objects, not ExternalEventId's.
 */
export interface ListExternalEventsRequest {
  /** The WfRunId for whom we list ExternalEvent's. */
  wfRunId: WfRunId | undefined;
}

/** A list of ExternalEvents. */
export interface ExternalEventList {
  /** A list of ExternalEvent objects. */
  results: ExternalEvent[];
}

/**
 * List all WorkflowEvents for a specific WfRunId. Note that List Requests return actual
 * WorkflowEvent objects, not WorkflowEventId's.
 */
export interface ListWorkflowEventsRequest {
  /** The WfRunId for whom we list WorkflowEvent's. */
  wfRunId: WfRunId | undefined;
}

/** A list of WorkflowEvents. */
export interface WorkflowEventList {
  /** A list of WorkflowEvent objects. */
  results: WorkflowEvent[];
}

/**
 * Message used by Task Worker to register itself to the server and ask for assignments of
 * servers to poll.
 *
 * Used by the Task Worker SDK; generally, you shouldn't have to touch this manually.
 */
export interface RegisterTaskWorkerRequest {
  /** Is the ID of the Task Worker. */
  taskWorkerId: string;
  /** The TaskDef the worker wants to poll for. */
  taskDefId: TaskDefId | undefined;
}

/**
 * Message used by Task Worker to register itself to the server and ask for assignments of
 * servers to poll.
 *
 * Used by the Task Worker SDK; generally, you shouldn't have to touch this manually.
 */
export interface TaskWorkerHeartBeatRequest {
  clientId: string;
  taskDefId: TaskDefId | undefined;
  listenerName: string;
}

/**
 * Response containing list of Servers that the Task Worker should connect to and start polling from.
 * Only used internally by the Task Worker SDK.
 */
export interface RegisterTaskWorkerResponse {
  /** The list of LH Server hosts that the Task Worker should start polling. */
  yourHosts: LHHostInfo[];
  /** Whether the LH Cluster is healthy. */
  isClusterHealthy?: boolean | undefined;
}

/** Information about a specific LH Server to contact. */
export interface LHHostInfo {
  /** The host on the server */
  host: string;
  /** The port for the specified listener. */
  port: number;
}

/**
 * Request sent by the Task Worker SDK to tell the Server that the Task Worker is ready
 * to execute a TaskRun. Generally used only by the Task Worker SDK.
 */
export interface PollTaskRequest {
  /** Is the TaskDefId that the Task Worker wants to execute. */
  taskDefId:
    | TaskDefId
    | undefined;
  /** Is the ID of the Task Worker. */
  clientId: string;
  /**
   * Optionally specifies the version of the Task Worker, so that it can be recorded
   * for debugging purposes on the TaskRun itself.
   */
  taskWorkerVersion?: string | undefined;
}

/**
 * Message sent by server to Task Worker SDK specifying a specific TaskRun to be executed.
 * This is used and handled internally by the Task Worker SDK.
 */
export interface ScheduledTask {
  /** Id of the TaskRun to execute. */
  taskRunId:
    | TaskRunId
    | undefined;
  /** ID of the TaskDef to which the TaskRun belongs. */
  taskDefId:
    | TaskDefId
    | undefined;
  /**
   * Attempt number of the TaskRun, zero indexed. attempt_number of `0` means this is the
   * first attempt; `1` means this is the first retry, etc.
   */
  attemptNumber: number;
  /** Input variables for this TaskRun. */
  variables: VarNameAndVal[];
  createdAt:
    | string
    | undefined;
  /**
   * Source of the TaskRun. Currently, there are two options:
   * 1. A TASK node
   * 2. A reminder task scheduled by a trigger on a User Task.
   */
  source: TaskRunSource | undefined;
}

/** Response from the server for PollTaskRequest. */
export interface PollTaskResponse {
  /** If possible, a ScheduledTask is returned. */
  result?: ScheduledTask | undefined;
}

/** Request used by the Task Worker SDK to report the result of a TaskRun execution. */
export interface ReportTaskRun {
  /** ID of the TaskRun */
  taskRunId:
    | TaskRunId
    | undefined;
  /** When the TaskRun was executed */
  time:
    | string
    | undefined;
  /** Status of the TaskRun */
  status: TaskStatus;
  /** Optional information for logging or exceptions */
  logOutput?:
    | VariableValue
    | undefined;
  /** Attempt number of the TaskRun */
  attemptNumber: number;
  /** Successfully completed task */
  output?:
    | VariableValue
    | undefined;
  /** Technical error */
  error?:
    | LHTaskError
    | undefined;
  /** Business exception */
  exception?: LHTaskException | undefined;
}

/** Message to HALT a WfRun. */
export interface StopWfRunRequest {
  /** Is the WfRunId */
  wfRunId:
    | WfRunId
    | undefined;
  /**
   * The number of the ThreadRun to halt. Note that halting the entrypoint ThreadRun (which
   * always has number `0`) causes the whole WfRun to halt. If you do not manually set
   * the thread_run_number field, it defaults to zero, so stopping the entire WfRun is the
   * default behavior.
   */
  threadRunNumber: number;
}

/** Resume a WfRun. */
export interface ResumeWfRunRequest {
  /** Is the WfRunId */
  wfRunId:
    | WfRunId
    | undefined;
  /**
   * The number of the ThreadRun to resume. Note that resuming the entrypoint ThreadRun (which
   * always has number `0`) causes the whole WfRun to resume. If you do not manually set
   * the thread_run_number field, it defaults to zero, so resuming the entire WfRun is the
   * default behavior.
   */
  threadRunNumber: number;
}

/** The request used to rescue a failed ThreadRun at a specific NodeRun. */
export interface RescueThreadRunRequest {
  /** The id of the `WfRun` which we are going to rescue. */
  wfRunId:
    | WfRunId
    | undefined;
  /**
   * The number of the failed `ThreadRun` that we will rescue. The specified
   * `ThreadRun` must be in a state where it's latest `NodeRun` is: <br/>
   * - In the `ERROR` state.<br/>
   * - Has no `FailureHandler` `ThreadRun`s <br/>
   * - The parent `ThreadRun`, or any parent of the parent, has not handled the `Failure`
   * yet.
   *
   * If that is not true, then the `ThreadRun` cannot be rescued and the request
   * will return `FAILED_PRECONDITION`.
   */
  threadRunNumber: number;
  /**
   * If set to `true`, then the ThreadRun will skip past the `Node` of the
   * current failed `NodeRun` and advance according to the outgoing edges.
   * If set to `false`, then the `ThreadRun` will schedule another `NodeRun` for
   * the current `Node`
   */
  skipCurrentNode: boolean;
}

/** Query to retrieve a specific TaskDef Metrics Window. */
export interface TaskDefMetricsQueryRequest {
  /**
   * Return the window *containing* this timestamp. The window start is not guaranteed to
   * align perfectly with the request.
   */
  windowStart:
    | string
    | undefined;
  /** The window size */
  windowType: MetricsWindowLength;
  /** The name of the specific TaskDef for which we are calculating metrics. */
  taskDefName?: string | undefined;
}

/** Query to retrieve TaskDef Metrics over a period of time. */
export interface ListTaskMetricsRequest {
  /** TaskDef id for whichwe retrieve metrics. */
  taskDefId:
    | TaskDefId
    | undefined;
  /**
   * This parameter is a timestamp that is used to determine the *last* window returned. The
   * server will then return `num_windows` worth of data from before this timestamp.
   */
  lastWindowStart:
    | string
    | undefined;
  /** Window size */
  windowLength: MetricsWindowLength;
  /** Number of windows to retrieve. */
  numWindows: number;
}

/** A list of TaskDef Metrics WIndows */
export interface ListTaskMetricsResponse {
  /** List of TaskDef Metrics Windows */
  results: TaskDefMetrics[];
}

/** Query to retrieve a specific WfSpec Metrics Window. */
export interface WfSpecMetricsQueryRequest {
  /** WfSpecId of metrics to get. */
  wfSpecId:
    | WfSpecId
    | undefined;
  /**
   * Return the window *containing* this timestamp. The window start is not guaranteed to
   * align perfectly with the request.
   */
  windowStart:
    | string
    | undefined;
  /** The window size */
  windowLength: MetricsWindowLength;
}

/** Query to retrieve WfSpec Metrics over a period of time. */
export interface ListWfMetricsRequest {
  /** WfSpecId of metrics to get. */
  wfSpecId:
    | WfSpecId
    | undefined;
  /**
   * This parameter is a timestamp that is used to determine the *last* window returned. The
   * server will then return `num_windows` worth of data from before this timestamp.
   */
  lastWindowStart:
    | string
    | undefined;
  /** The window size */
  windowLength: MetricsWindowLength;
  /** Number of windows to retrieve */
  numWindows: number;
}

/** A list of WfSpec Metrics Windows */
export interface ListWfMetricsResponse {
  /** List of WfSpec Metrics Windows */
  results: WfSpecMetrics[];
}

/** Metrics for a TaskDef in a certain time period. */
export interface TaskDefMetrics {
  /** TaskDef that the metrics apply to. */
  taskDefId:
    | TaskDefId
    | undefined;
  /** When the window started. */
  windowStart:
    | string
    | undefined;
  /** Length of the window. */
  type: MetricsWindowLength;
  /** Longest time that a TaskRun was in the TASK_SCHEDULED state */
  scheduleToStartMax: number;
  /** Average time that a TaskRun was in the TASK_SCHEDULED state */
  scheduleToStartAvg: number;
  /** Longest time between a TaskRun being started and completed */
  startToCompleteMax: number;
  /** Average time between a TaskRun being started and completed */
  startToCompleteAvg: number;
  /** Total number of TaskRun's that reached the TASK_SUCCESS state */
  totalCompleted: number;
  /** Total number of TaskRun's that reached the TASK_ERROR state */
  totalErrored: number;
  /** Total number of TaskRun's that transitioned to the TASK_RUNNING state */
  totalStarted: number;
  /** Total number of TaskRun's that were scheduled */
  totalScheduled: number;
}

/** Metrics for a WfSpec in a specific time window */
export interface WfSpecMetrics {
  /** The WfSpecId that these metrics analyze */
  wfSpecId:
    | WfSpecId
    | undefined;
  /** The time that the window started */
  windowStart:
    | string
    | undefined;
  /** The length of the window */
  type: MetricsWindowLength;
  /** Total number of WfRun's created for this WfSpec */
  totalStarted: number;
  /** Total number of WfRun's that reached the COMPLETED state */
  totalCompleted: number;
  /** Total number of WfRun's that reached the ERROR state */
  totalErrored: number;
  /** Longest time between a WfRun being started and reaching the COMPLETED state */
  startToCompleteMax: number;
  /** Average time that a WfRun took to reach the COMPLETED state */
  startToCompleteAvg: number;
}

/** List UserTaskRun's for a specific WfRun */
export interface ListUserTaskRunRequest {
  /** The WfRun for which to list UserTaskRuns */
  wfRunId: WfRunId | undefined;
}

/** List of UserTaskRuns */
export interface UserTaskRunList {
  /** A list of UserTaskRun Objects */
  results: UserTaskRun[];
}

/** List of ScheduledWfRun */
export interface ScheduledWfRunIdList {
  /** A list of ScheduledWfRun Objects */
  results: ScheduledWfRunId[];
}

/** Search filters for ScheduledWfRun's */
export interface SearchScheduledWfRunRequest {
  /** The name of the WfSpec to filter */
  wfSpecName: string;
  /** The major version of the WfSpec to filter */
  majorVersion?:
    | number
    | undefined;
  /** The revision number of the WfSpec to filter */
  revision?: number | undefined;
}

/** Describes a specific task worker */
export interface TaskWorkerMetadata {
  /** User-defined identifier for the worker. */
  taskWorkerId: string;
  /** Timestamp indicating the last heartbeat sent by the worker. */
  latestHeartbeat:
    | string
    | undefined;
  /** The host(s) where the worker is polling tasks */
  hosts: LHHostInfo[];
}

/** Describes all workers registered for a specific TaskDef. */
export interface TaskWorkerGroup {
  /** Identifier for the group. */
  id:
    | TaskWorkerGroupId
    | undefined;
  /** Timestamp indicating when the worker group was initially registered. */
  createdAt:
    | string
    | undefined;
  /** Metadata grouped by ClientId string. */
  taskWorkers: { [key: string]: TaskWorkerMetadata };
}

export interface TaskWorkerGroup_TaskWorkersEntry {
  key: string;
  value: TaskWorkerMetadata | undefined;
}

/** List TaskRun's for a specific WfRun */
export interface ListTaskRunsRequest {
  /** The WfRun for which to list TaskRun's */
  wfRunId: WfRunId | undefined;
}

/** A list of TaskRun's */
export interface TaskRunList {
  /** A list of TaskRun Objects */
  results: TaskRun[];
}

/** EXPERIMENTAL: migrate live WfRun's from one version of a WfSpec to another. */
export interface MigrateWfSpecRequest {
  oldWfSpec: WfSpecId | undefined;
  migration: WfSpecVersionMigration | undefined;
}

/** Get the latest WfSpec with a given name and optionally majorVersion */
export interface GetLatestWfSpecRequest {
  /** The name of the WfSpec to get. This is required. */
  name: string;
  /**
   * Optionally get only WfSpec's that have the same major version. This can be useful
   * if you want to guarantee that there have been no breaking changes to the API of the
   * WfSpec, for example, to ensure that there have been no changes to searchable variables
   * or required input variables.
   */
  majorVersion?: number | undefined;
}

/** The version of the LH Server according to Semantic Versioning */
export interface ServerVersion {
  /** Server Major Version */
  majorVersion: number;
  /** Server Minor Version */
  minorVersion: number;
  /** Server Patch Version */
  patchVersion: number;
  /**
   * Prerelease Identifier. If this is set, then the server is NOT a production release
   * but rather a release candidate or experimental pre-release.
   */
  preReleaseIdentifier?: string | undefined;
}

function createBaseGetLatestUserTaskDefRequest(): GetLatestUserTaskDefRequest {
  return { name: "" };
}

export const GetLatestUserTaskDefRequest = {
  encode(message: GetLatestUserTaskDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLatestUserTaskDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestUserTaskDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetLatestUserTaskDefRequest>): GetLatestUserTaskDefRequest {
    return GetLatestUserTaskDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLatestUserTaskDefRequest>): GetLatestUserTaskDefRequest {
    const message = createBaseGetLatestUserTaskDefRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePutWfSpecRequest(): PutWfSpecRequest {
  return {
    name: "",
    threadSpecs: {},
    entrypointThreadName: "",
    retentionPolicy: undefined,
    parentWfSpec: undefined,
    allowedUpdates: AllowedUpdateType.ALL_UPDATES,
  };
}

export const PutWfSpecRequest = {
  encode(message: PutWfSpecRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.threadSpecs).forEach(([key, value]) => {
      PutWfSpecRequest_ThreadSpecsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    if (message.entrypointThreadName !== "") {
      writer.uint32(50).string(message.entrypointThreadName);
    }
    if (message.retentionPolicy !== undefined) {
      WorkflowRetentionPolicy.encode(message.retentionPolicy, writer.uint32(66).fork()).ldelim();
    }
    if (message.parentWfSpec !== undefined) {
      WfSpec_ParentWfSpecReference.encode(message.parentWfSpec, writer.uint32(74).fork()).ldelim();
    }
    if (message.allowedUpdates !== AllowedUpdateType.ALL_UPDATES) {
      writer.uint32(80).int32(allowedUpdateTypeToNumber(message.allowedUpdates));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutWfSpecRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutWfSpecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = PutWfSpecRequest_ThreadSpecsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.threadSpecs[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.entrypointThreadName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.retentionPolicy = WorkflowRetentionPolicy.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.parentWfSpec = WfSpec_ParentWfSpecReference.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.allowedUpdates = allowedUpdateTypeFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PutWfSpecRequest>): PutWfSpecRequest {
    return PutWfSpecRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PutWfSpecRequest>): PutWfSpecRequest {
    const message = createBasePutWfSpecRequest();
    message.name = object.name ?? "";
    message.threadSpecs = Object.entries(object.threadSpecs ?? {}).reduce<{ [key: string]: ThreadSpec }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ThreadSpec.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.entrypointThreadName = object.entrypointThreadName ?? "";
    message.retentionPolicy = (object.retentionPolicy !== undefined && object.retentionPolicy !== null)
      ? WorkflowRetentionPolicy.fromPartial(object.retentionPolicy)
      : undefined;
    message.parentWfSpec = (object.parentWfSpec !== undefined && object.parentWfSpec !== null)
      ? WfSpec_ParentWfSpecReference.fromPartial(object.parentWfSpec)
      : undefined;
    message.allowedUpdates = object.allowedUpdates ?? AllowedUpdateType.ALL_UPDATES;
    return message;
  },
};

function createBasePutWfSpecRequest_ThreadSpecsEntry(): PutWfSpecRequest_ThreadSpecsEntry {
  return { key: "", value: undefined };
}

export const PutWfSpecRequest_ThreadSpecsEntry = {
  encode(message: PutWfSpecRequest_ThreadSpecsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ThreadSpec.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutWfSpecRequest_ThreadSpecsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutWfSpecRequest_ThreadSpecsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ThreadSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PutWfSpecRequest_ThreadSpecsEntry>): PutWfSpecRequest_ThreadSpecsEntry {
    return PutWfSpecRequest_ThreadSpecsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PutWfSpecRequest_ThreadSpecsEntry>): PutWfSpecRequest_ThreadSpecsEntry {
    const message = createBasePutWfSpecRequest_ThreadSpecsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ThreadSpec.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePutTaskDefRequest(): PutTaskDefRequest {
  return { name: "", inputVars: [], outputSchema: undefined };
}

export const PutTaskDefRequest = {
  encode(message: PutTaskDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.inputVars) {
      VariableDef.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.outputSchema !== undefined) {
      TaskDefOutputSchema.encode(message.outputSchema, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutTaskDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutTaskDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputVars.push(VariableDef.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outputSchema = TaskDefOutputSchema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PutTaskDefRequest>): PutTaskDefRequest {
    return PutTaskDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PutTaskDefRequest>): PutTaskDefRequest {
    const message = createBasePutTaskDefRequest();
    message.name = object.name ?? "";
    message.inputVars = object.inputVars?.map((e) => VariableDef.fromPartial(e)) || [];
    message.outputSchema = (object.outputSchema !== undefined && object.outputSchema !== null)
      ? TaskDefOutputSchema.fromPartial(object.outputSchema)
      : undefined;
    return message;
  },
};

function createBasePutWorkflowEventDefRequest(): PutWorkflowEventDefRequest {
  return { name: "", type: VariableType.JSON_OBJ };
}

export const PutWorkflowEventDefRequest = {
  encode(message: PutWorkflowEventDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== VariableType.JSON_OBJ) {
      writer.uint32(16).int32(variableTypeToNumber(message.type));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutWorkflowEventDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutWorkflowEventDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = variableTypeFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PutWorkflowEventDefRequest>): PutWorkflowEventDefRequest {
    return PutWorkflowEventDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PutWorkflowEventDefRequest>): PutWorkflowEventDefRequest {
    const message = createBasePutWorkflowEventDefRequest();
    message.name = object.name ?? "";
    message.type = object.type ?? VariableType.JSON_OBJ;
    return message;
  },
};

function createBasePutUserTaskDefRequest(): PutUserTaskDefRequest {
  return { name: "", fields: [], description: undefined };
}

export const PutUserTaskDefRequest = {
  encode(message: PutUserTaskDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.fields) {
      UserTaskField.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutUserTaskDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutUserTaskDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fields.push(UserTaskField.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PutUserTaskDefRequest>): PutUserTaskDefRequest {
    return PutUserTaskDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PutUserTaskDefRequest>): PutUserTaskDefRequest {
    const message = createBasePutUserTaskDefRequest();
    message.name = object.name ?? "";
    message.fields = object.fields?.map((e) => UserTaskField.fromPartial(e)) || [];
    message.description = object.description ?? undefined;
    return message;
  },
};

function createBasePutExternalEventDefRequest(): PutExternalEventDefRequest {
  return { name: "", retentionPolicy: undefined };
}

export const PutExternalEventDefRequest = {
  encode(message: PutExternalEventDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.retentionPolicy !== undefined) {
      ExternalEventRetentionPolicy.encode(message.retentionPolicy, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutExternalEventDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutExternalEventDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.retentionPolicy = ExternalEventRetentionPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PutExternalEventDefRequest>): PutExternalEventDefRequest {
    return PutExternalEventDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PutExternalEventDefRequest>): PutExternalEventDefRequest {
    const message = createBasePutExternalEventDefRequest();
    message.name = object.name ?? "";
    message.retentionPolicy = (object.retentionPolicy !== undefined && object.retentionPolicy !== null)
      ? ExternalEventRetentionPolicy.fromPartial(object.retentionPolicy)
      : undefined;
    return message;
  },
};

function createBasePutExternalEventRequest(): PutExternalEventRequest {
  return {
    wfRunId: undefined,
    externalEventDefId: undefined,
    guid: undefined,
    content: undefined,
    threadRunNumber: undefined,
    nodeRunPosition: undefined,
  };
}

export const PutExternalEventRequest = {
  encode(message: PutExternalEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfRunId !== undefined) {
      WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
    }
    if (message.externalEventDefId !== undefined) {
      ExternalEventDefId.encode(message.externalEventDefId, writer.uint32(18).fork()).ldelim();
    }
    if (message.guid !== undefined) {
      writer.uint32(26).string(message.guid);
    }
    if (message.content !== undefined) {
      VariableValue.encode(message.content, writer.uint32(42).fork()).ldelim();
    }
    if (message.threadRunNumber !== undefined) {
      writer.uint32(48).int32(message.threadRunNumber);
    }
    if (message.nodeRunPosition !== undefined) {
      writer.uint32(56).int32(message.nodeRunPosition);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutExternalEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutExternalEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.externalEventDefId = ExternalEventDefId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.guid = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.content = VariableValue.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.threadRunNumber = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.nodeRunPosition = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PutExternalEventRequest>): PutExternalEventRequest {
    return PutExternalEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PutExternalEventRequest>): PutExternalEventRequest {
    const message = createBasePutExternalEventRequest();
    message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
      ? WfRunId.fromPartial(object.wfRunId)
      : undefined;
    message.externalEventDefId = (object.externalEventDefId !== undefined && object.externalEventDefId !== null)
      ? ExternalEventDefId.fromPartial(object.externalEventDefId)
      : undefined;
    message.guid = object.guid ?? undefined;
    message.content = (object.content !== undefined && object.content !== null)
      ? VariableValue.fromPartial(object.content)
      : undefined;
    message.threadRunNumber = object.threadRunNumber ?? undefined;
    message.nodeRunPosition = object.nodeRunPosition ?? undefined;
    return message;
  },
};

function createBaseDeleteExternalEventRequest(): DeleteExternalEventRequest {
  return { id: undefined };
}

export const DeleteExternalEventRequest = {
  encode(message: DeleteExternalEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      ExternalEventId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteExternalEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteExternalEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ExternalEventId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeleteExternalEventRequest>): DeleteExternalEventRequest {
    return DeleteExternalEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteExternalEventRequest>): DeleteExternalEventRequest {
    const message = createBaseDeleteExternalEventRequest();
    message.id = (object.id !== undefined && object.id !== null) ? ExternalEventId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseDeleteScheduledWfRunRequest(): DeleteScheduledWfRunRequest {
  return { id: undefined };
}

export const DeleteScheduledWfRunRequest = {
  encode(message: DeleteScheduledWfRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      ScheduledWfRunId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteScheduledWfRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteScheduledWfRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ScheduledWfRunId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeleteScheduledWfRunRequest>): DeleteScheduledWfRunRequest {
    return DeleteScheduledWfRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteScheduledWfRunRequest>): DeleteScheduledWfRunRequest {
    const message = createBaseDeleteScheduledWfRunRequest();
    message.id = (object.id !== undefined && object.id !== null) ? ScheduledWfRunId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseDeleteWfRunRequest(): DeleteWfRunRequest {
  return { id: undefined };
}

export const DeleteWfRunRequest = {
  encode(message: DeleteWfRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      WfRunId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteWfRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWfRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = WfRunId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeleteWfRunRequest>): DeleteWfRunRequest {
    return DeleteWfRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWfRunRequest>): DeleteWfRunRequest {
    const message = createBaseDeleteWfRunRequest();
    message.id = (object.id !== undefined && object.id !== null) ? WfRunId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseDeleteTaskDefRequest(): DeleteTaskDefRequest {
  return { id: undefined };
}

export const DeleteTaskDefRequest = {
  encode(message: DeleteTaskDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      TaskDefId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteTaskDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTaskDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = TaskDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeleteTaskDefRequest>): DeleteTaskDefRequest {
    return DeleteTaskDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTaskDefRequest>): DeleteTaskDefRequest {
    const message = createBaseDeleteTaskDefRequest();
    message.id = (object.id !== undefined && object.id !== null) ? TaskDefId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseDeleteUserTaskDefRequest(): DeleteUserTaskDefRequest {
  return { id: undefined };
}

export const DeleteUserTaskDefRequest = {
  encode(message: DeleteUserTaskDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      UserTaskDefId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserTaskDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserTaskDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = UserTaskDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeleteUserTaskDefRequest>): DeleteUserTaskDefRequest {
    return DeleteUserTaskDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteUserTaskDefRequest>): DeleteUserTaskDefRequest {
    const message = createBaseDeleteUserTaskDefRequest();
    message.id = (object.id !== undefined && object.id !== null) ? UserTaskDefId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseDeleteWfSpecRequest(): DeleteWfSpecRequest {
  return { id: undefined };
}

export const DeleteWfSpecRequest = {
  encode(message: DeleteWfSpecRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      WfSpecId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteWfSpecRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWfSpecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = WfSpecId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeleteWfSpecRequest>): DeleteWfSpecRequest {
    return DeleteWfSpecRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWfSpecRequest>): DeleteWfSpecRequest {
    const message = createBaseDeleteWfSpecRequest();
    message.id = (object.id !== undefined && object.id !== null) ? WfSpecId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseDeleteExternalEventDefRequest(): DeleteExternalEventDefRequest {
  return { id: undefined };
}

export const DeleteExternalEventDefRequest = {
  encode(message: DeleteExternalEventDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      ExternalEventDefId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteExternalEventDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteExternalEventDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ExternalEventDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeleteExternalEventDefRequest>): DeleteExternalEventDefRequest {
    return DeleteExternalEventDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteExternalEventDefRequest>): DeleteExternalEventDefRequest {
    const message = createBaseDeleteExternalEventDefRequest();
    message.id = (object.id !== undefined && object.id !== null)
      ? ExternalEventDefId.fromPartial(object.id)
      : undefined;
    return message;
  },
};

function createBaseDeleteWorkflowEventDefRequest(): DeleteWorkflowEventDefRequest {
  return { id: undefined };
}

export const DeleteWorkflowEventDefRequest = {
  encode(message: DeleteWorkflowEventDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      WorkflowEventDefId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteWorkflowEventDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWorkflowEventDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = WorkflowEventDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeleteWorkflowEventDefRequest>): DeleteWorkflowEventDefRequest {
    return DeleteWorkflowEventDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWorkflowEventDefRequest>): DeleteWorkflowEventDefRequest {
    const message = createBaseDeleteWorkflowEventDefRequest();
    message.id = (object.id !== undefined && object.id !== null)
      ? WorkflowEventDefId.fromPartial(object.id)
      : undefined;
    return message;
  },
};

function createBaseRunWfRequest(): RunWfRequest {
  return {
    wfSpecName: "",
    majorVersion: undefined,
    revision: undefined,
    variables: {},
    id: undefined,
    parentWfRunId: undefined,
  };
}

export const RunWfRequest = {
  encode(message: RunWfRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpecName !== "") {
      writer.uint32(10).string(message.wfSpecName);
    }
    if (message.majorVersion !== undefined) {
      writer.uint32(16).int32(message.majorVersion);
    }
    if (message.revision !== undefined) {
      writer.uint32(24).int32(message.revision);
    }
    Object.entries(message.variables).forEach(([key, value]) => {
      RunWfRequest_VariablesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    if (message.id !== undefined) {
      writer.uint32(42).string(message.id);
    }
    if (message.parentWfRunId !== undefined) {
      WfRunId.encode(message.parentWfRunId, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RunWfRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunWfRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpecName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.majorVersion = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.revision = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = RunWfRequest_VariablesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.variables[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.parentWfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RunWfRequest>): RunWfRequest {
    return RunWfRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunWfRequest>): RunWfRequest {
    const message = createBaseRunWfRequest();
    message.wfSpecName = object.wfSpecName ?? "";
    message.majorVersion = object.majorVersion ?? undefined;
    message.revision = object.revision ?? undefined;
    message.variables = Object.entries(object.variables ?? {}).reduce<{ [key: string]: VariableValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = VariableValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.id = object.id ?? undefined;
    message.parentWfRunId = (object.parentWfRunId !== undefined && object.parentWfRunId !== null)
      ? WfRunId.fromPartial(object.parentWfRunId)
      : undefined;
    return message;
  },
};

function createBaseRunWfRequest_VariablesEntry(): RunWfRequest_VariablesEntry {
  return { key: "", value: undefined };
}

export const RunWfRequest_VariablesEntry = {
  encode(message: RunWfRequest_VariablesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      VariableValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RunWfRequest_VariablesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunWfRequest_VariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = VariableValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RunWfRequest_VariablesEntry>): RunWfRequest_VariablesEntry {
    return RunWfRequest_VariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunWfRequest_VariablesEntry>): RunWfRequest_VariablesEntry {
    const message = createBaseRunWfRequest_VariablesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseScheduleWfRequest(): ScheduleWfRequest {
  return {
    id: undefined,
    wfSpecName: "",
    majorVersion: undefined,
    revision: undefined,
    variables: {},
    parentWfRunId: undefined,
    cronExpression: "",
  };
}

export const ScheduleWfRequest = {
  encode(message: ScheduleWfRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.wfSpecName !== "") {
      writer.uint32(18).string(message.wfSpecName);
    }
    if (message.majorVersion !== undefined) {
      writer.uint32(24).int32(message.majorVersion);
    }
    if (message.revision !== undefined) {
      writer.uint32(32).int32(message.revision);
    }
    Object.entries(message.variables).forEach(([key, value]) => {
      ScheduleWfRequest_VariablesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    if (message.parentWfRunId !== undefined) {
      WfRunId.encode(message.parentWfRunId, writer.uint32(50).fork()).ldelim();
    }
    if (message.cronExpression !== "") {
      writer.uint32(58).string(message.cronExpression);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScheduleWfRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleWfRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.wfSpecName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.majorVersion = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.revision = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = ScheduleWfRequest_VariablesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.variables[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.parentWfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.cronExpression = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ScheduleWfRequest>): ScheduleWfRequest {
    return ScheduleWfRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScheduleWfRequest>): ScheduleWfRequest {
    const message = createBaseScheduleWfRequest();
    message.id = object.id ?? undefined;
    message.wfSpecName = object.wfSpecName ?? "";
    message.majorVersion = object.majorVersion ?? undefined;
    message.revision = object.revision ?? undefined;
    message.variables = Object.entries(object.variables ?? {}).reduce<{ [key: string]: VariableValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = VariableValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.parentWfRunId = (object.parentWfRunId !== undefined && object.parentWfRunId !== null)
      ? WfRunId.fromPartial(object.parentWfRunId)
      : undefined;
    message.cronExpression = object.cronExpression ?? "";
    return message;
  },
};

function createBaseScheduleWfRequest_VariablesEntry(): ScheduleWfRequest_VariablesEntry {
  return { key: "", value: undefined };
}

export const ScheduleWfRequest_VariablesEntry = {
  encode(message: ScheduleWfRequest_VariablesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      VariableValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScheduleWfRequest_VariablesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleWfRequest_VariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = VariableValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ScheduleWfRequest_VariablesEntry>): ScheduleWfRequest_VariablesEntry {
    return ScheduleWfRequest_VariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScheduleWfRequest_VariablesEntry>): ScheduleWfRequest_VariablesEntry {
    const message = createBaseScheduleWfRequest_VariablesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseVariableMatch(): VariableMatch {
  return { varName: "", value: undefined };
}

export const VariableMatch = {
  encode(message: VariableMatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.varName !== "") {
      writer.uint32(10).string(message.varName);
    }
    if (message.value !== undefined) {
      VariableValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VariableMatch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariableMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.varName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = VariableValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<VariableMatch>): VariableMatch {
    return VariableMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariableMatch>): VariableMatch {
    const message = createBaseVariableMatch();
    message.varName = object.varName ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAwaitWorkflowEventRequest(): AwaitWorkflowEventRequest {
  return { wfRunId: undefined, eventDefIds: [], workflowEventsToIgnore: [] };
}

export const AwaitWorkflowEventRequest = {
  encode(message: AwaitWorkflowEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfRunId !== undefined) {
      WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.eventDefIds) {
      WorkflowEventDefId.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.workflowEventsToIgnore) {
      WorkflowEventId.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AwaitWorkflowEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwaitWorkflowEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventDefIds.push(WorkflowEventDefId.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.workflowEventsToIgnore.push(WorkflowEventId.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AwaitWorkflowEventRequest>): AwaitWorkflowEventRequest {
    return AwaitWorkflowEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwaitWorkflowEventRequest>): AwaitWorkflowEventRequest {
    const message = createBaseAwaitWorkflowEventRequest();
    message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
      ? WfRunId.fromPartial(object.wfRunId)
      : undefined;
    message.eventDefIds = object.eventDefIds?.map((e) => WorkflowEventDefId.fromPartial(e)) || [];
    message.workflowEventsToIgnore = object.workflowEventsToIgnore?.map((e) => WorkflowEventId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchWfRunRequest(): SearchWfRunRequest {
  return {
    bookmark: undefined,
    limit: undefined,
    wfSpecName: "",
    wfSpecMajorVersion: undefined,
    wfSpecRevision: undefined,
    status: undefined,
    earliestStart: undefined,
    latestStart: undefined,
    variableFilters: [],
  };
}

export const SearchWfRunRequest = {
  encode(message: SearchWfRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.wfSpecName !== "") {
      writer.uint32(26).string(message.wfSpecName);
    }
    if (message.wfSpecMajorVersion !== undefined) {
      writer.uint32(32).int32(message.wfSpecMajorVersion);
    }
    if (message.wfSpecRevision !== undefined) {
      writer.uint32(40).int32(message.wfSpecRevision);
    }
    if (message.status !== undefined) {
      writer.uint32(48).int32(lHStatusToNumber(message.status));
    }
    if (message.earliestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.earliestStart), writer.uint32(58).fork()).ldelim();
    }
    if (message.latestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.latestStart), writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.variableFilters) {
      VariableMatch.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchWfRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchWfRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.wfSpecName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.wfSpecMajorVersion = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.wfSpecRevision = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.status = lHStatusFromJSON(reader.int32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.earliestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.latestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.variableFilters.push(VariableMatch.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchWfRunRequest>): SearchWfRunRequest {
    return SearchWfRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchWfRunRequest>): SearchWfRunRequest {
    const message = createBaseSearchWfRunRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.wfSpecName = object.wfSpecName ?? "";
    message.wfSpecMajorVersion = object.wfSpecMajorVersion ?? undefined;
    message.wfSpecRevision = object.wfSpecRevision ?? undefined;
    message.status = object.status ?? undefined;
    message.earliestStart = object.earliestStart ?? undefined;
    message.latestStart = object.latestStart ?? undefined;
    message.variableFilters = object.variableFilters?.map((e) => VariableMatch.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWfRunIdList(): WfRunIdList {
  return { results: [], bookmark: undefined };
}

export const WfRunIdList = {
  encode(message: WfRunIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      WfRunId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfRunIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfRunIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(WfRunId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WfRunIdList>): WfRunIdList {
    return WfRunIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WfRunIdList>): WfRunIdList {
    const message = createBaseWfRunIdList();
    message.results = object.results?.map((e) => WfRunId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchTaskRunRequest(): SearchTaskRunRequest {
  return {
    bookmark: undefined,
    limit: undefined,
    taskDefName: "",
    status: undefined,
    earliestStart: undefined,
    latestStart: undefined,
  };
}

export const SearchTaskRunRequest = {
  encode(message: SearchTaskRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.taskDefName !== "") {
      writer.uint32(26).string(message.taskDefName);
    }
    if (message.status !== undefined) {
      writer.uint32(32).int32(taskStatusToNumber(message.status));
    }
    if (message.earliestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.earliestStart), writer.uint32(42).fork()).ldelim();
    }
    if (message.latestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.latestStart), writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchTaskRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTaskRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.taskDefName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = taskStatusFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.earliestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.latestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchTaskRunRequest>): SearchTaskRunRequest {
    return SearchTaskRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchTaskRunRequest>): SearchTaskRunRequest {
    const message = createBaseSearchTaskRunRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.taskDefName = object.taskDefName ?? "";
    message.status = object.status ?? undefined;
    message.earliestStart = object.earliestStart ?? undefined;
    message.latestStart = object.latestStart ?? undefined;
    return message;
  },
};

function createBaseTaskRunIdList(): TaskRunIdList {
  return { results: [], bookmark: undefined };
}

export const TaskRunIdList = {
  encode(message: TaskRunIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      TaskRunId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskRunIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(TaskRunId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TaskRunIdList>): TaskRunIdList {
    return TaskRunIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunIdList>): TaskRunIdList {
    const message = createBaseTaskRunIdList();
    message.results = object.results?.map((e) => TaskRunId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchNodeRunRequest(): SearchNodeRunRequest {
  return {
    bookmark: undefined,
    limit: undefined,
    earliestStart: undefined,
    latestStart: undefined,
    nodeType: SearchNodeRunRequest_NodeType.TASK,
    status: LHStatus.STARTING,
  };
}

export const SearchNodeRunRequest = {
  encode(message: SearchNodeRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.earliestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.earliestStart), writer.uint32(26).fork()).ldelim();
    }
    if (message.latestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.latestStart), writer.uint32(34).fork()).ldelim();
    }
    if (message.nodeType !== SearchNodeRunRequest_NodeType.TASK) {
      writer.uint32(40).int32(searchNodeRunRequest_NodeTypeToNumber(message.nodeType));
    }
    if (message.status !== LHStatus.STARTING) {
      writer.uint32(48).int32(lHStatusToNumber(message.status));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchNodeRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchNodeRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.earliestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.latestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nodeType = searchNodeRunRequest_NodeTypeFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.status = lHStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchNodeRunRequest>): SearchNodeRunRequest {
    return SearchNodeRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchNodeRunRequest>): SearchNodeRunRequest {
    const message = createBaseSearchNodeRunRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.earliestStart = object.earliestStart ?? undefined;
    message.latestStart = object.latestStart ?? undefined;
    message.nodeType = object.nodeType ?? SearchNodeRunRequest_NodeType.TASK;
    message.status = object.status ?? LHStatus.STARTING;
    return message;
  },
};

function createBaseNodeRunIdList(): NodeRunIdList {
  return { results: [], bookmark: undefined };
}

export const NodeRunIdList = {
  encode(message: NodeRunIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      NodeRunId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeRunIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeRunIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(NodeRunId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NodeRunIdList>): NodeRunIdList {
    return NodeRunIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeRunIdList>): NodeRunIdList {
    const message = createBaseNodeRunIdList();
    message.results = object.results?.map((e) => NodeRunId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchUserTaskRunRequest(): SearchUserTaskRunRequest {
  return {
    bookmark: undefined,
    limit: undefined,
    status: undefined,
    userTaskDefName: undefined,
    userId: undefined,
    userGroup: undefined,
    earliestStart: undefined,
    latestStart: undefined,
  };
}

export const SearchUserTaskRunRequest = {
  encode(message: SearchUserTaskRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.status !== undefined) {
      writer.uint32(24).int32(userTaskRunStatusToNumber(message.status));
    }
    if (message.userTaskDefName !== undefined) {
      writer.uint32(34).string(message.userTaskDefName);
    }
    if (message.userId !== undefined) {
      writer.uint32(42).string(message.userId);
    }
    if (message.userGroup !== undefined) {
      writer.uint32(50).string(message.userGroup);
    }
    if (message.earliestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.earliestStart), writer.uint32(58).fork()).ldelim();
    }
    if (message.latestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.latestStart), writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchUserTaskRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchUserTaskRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.status = userTaskRunStatusFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userTaskDefName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.userGroup = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.earliestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.latestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchUserTaskRunRequest>): SearchUserTaskRunRequest {
    return SearchUserTaskRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchUserTaskRunRequest>): SearchUserTaskRunRequest {
    const message = createBaseSearchUserTaskRunRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.status = object.status ?? undefined;
    message.userTaskDefName = object.userTaskDefName ?? undefined;
    message.userId = object.userId ?? undefined;
    message.userGroup = object.userGroup ?? undefined;
    message.earliestStart = object.earliestStart ?? undefined;
    message.latestStart = object.latestStart ?? undefined;
    return message;
  },
};

function createBaseUserTaskRunIdList(): UserTaskRunIdList {
  return { results: [], bookmark: undefined };
}

export const UserTaskRunIdList = {
  encode(message: UserTaskRunIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      UserTaskRunId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskRunIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskRunIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(UserTaskRunId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<UserTaskRunIdList>): UserTaskRunIdList {
    return UserTaskRunIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskRunIdList>): UserTaskRunIdList {
    const message = createBaseUserTaskRunIdList();
    message.results = object.results?.map((e) => UserTaskRunId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchVariableRequest(): SearchVariableRequest {
  return {
    bookmark: undefined,
    limit: undefined,
    value: undefined,
    wfSpecMajorVersion: undefined,
    wfSpecRevision: undefined,
    varName: "",
    wfSpecName: "",
  };
}

export const SearchVariableRequest = {
  encode(message: SearchVariableRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.value !== undefined) {
      VariableValue.encode(message.value, writer.uint32(26).fork()).ldelim();
    }
    if (message.wfSpecMajorVersion !== undefined) {
      writer.uint32(32).int32(message.wfSpecMajorVersion);
    }
    if (message.wfSpecRevision !== undefined) {
      writer.uint32(40).int32(message.wfSpecRevision);
    }
    if (message.varName !== "") {
      writer.uint32(50).string(message.varName);
    }
    if (message.wfSpecName !== "") {
      writer.uint32(58).string(message.wfSpecName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchVariableRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchVariableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = VariableValue.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.wfSpecMajorVersion = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.wfSpecRevision = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.varName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.wfSpecName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchVariableRequest>): SearchVariableRequest {
    return SearchVariableRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchVariableRequest>): SearchVariableRequest {
    const message = createBaseSearchVariableRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableValue.fromPartial(object.value)
      : undefined;
    message.wfSpecMajorVersion = object.wfSpecMajorVersion ?? undefined;
    message.wfSpecRevision = object.wfSpecRevision ?? undefined;
    message.varName = object.varName ?? "";
    message.wfSpecName = object.wfSpecName ?? "";
    return message;
  },
};

function createBaseVariableIdList(): VariableIdList {
  return { results: [], bookmark: undefined };
}

export const VariableIdList = {
  encode(message: VariableIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      VariableId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VariableIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariableIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(VariableId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<VariableIdList>): VariableIdList {
    return VariableIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariableIdList>): VariableIdList {
    const message = createBaseVariableIdList();
    message.results = object.results?.map((e) => VariableId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchTaskDefRequest(): SearchTaskDefRequest {
  return { bookmark: undefined, limit: undefined, prefix: undefined };
}

export const SearchTaskDefRequest = {
  encode(message: SearchTaskDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.prefix !== undefined) {
      writer.uint32(26).string(message.prefix);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchTaskDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTaskDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.prefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchTaskDefRequest>): SearchTaskDefRequest {
    return SearchTaskDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchTaskDefRequest>): SearchTaskDefRequest {
    const message = createBaseSearchTaskDefRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.prefix = object.prefix ?? undefined;
    return message;
  },
};

function createBaseTaskDefIdList(): TaskDefIdList {
  return { results: [], bookmark: undefined };
}

export const TaskDefIdList = {
  encode(message: TaskDefIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      TaskDefId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskDefIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskDefIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(TaskDefId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TaskDefIdList>): TaskDefIdList {
    return TaskDefIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskDefIdList>): TaskDefIdList {
    const message = createBaseTaskDefIdList();
    message.results = object.results?.map((e) => TaskDefId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchUserTaskDefRequest(): SearchUserTaskDefRequest {
  return { bookmark: undefined, limit: undefined, prefix: undefined, name: undefined };
}

export const SearchUserTaskDefRequest = {
  encode(message: SearchUserTaskDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.prefix !== undefined) {
      writer.uint32(26).string(message.prefix);
    }
    if (message.name !== undefined) {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchUserTaskDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchUserTaskDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.prefix = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchUserTaskDefRequest>): SearchUserTaskDefRequest {
    return SearchUserTaskDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchUserTaskDefRequest>): SearchUserTaskDefRequest {
    const message = createBaseSearchUserTaskDefRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.prefix = object.prefix ?? undefined;
    message.name = object.name ?? undefined;
    return message;
  },
};

function createBaseUserTaskDefIdList(): UserTaskDefIdList {
  return { results: [], bookmark: undefined };
}

export const UserTaskDefIdList = {
  encode(message: UserTaskDefIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      UserTaskDefId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskDefIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskDefIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(UserTaskDefId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<UserTaskDefIdList>): UserTaskDefIdList {
    return UserTaskDefIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskDefIdList>): UserTaskDefIdList {
    const message = createBaseUserTaskDefIdList();
    message.results = object.results?.map((e) => UserTaskDefId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchWfSpecRequest(): SearchWfSpecRequest {
  return { bookmark: undefined, limit: undefined, name: undefined, prefix: undefined, taskDefName: undefined };
}

export const SearchWfSpecRequest = {
  encode(message: SearchWfSpecRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.prefix !== undefined) {
      writer.uint32(34).string(message.prefix);
    }
    if (message.taskDefName !== undefined) {
      writer.uint32(42).string(message.taskDefName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchWfSpecRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchWfSpecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.prefix = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.taskDefName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchWfSpecRequest>): SearchWfSpecRequest {
    return SearchWfSpecRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchWfSpecRequest>): SearchWfSpecRequest {
    const message = createBaseSearchWfSpecRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.name = object.name ?? undefined;
    message.prefix = object.prefix ?? undefined;
    message.taskDefName = object.taskDefName ?? undefined;
    return message;
  },
};

function createBaseWfSpecIdList(): WfSpecIdList {
  return { results: [], bookmark: undefined };
}

export const WfSpecIdList = {
  encode(message: WfSpecIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      WfSpecId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpecIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpecIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(WfSpecId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WfSpecIdList>): WfSpecIdList {
    return WfSpecIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WfSpecIdList>): WfSpecIdList {
    const message = createBaseWfSpecIdList();
    message.results = object.results?.map((e) => WfSpecId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchExternalEventDefRequest(): SearchExternalEventDefRequest {
  return { bookmark: undefined, limit: undefined, prefix: undefined };
}

export const SearchExternalEventDefRequest = {
  encode(message: SearchExternalEventDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.prefix !== undefined) {
      writer.uint32(26).string(message.prefix);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchExternalEventDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchExternalEventDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.prefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchExternalEventDefRequest>): SearchExternalEventDefRequest {
    return SearchExternalEventDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchExternalEventDefRequest>): SearchExternalEventDefRequest {
    const message = createBaseSearchExternalEventDefRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.prefix = object.prefix ?? undefined;
    return message;
  },
};

function createBaseExternalEventDefIdList(): ExternalEventDefIdList {
  return { results: [], bookmark: undefined };
}

export const ExternalEventDefIdList = {
  encode(message: ExternalEventDefIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      ExternalEventDefId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExternalEventDefIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalEventDefIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(ExternalEventDefId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ExternalEventDefIdList>): ExternalEventDefIdList {
    return ExternalEventDefIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalEventDefIdList>): ExternalEventDefIdList {
    const message = createBaseExternalEventDefIdList();
    message.results = object.results?.map((e) => ExternalEventDefId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchWorkflowEventDefRequest(): SearchWorkflowEventDefRequest {
  return { bookmark: undefined, limit: undefined, prefix: undefined };
}

export const SearchWorkflowEventDefRequest = {
  encode(message: SearchWorkflowEventDefRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.prefix !== undefined) {
      writer.uint32(26).string(message.prefix);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchWorkflowEventDefRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchWorkflowEventDefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.prefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchWorkflowEventDefRequest>): SearchWorkflowEventDefRequest {
    return SearchWorkflowEventDefRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchWorkflowEventDefRequest>): SearchWorkflowEventDefRequest {
    const message = createBaseSearchWorkflowEventDefRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.prefix = object.prefix ?? undefined;
    return message;
  },
};

function createBaseWorkflowEventDefIdList(): WorkflowEventDefIdList {
  return { results: [], bookmark: undefined };
}

export const WorkflowEventDefIdList = {
  encode(message: WorkflowEventDefIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      WorkflowEventDefId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowEventDefIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowEventDefIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(WorkflowEventDefId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkflowEventDefIdList>): WorkflowEventDefIdList {
    return WorkflowEventDefIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowEventDefIdList>): WorkflowEventDefIdList {
    const message = createBaseWorkflowEventDefIdList();
    message.results = object.results?.map((e) => WorkflowEventDefId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchTenantRequest(): SearchTenantRequest {
  return { limit: undefined, bookmark: undefined };
}

export const SearchTenantRequest = {
  encode(message: SearchTenantRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== undefined) {
      writer.uint32(8).int32(message.limit);
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchTenantRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTenantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchTenantRequest>): SearchTenantRequest {
    return SearchTenantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchTenantRequest>): SearchTenantRequest {
    const message = createBaseSearchTenantRequest();
    message.limit = object.limit ?? undefined;
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseTenantIdList(): TenantIdList {
  return { results: [], bookmark: undefined };
}

export const TenantIdList = {
  encode(message: TenantIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      TenantId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TenantIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTenantIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(TenantId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TenantIdList>): TenantIdList {
    return TenantIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TenantIdList>): TenantIdList {
    const message = createBaseTenantIdList();
    message.results = object.results?.map((e) => TenantId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchPrincipalRequest(): SearchPrincipalRequest {
  return {
    bookmark: undefined,
    limit: undefined,
    earliestStart: undefined,
    latestStart: undefined,
    isAdmin: undefined,
    tenantId: undefined,
  };
}

export const SearchPrincipalRequest = {
  encode(message: SearchPrincipalRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.earliestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.earliestStart), writer.uint32(26).fork()).ldelim();
    }
    if (message.latestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.latestStart), writer.uint32(34).fork()).ldelim();
    }
    if (message.isAdmin !== undefined) {
      writer.uint32(40).bool(message.isAdmin);
    }
    if (message.tenantId !== undefined) {
      writer.uint32(50).string(message.tenantId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchPrincipalRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchPrincipalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.earliestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.latestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isAdmin = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tenantId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchPrincipalRequest>): SearchPrincipalRequest {
    return SearchPrincipalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchPrincipalRequest>): SearchPrincipalRequest {
    const message = createBaseSearchPrincipalRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.earliestStart = object.earliestStart ?? undefined;
    message.latestStart = object.latestStart ?? undefined;
    message.isAdmin = object.isAdmin ?? undefined;
    message.tenantId = object.tenantId ?? undefined;
    return message;
  },
};

function createBasePrincipalIdList(): PrincipalIdList {
  return { results: [], bookmark: undefined };
}

export const PrincipalIdList = {
  encode(message: PrincipalIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      PrincipalId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PrincipalIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrincipalIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(PrincipalId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PrincipalIdList>): PrincipalIdList {
    return PrincipalIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrincipalIdList>): PrincipalIdList {
    const message = createBasePrincipalIdList();
    message.results = object.results?.map((e) => PrincipalId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchExternalEventRequest(): SearchExternalEventRequest {
  return {
    bookmark: undefined,
    limit: undefined,
    earliestStart: undefined,
    latestStart: undefined,
    externalEventDefId: undefined,
    isClaimed: undefined,
  };
}

export const SearchExternalEventRequest = {
  encode(message: SearchExternalEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.earliestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.earliestStart), writer.uint32(26).fork()).ldelim();
    }
    if (message.latestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.latestStart), writer.uint32(34).fork()).ldelim();
    }
    if (message.externalEventDefId !== undefined) {
      ExternalEventDefId.encode(message.externalEventDefId, writer.uint32(42).fork()).ldelim();
    }
    if (message.isClaimed !== undefined) {
      writer.uint32(48).bool(message.isClaimed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchExternalEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchExternalEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.earliestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.latestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalEventDefId = ExternalEventDefId.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isClaimed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchExternalEventRequest>): SearchExternalEventRequest {
    return SearchExternalEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchExternalEventRequest>): SearchExternalEventRequest {
    const message = createBaseSearchExternalEventRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.earliestStart = object.earliestStart ?? undefined;
    message.latestStart = object.latestStart ?? undefined;
    message.externalEventDefId = (object.externalEventDefId !== undefined && object.externalEventDefId !== null)
      ? ExternalEventDefId.fromPartial(object.externalEventDefId)
      : undefined;
    message.isClaimed = object.isClaimed ?? undefined;
    return message;
  },
};

function createBaseExternalEventIdList(): ExternalEventIdList {
  return { results: [], bookmark: undefined };
}

export const ExternalEventIdList = {
  encode(message: ExternalEventIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      ExternalEventId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExternalEventIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalEventIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(ExternalEventId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ExternalEventIdList>): ExternalEventIdList {
    return ExternalEventIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalEventIdList>): ExternalEventIdList {
    const message = createBaseExternalEventIdList();
    message.results = object.results?.map((e) => ExternalEventId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseSearchWorkflowEventRequest(): SearchWorkflowEventRequest {
  return {
    bookmark: undefined,
    limit: undefined,
    earliestStart: undefined,
    latestStart: undefined,
    workflowEventDefId: undefined,
  };
}

export const SearchWorkflowEventRequest = {
  encode(message: SearchWorkflowEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bookmark !== undefined) {
      writer.uint32(10).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.earliestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.earliestStart), writer.uint32(26).fork()).ldelim();
    }
    if (message.latestStart !== undefined) {
      Timestamp.encode(toTimestamp(message.latestStart), writer.uint32(34).fork()).ldelim();
    }
    if (message.workflowEventDefId !== undefined) {
      WorkflowEventDefId.encode(message.workflowEventDefId, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchWorkflowEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchWorkflowEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.earliestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.latestStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.workflowEventDefId = WorkflowEventDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchWorkflowEventRequest>): SearchWorkflowEventRequest {
    return SearchWorkflowEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchWorkflowEventRequest>): SearchWorkflowEventRequest {
    const message = createBaseSearchWorkflowEventRequest();
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    message.earliestStart = object.earliestStart ?? undefined;
    message.latestStart = object.latestStart ?? undefined;
    message.workflowEventDefId = (object.workflowEventDefId !== undefined && object.workflowEventDefId !== null)
      ? WorkflowEventDefId.fromPartial(object.workflowEventDefId)
      : undefined;
    return message;
  },
};

function createBaseWorkflowEventIdList(): WorkflowEventIdList {
  return { results: [], bookmark: undefined };
}

export const WorkflowEventIdList = {
  encode(message: WorkflowEventIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      WorkflowEventId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowEventIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowEventIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(WorkflowEventId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkflowEventIdList>): WorkflowEventIdList {
    return WorkflowEventIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowEventIdList>): WorkflowEventIdList {
    const message = createBaseWorkflowEventIdList();
    message.results = object.results?.map((e) => WorkflowEventId.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseListNodeRunsRequest(): ListNodeRunsRequest {
  return { wfRunId: undefined, threadRunNumber: undefined, bookmark: undefined, limit: undefined };
}

export const ListNodeRunsRequest = {
  encode(message: ListNodeRunsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfRunId !== undefined) {
      WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
    }
    if (message.threadRunNumber !== undefined) {
      writer.uint32(16).int32(message.threadRunNumber);
    }
    if (message.bookmark !== undefined) {
      writer.uint32(26).bytes(message.bookmark);
    }
    if (message.limit !== undefined) {
      writer.uint32(32).int32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListNodeRunsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodeRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.threadRunNumber = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListNodeRunsRequest>): ListNodeRunsRequest {
    return ListNodeRunsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodeRunsRequest>): ListNodeRunsRequest {
    const message = createBaseListNodeRunsRequest();
    message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
      ? WfRunId.fromPartial(object.wfRunId)
      : undefined;
    message.threadRunNumber = object.threadRunNumber ?? undefined;
    message.bookmark = object.bookmark ?? undefined;
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBaseNodeRunList(): NodeRunList {
  return { results: [], bookmark: undefined };
}

export const NodeRunList = {
  encode(message: NodeRunList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      NodeRun.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.bookmark !== undefined) {
      writer.uint32(18).bytes(message.bookmark);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeRunList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeRunList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(NodeRun.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bookmark = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NodeRunList>): NodeRunList {
    return NodeRunList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeRunList>): NodeRunList {
    const message = createBaseNodeRunList();
    message.results = object.results?.map((e) => NodeRun.fromPartial(e)) || [];
    message.bookmark = object.bookmark ?? undefined;
    return message;
  },
};

function createBaseListVariablesRequest(): ListVariablesRequest {
  return { wfRunId: undefined };
}

export const ListVariablesRequest = {
  encode(message: ListVariablesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfRunId !== undefined) {
      WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListVariablesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVariablesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListVariablesRequest>): ListVariablesRequest {
    return ListVariablesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVariablesRequest>): ListVariablesRequest {
    const message = createBaseListVariablesRequest();
    message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
      ? WfRunId.fromPartial(object.wfRunId)
      : undefined;
    return message;
  },
};

function createBaseVariableList(): VariableList {
  return { results: [] };
}

export const VariableList = {
  encode(message: VariableList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      Variable.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VariableList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariableList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(Variable.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<VariableList>): VariableList {
    return VariableList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariableList>): VariableList {
    const message = createBaseVariableList();
    message.results = object.results?.map((e) => Variable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListExternalEventsRequest(): ListExternalEventsRequest {
  return { wfRunId: undefined };
}

export const ListExternalEventsRequest = {
  encode(message: ListExternalEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfRunId !== undefined) {
      WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListExternalEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExternalEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListExternalEventsRequest>): ListExternalEventsRequest {
    return ListExternalEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListExternalEventsRequest>): ListExternalEventsRequest {
    const message = createBaseListExternalEventsRequest();
    message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
      ? WfRunId.fromPartial(object.wfRunId)
      : undefined;
    return message;
  },
};

function createBaseExternalEventList(): ExternalEventList {
  return { results: [] };
}

export const ExternalEventList = {
  encode(message: ExternalEventList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      ExternalEvent.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExternalEventList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalEventList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(ExternalEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ExternalEventList>): ExternalEventList {
    return ExternalEventList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalEventList>): ExternalEventList {
    const message = createBaseExternalEventList();
    message.results = object.results?.map((e) => ExternalEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListWorkflowEventsRequest(): ListWorkflowEventsRequest {
  return { wfRunId: undefined };
}

export const ListWorkflowEventsRequest = {
  encode(message: ListWorkflowEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfRunId !== undefined) {
      WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListWorkflowEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkflowEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListWorkflowEventsRequest>): ListWorkflowEventsRequest {
    return ListWorkflowEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkflowEventsRequest>): ListWorkflowEventsRequest {
    const message = createBaseListWorkflowEventsRequest();
    message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
      ? WfRunId.fromPartial(object.wfRunId)
      : undefined;
    return message;
  },
};

function createBaseWorkflowEventList(): WorkflowEventList {
  return { results: [] };
}

export const WorkflowEventList = {
  encode(message: WorkflowEventList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      WorkflowEvent.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowEventList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowEventList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(WorkflowEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkflowEventList>): WorkflowEventList {
    return WorkflowEventList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowEventList>): WorkflowEventList {
    const message = createBaseWorkflowEventList();
    message.results = object.results?.map((e) => WorkflowEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRegisterTaskWorkerRequest(): RegisterTaskWorkerRequest {
  return { taskWorkerId: "", taskDefId: undefined };
}

export const RegisterTaskWorkerRequest = {
  encode(message: RegisterTaskWorkerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskWorkerId !== "") {
      writer.uint32(10).string(message.taskWorkerId);
    }
    if (message.taskDefId !== undefined) {
      TaskDefId.encode(message.taskDefId, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterTaskWorkerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterTaskWorkerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskWorkerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskDefId = TaskDefId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RegisterTaskWorkerRequest>): RegisterTaskWorkerRequest {
    return RegisterTaskWorkerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterTaskWorkerRequest>): RegisterTaskWorkerRequest {
    const message = createBaseRegisterTaskWorkerRequest();
    message.taskWorkerId = object.taskWorkerId ?? "";
    message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
      ? TaskDefId.fromPartial(object.taskDefId)
      : undefined;
    return message;
  },
};

function createBaseTaskWorkerHeartBeatRequest(): TaskWorkerHeartBeatRequest {
  return { clientId: "", taskDefId: undefined, listenerName: "" };
}

export const TaskWorkerHeartBeatRequest = {
  encode(message: TaskWorkerHeartBeatRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.taskDefId !== undefined) {
      TaskDefId.encode(message.taskDefId, writer.uint32(18).fork()).ldelim();
    }
    if (message.listenerName !== "") {
      writer.uint32(26).string(message.listenerName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskWorkerHeartBeatRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskWorkerHeartBeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskDefId = TaskDefId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.listenerName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TaskWorkerHeartBeatRequest>): TaskWorkerHeartBeatRequest {
    return TaskWorkerHeartBeatRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskWorkerHeartBeatRequest>): TaskWorkerHeartBeatRequest {
    const message = createBaseTaskWorkerHeartBeatRequest();
    message.clientId = object.clientId ?? "";
    message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
      ? TaskDefId.fromPartial(object.taskDefId)
      : undefined;
    message.listenerName = object.listenerName ?? "";
    return message;
  },
};

function createBaseRegisterTaskWorkerResponse(): RegisterTaskWorkerResponse {
  return { yourHosts: [], isClusterHealthy: undefined };
}

export const RegisterTaskWorkerResponse = {
  encode(message: RegisterTaskWorkerResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.yourHosts) {
      LHHostInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.isClusterHealthy !== undefined) {
      writer.uint32(16).bool(message.isClusterHealthy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterTaskWorkerResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterTaskWorkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.yourHosts.push(LHHostInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isClusterHealthy = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RegisterTaskWorkerResponse>): RegisterTaskWorkerResponse {
    return RegisterTaskWorkerResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterTaskWorkerResponse>): RegisterTaskWorkerResponse {
    const message = createBaseRegisterTaskWorkerResponse();
    message.yourHosts = object.yourHosts?.map((e) => LHHostInfo.fromPartial(e)) || [];
    message.isClusterHealthy = object.isClusterHealthy ?? undefined;
    return message;
  },
};

function createBaseLHHostInfo(): LHHostInfo {
  return { host: "", port: 0 };
}

export const LHHostInfo = {
  encode(message: LHHostInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LHHostInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLHHostInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LHHostInfo>): LHHostInfo {
    return LHHostInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LHHostInfo>): LHHostInfo {
    const message = createBaseLHHostInfo();
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    return message;
  },
};

function createBasePollTaskRequest(): PollTaskRequest {
  return { taskDefId: undefined, clientId: "", taskWorkerVersion: undefined };
}

export const PollTaskRequest = {
  encode(message: PollTaskRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskDefId !== undefined) {
      TaskDefId.encode(message.taskDefId, writer.uint32(10).fork()).ldelim();
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.taskWorkerVersion !== undefined) {
      writer.uint32(26).string(message.taskWorkerVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PollTaskRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskDefId = TaskDefId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.taskWorkerVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PollTaskRequest>): PollTaskRequest {
    return PollTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PollTaskRequest>): PollTaskRequest {
    const message = createBasePollTaskRequest();
    message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
      ? TaskDefId.fromPartial(object.taskDefId)
      : undefined;
    message.clientId = object.clientId ?? "";
    message.taskWorkerVersion = object.taskWorkerVersion ?? undefined;
    return message;
  },
};

function createBaseScheduledTask(): ScheduledTask {
  return {
    taskRunId: undefined,
    taskDefId: undefined,
    attemptNumber: 0,
    variables: [],
    createdAt: undefined,
    source: undefined,
  };
}

export const ScheduledTask = {
  encode(message: ScheduledTask, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskRunId !== undefined) {
      TaskRunId.encode(message.taskRunId, writer.uint32(10).fork()).ldelim();
    }
    if (message.taskDefId !== undefined) {
      TaskDefId.encode(message.taskDefId, writer.uint32(18).fork()).ldelim();
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(24).int32(message.attemptNumber);
    }
    for (const v of message.variables) {
      VarNameAndVal.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).ldelim();
    }
    if (message.source !== undefined) {
      TaskRunSource.encode(message.source, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScheduledTask {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduledTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskRunId = TaskRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskDefId = TaskDefId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.variables.push(VarNameAndVal.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.source = TaskRunSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ScheduledTask>): ScheduledTask {
    return ScheduledTask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScheduledTask>): ScheduledTask {
    const message = createBaseScheduledTask();
    message.taskRunId = (object.taskRunId !== undefined && object.taskRunId !== null)
      ? TaskRunId.fromPartial(object.taskRunId)
      : undefined;
    message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
      ? TaskDefId.fromPartial(object.taskDefId)
      : undefined;
    message.attemptNumber = object.attemptNumber ?? 0;
    message.variables = object.variables?.map((e) => VarNameAndVal.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? undefined;
    message.source = (object.source !== undefined && object.source !== null)
      ? TaskRunSource.fromPartial(object.source)
      : undefined;
    return message;
  },
};

function createBasePollTaskResponse(): PollTaskResponse {
  return { result: undefined };
}

export const PollTaskResponse = {
  encode(message: PollTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      ScheduledTask.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PollTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = ScheduledTask.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PollTaskResponse>): PollTaskResponse {
    return PollTaskResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PollTaskResponse>): PollTaskResponse {
    const message = createBasePollTaskResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? ScheduledTask.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseReportTaskRun(): ReportTaskRun {
  return {
    taskRunId: undefined,
    time: undefined,
    status: TaskStatus.TASK_SCHEDULED,
    logOutput: undefined,
    attemptNumber: 0,
    output: undefined,
    error: undefined,
    exception: undefined,
  };
}

export const ReportTaskRun = {
  encode(message: ReportTaskRun, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskRunId !== undefined) {
      TaskRunId.encode(message.taskRunId, writer.uint32(10).fork()).ldelim();
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(18).fork()).ldelim();
    }
    if (message.status !== TaskStatus.TASK_SCHEDULED) {
      writer.uint32(24).int32(taskStatusToNumber(message.status));
    }
    if (message.logOutput !== undefined) {
      VariableValue.encode(message.logOutput, writer.uint32(42).fork()).ldelim();
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(48).int32(message.attemptNumber);
    }
    if (message.output !== undefined) {
      VariableValue.encode(message.output, writer.uint32(34).fork()).ldelim();
    }
    if (message.error !== undefined) {
      LHTaskError.encode(message.error, writer.uint32(58).fork()).ldelim();
    }
    if (message.exception !== undefined) {
      LHTaskException.encode(message.exception, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReportTaskRun {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportTaskRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskRunId = TaskRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.status = taskStatusFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.logOutput = VariableValue.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.output = VariableValue.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.error = LHTaskError.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.exception = LHTaskException.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ReportTaskRun>): ReportTaskRun {
    return ReportTaskRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportTaskRun>): ReportTaskRun {
    const message = createBaseReportTaskRun();
    message.taskRunId = (object.taskRunId !== undefined && object.taskRunId !== null)
      ? TaskRunId.fromPartial(object.taskRunId)
      : undefined;
    message.time = object.time ?? undefined;
    message.status = object.status ?? TaskStatus.TASK_SCHEDULED;
    message.logOutput = (object.logOutput !== undefined && object.logOutput !== null)
      ? VariableValue.fromPartial(object.logOutput)
      : undefined;
    message.attemptNumber = object.attemptNumber ?? 0;
    message.output = (object.output !== undefined && object.output !== null)
      ? VariableValue.fromPartial(object.output)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? LHTaskError.fromPartial(object.error)
      : undefined;
    message.exception = (object.exception !== undefined && object.exception !== null)
      ? LHTaskException.fromPartial(object.exception)
      : undefined;
    return message;
  },
};

function createBaseStopWfRunRequest(): StopWfRunRequest {
  return { wfRunId: undefined, threadRunNumber: 0 };
}

export const StopWfRunRequest = {
  encode(message: StopWfRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfRunId !== undefined) {
      WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
    }
    if (message.threadRunNumber !== 0) {
      writer.uint32(16).int32(message.threadRunNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StopWfRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopWfRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.threadRunNumber = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StopWfRunRequest>): StopWfRunRequest {
    return StopWfRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopWfRunRequest>): StopWfRunRequest {
    const message = createBaseStopWfRunRequest();
    message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
      ? WfRunId.fromPartial(object.wfRunId)
      : undefined;
    message.threadRunNumber = object.threadRunNumber ?? 0;
    return message;
  },
};

function createBaseResumeWfRunRequest(): ResumeWfRunRequest {
  return { wfRunId: undefined, threadRunNumber: 0 };
}

export const ResumeWfRunRequest = {
  encode(message: ResumeWfRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfRunId !== undefined) {
      WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
    }
    if (message.threadRunNumber !== 0) {
      writer.uint32(16).int32(message.threadRunNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResumeWfRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResumeWfRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.threadRunNumber = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ResumeWfRunRequest>): ResumeWfRunRequest {
    return ResumeWfRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResumeWfRunRequest>): ResumeWfRunRequest {
    const message = createBaseResumeWfRunRequest();
    message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
      ? WfRunId.fromPartial(object.wfRunId)
      : undefined;
    message.threadRunNumber = object.threadRunNumber ?? 0;
    return message;
  },
};

function createBaseRescueThreadRunRequest(): RescueThreadRunRequest {
  return { wfRunId: undefined, threadRunNumber: 0, skipCurrentNode: false };
}

export const RescueThreadRunRequest = {
  encode(message: RescueThreadRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfRunId !== undefined) {
      WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
    }
    if (message.threadRunNumber !== 0) {
      writer.uint32(16).int32(message.threadRunNumber);
    }
    if (message.skipCurrentNode !== false) {
      writer.uint32(24).bool(message.skipCurrentNode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RescueThreadRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRescueThreadRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.threadRunNumber = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.skipCurrentNode = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RescueThreadRunRequest>): RescueThreadRunRequest {
    return RescueThreadRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RescueThreadRunRequest>): RescueThreadRunRequest {
    const message = createBaseRescueThreadRunRequest();
    message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
      ? WfRunId.fromPartial(object.wfRunId)
      : undefined;
    message.threadRunNumber = object.threadRunNumber ?? 0;
    message.skipCurrentNode = object.skipCurrentNode ?? false;
    return message;
  },
};

function createBaseTaskDefMetricsQueryRequest(): TaskDefMetricsQueryRequest {
  return { windowStart: undefined, windowType: MetricsWindowLength.MINUTES_5, taskDefName: undefined };
}

export const TaskDefMetricsQueryRequest = {
  encode(message: TaskDefMetricsQueryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.windowStart !== undefined) {
      Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(10).fork()).ldelim();
    }
    if (message.windowType !== MetricsWindowLength.MINUTES_5) {
      writer.uint32(16).int32(metricsWindowLengthToNumber(message.windowType));
    }
    if (message.taskDefName !== undefined) {
      writer.uint32(26).string(message.taskDefName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskDefMetricsQueryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskDefMetricsQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.windowStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.windowType = metricsWindowLengthFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.taskDefName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TaskDefMetricsQueryRequest>): TaskDefMetricsQueryRequest {
    return TaskDefMetricsQueryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskDefMetricsQueryRequest>): TaskDefMetricsQueryRequest {
    const message = createBaseTaskDefMetricsQueryRequest();
    message.windowStart = object.windowStart ?? undefined;
    message.windowType = object.windowType ?? MetricsWindowLength.MINUTES_5;
    message.taskDefName = object.taskDefName ?? undefined;
    return message;
  },
};

function createBaseListTaskMetricsRequest(): ListTaskMetricsRequest {
  return {
    taskDefId: undefined,
    lastWindowStart: undefined,
    windowLength: MetricsWindowLength.MINUTES_5,
    numWindows: 0,
  };
}

export const ListTaskMetricsRequest = {
  encode(message: ListTaskMetricsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskDefId !== undefined) {
      TaskDefId.encode(message.taskDefId, writer.uint32(10).fork()).ldelim();
    }
    if (message.lastWindowStart !== undefined) {
      Timestamp.encode(toTimestamp(message.lastWindowStart), writer.uint32(18).fork()).ldelim();
    }
    if (message.windowLength !== MetricsWindowLength.MINUTES_5) {
      writer.uint32(24).int32(metricsWindowLengthToNumber(message.windowLength));
    }
    if (message.numWindows !== 0) {
      writer.uint32(32).int32(message.numWindows);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTaskMetricsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTaskMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskDefId = TaskDefId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastWindowStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.windowLength = metricsWindowLengthFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.numWindows = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListTaskMetricsRequest>): ListTaskMetricsRequest {
    return ListTaskMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTaskMetricsRequest>): ListTaskMetricsRequest {
    const message = createBaseListTaskMetricsRequest();
    message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
      ? TaskDefId.fromPartial(object.taskDefId)
      : undefined;
    message.lastWindowStart = object.lastWindowStart ?? undefined;
    message.windowLength = object.windowLength ?? MetricsWindowLength.MINUTES_5;
    message.numWindows = object.numWindows ?? 0;
    return message;
  },
};

function createBaseListTaskMetricsResponse(): ListTaskMetricsResponse {
  return { results: [] };
}

export const ListTaskMetricsResponse = {
  encode(message: ListTaskMetricsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      TaskDefMetrics.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTaskMetricsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTaskMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(TaskDefMetrics.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListTaskMetricsResponse>): ListTaskMetricsResponse {
    return ListTaskMetricsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTaskMetricsResponse>): ListTaskMetricsResponse {
    const message = createBaseListTaskMetricsResponse();
    message.results = object.results?.map((e) => TaskDefMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWfSpecMetricsQueryRequest(): WfSpecMetricsQueryRequest {
  return { wfSpecId: undefined, windowStart: undefined, windowLength: MetricsWindowLength.MINUTES_5 };
}

export const WfSpecMetricsQueryRequest = {
  encode(message: WfSpecMetricsQueryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpecId !== undefined) {
      WfSpecId.encode(message.wfSpecId, writer.uint32(10).fork()).ldelim();
    }
    if (message.windowStart !== undefined) {
      Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(18).fork()).ldelim();
    }
    if (message.windowLength !== MetricsWindowLength.MINUTES_5) {
      writer.uint32(24).int32(metricsWindowLengthToNumber(message.windowLength));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpecMetricsQueryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpecMetricsQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpecId = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.windowStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.windowLength = metricsWindowLengthFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WfSpecMetricsQueryRequest>): WfSpecMetricsQueryRequest {
    return WfSpecMetricsQueryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WfSpecMetricsQueryRequest>): WfSpecMetricsQueryRequest {
    const message = createBaseWfSpecMetricsQueryRequest();
    message.wfSpecId = (object.wfSpecId !== undefined && object.wfSpecId !== null)
      ? WfSpecId.fromPartial(object.wfSpecId)
      : undefined;
    message.windowStart = object.windowStart ?? undefined;
    message.windowLength = object.windowLength ?? MetricsWindowLength.MINUTES_5;
    return message;
  },
};

function createBaseListWfMetricsRequest(): ListWfMetricsRequest {
  return {
    wfSpecId: undefined,
    lastWindowStart: undefined,
    windowLength: MetricsWindowLength.MINUTES_5,
    numWindows: 0,
  };
}

export const ListWfMetricsRequest = {
  encode(message: ListWfMetricsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpecId !== undefined) {
      WfSpecId.encode(message.wfSpecId, writer.uint32(10).fork()).ldelim();
    }
    if (message.lastWindowStart !== undefined) {
      Timestamp.encode(toTimestamp(message.lastWindowStart), writer.uint32(18).fork()).ldelim();
    }
    if (message.windowLength !== MetricsWindowLength.MINUTES_5) {
      writer.uint32(24).int32(metricsWindowLengthToNumber(message.windowLength));
    }
    if (message.numWindows !== 0) {
      writer.uint32(32).int32(message.numWindows);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListWfMetricsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWfMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpecId = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastWindowStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.windowLength = metricsWindowLengthFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.numWindows = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListWfMetricsRequest>): ListWfMetricsRequest {
    return ListWfMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWfMetricsRequest>): ListWfMetricsRequest {
    const message = createBaseListWfMetricsRequest();
    message.wfSpecId = (object.wfSpecId !== undefined && object.wfSpecId !== null)
      ? WfSpecId.fromPartial(object.wfSpecId)
      : undefined;
    message.lastWindowStart = object.lastWindowStart ?? undefined;
    message.windowLength = object.windowLength ?? MetricsWindowLength.MINUTES_5;
    message.numWindows = object.numWindows ?? 0;
    return message;
  },
};

function createBaseListWfMetricsResponse(): ListWfMetricsResponse {
  return { results: [] };
}

export const ListWfMetricsResponse = {
  encode(message: ListWfMetricsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      WfSpecMetrics.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListWfMetricsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWfMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(WfSpecMetrics.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListWfMetricsResponse>): ListWfMetricsResponse {
    return ListWfMetricsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWfMetricsResponse>): ListWfMetricsResponse {
    const message = createBaseListWfMetricsResponse();
    message.results = object.results?.map((e) => WfSpecMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTaskDefMetrics(): TaskDefMetrics {
  return {
    taskDefId: undefined,
    windowStart: undefined,
    type: MetricsWindowLength.MINUTES_5,
    scheduleToStartMax: 0,
    scheduleToStartAvg: 0,
    startToCompleteMax: 0,
    startToCompleteAvg: 0,
    totalCompleted: 0,
    totalErrored: 0,
    totalStarted: 0,
    totalScheduled: 0,
  };
}

export const TaskDefMetrics = {
  encode(message: TaskDefMetrics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskDefId !== undefined) {
      TaskDefId.encode(message.taskDefId, writer.uint32(10).fork()).ldelim();
    }
    if (message.windowStart !== undefined) {
      Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(18).fork()).ldelim();
    }
    if (message.type !== MetricsWindowLength.MINUTES_5) {
      writer.uint32(24).int32(metricsWindowLengthToNumber(message.type));
    }
    if (message.scheduleToStartMax !== 0) {
      writer.uint32(32).int64(message.scheduleToStartMax);
    }
    if (message.scheduleToStartAvg !== 0) {
      writer.uint32(40).int64(message.scheduleToStartAvg);
    }
    if (message.startToCompleteMax !== 0) {
      writer.uint32(48).int64(message.startToCompleteMax);
    }
    if (message.startToCompleteAvg !== 0) {
      writer.uint32(56).int64(message.startToCompleteAvg);
    }
    if (message.totalCompleted !== 0) {
      writer.uint32(64).int64(message.totalCompleted);
    }
    if (message.totalErrored !== 0) {
      writer.uint32(72).int64(message.totalErrored);
    }
    if (message.totalStarted !== 0) {
      writer.uint32(80).int64(message.totalStarted);
    }
    if (message.totalScheduled !== 0) {
      writer.uint32(88).int64(message.totalScheduled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskDefMetrics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskDefMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskDefId = TaskDefId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.windowStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = metricsWindowLengthFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.scheduleToStartMax = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.scheduleToStartAvg = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.startToCompleteMax = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.startToCompleteAvg = longToNumber(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.totalCompleted = longToNumber(reader.int64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.totalErrored = longToNumber(reader.int64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.totalStarted = longToNumber(reader.int64() as Long);
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.totalScheduled = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TaskDefMetrics>): TaskDefMetrics {
    return TaskDefMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskDefMetrics>): TaskDefMetrics {
    const message = createBaseTaskDefMetrics();
    message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
      ? TaskDefId.fromPartial(object.taskDefId)
      : undefined;
    message.windowStart = object.windowStart ?? undefined;
    message.type = object.type ?? MetricsWindowLength.MINUTES_5;
    message.scheduleToStartMax = object.scheduleToStartMax ?? 0;
    message.scheduleToStartAvg = object.scheduleToStartAvg ?? 0;
    message.startToCompleteMax = object.startToCompleteMax ?? 0;
    message.startToCompleteAvg = object.startToCompleteAvg ?? 0;
    message.totalCompleted = object.totalCompleted ?? 0;
    message.totalErrored = object.totalErrored ?? 0;
    message.totalStarted = object.totalStarted ?? 0;
    message.totalScheduled = object.totalScheduled ?? 0;
    return message;
  },
};

function createBaseWfSpecMetrics(): WfSpecMetrics {
  return {
    wfSpecId: undefined,
    windowStart: undefined,
    type: MetricsWindowLength.MINUTES_5,
    totalStarted: 0,
    totalCompleted: 0,
    totalErrored: 0,
    startToCompleteMax: 0,
    startToCompleteAvg: 0,
  };
}

export const WfSpecMetrics = {
  encode(message: WfSpecMetrics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpecId !== undefined) {
      WfSpecId.encode(message.wfSpecId, writer.uint32(10).fork()).ldelim();
    }
    if (message.windowStart !== undefined) {
      Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(18).fork()).ldelim();
    }
    if (message.type !== MetricsWindowLength.MINUTES_5) {
      writer.uint32(24).int32(metricsWindowLengthToNumber(message.type));
    }
    if (message.totalStarted !== 0) {
      writer.uint32(32).int64(message.totalStarted);
    }
    if (message.totalCompleted !== 0) {
      writer.uint32(40).int64(message.totalCompleted);
    }
    if (message.totalErrored !== 0) {
      writer.uint32(48).int64(message.totalErrored);
    }
    if (message.startToCompleteMax !== 0) {
      writer.uint32(56).int64(message.startToCompleteMax);
    }
    if (message.startToCompleteAvg !== 0) {
      writer.uint32(64).int64(message.startToCompleteAvg);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpecMetrics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpecMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpecId = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.windowStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = metricsWindowLengthFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalStarted = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalCompleted = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalErrored = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.startToCompleteMax = longToNumber(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.startToCompleteAvg = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WfSpecMetrics>): WfSpecMetrics {
    return WfSpecMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WfSpecMetrics>): WfSpecMetrics {
    const message = createBaseWfSpecMetrics();
    message.wfSpecId = (object.wfSpecId !== undefined && object.wfSpecId !== null)
      ? WfSpecId.fromPartial(object.wfSpecId)
      : undefined;
    message.windowStart = object.windowStart ?? undefined;
    message.type = object.type ?? MetricsWindowLength.MINUTES_5;
    message.totalStarted = object.totalStarted ?? 0;
    message.totalCompleted = object.totalCompleted ?? 0;
    message.totalErrored = object.totalErrored ?? 0;
    message.startToCompleteMax = object.startToCompleteMax ?? 0;
    message.startToCompleteAvg = object.startToCompleteAvg ?? 0;
    return message;
  },
};

function createBaseListUserTaskRunRequest(): ListUserTaskRunRequest {
  return { wfRunId: undefined };
}

export const ListUserTaskRunRequest = {
  encode(message: ListUserTaskRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfRunId !== undefined) {
      WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUserTaskRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserTaskRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListUserTaskRunRequest>): ListUserTaskRunRequest {
    return ListUserTaskRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUserTaskRunRequest>): ListUserTaskRunRequest {
    const message = createBaseListUserTaskRunRequest();
    message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
      ? WfRunId.fromPartial(object.wfRunId)
      : undefined;
    return message;
  },
};

function createBaseUserTaskRunList(): UserTaskRunList {
  return { results: [] };
}

export const UserTaskRunList = {
  encode(message: UserTaskRunList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      UserTaskRun.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskRunList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskRunList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(UserTaskRun.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<UserTaskRunList>): UserTaskRunList {
    return UserTaskRunList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskRunList>): UserTaskRunList {
    const message = createBaseUserTaskRunList();
    message.results = object.results?.map((e) => UserTaskRun.fromPartial(e)) || [];
    return message;
  },
};

function createBaseScheduledWfRunIdList(): ScheduledWfRunIdList {
  return { results: [] };
}

export const ScheduledWfRunIdList = {
  encode(message: ScheduledWfRunIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      ScheduledWfRunId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScheduledWfRunIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduledWfRunIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(ScheduledWfRunId.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ScheduledWfRunIdList>): ScheduledWfRunIdList {
    return ScheduledWfRunIdList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScheduledWfRunIdList>): ScheduledWfRunIdList {
    const message = createBaseScheduledWfRunIdList();
    message.results = object.results?.map((e) => ScheduledWfRunId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchScheduledWfRunRequest(): SearchScheduledWfRunRequest {
  return { wfSpecName: "", majorVersion: undefined, revision: undefined };
}

export const SearchScheduledWfRunRequest = {
  encode(message: SearchScheduledWfRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpecName !== "") {
      writer.uint32(10).string(message.wfSpecName);
    }
    if (message.majorVersion !== undefined) {
      writer.uint32(16).int32(message.majorVersion);
    }
    if (message.revision !== undefined) {
      writer.uint32(24).int32(message.revision);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchScheduledWfRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchScheduledWfRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpecName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.majorVersion = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.revision = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SearchScheduledWfRunRequest>): SearchScheduledWfRunRequest {
    return SearchScheduledWfRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchScheduledWfRunRequest>): SearchScheduledWfRunRequest {
    const message = createBaseSearchScheduledWfRunRequest();
    message.wfSpecName = object.wfSpecName ?? "";
    message.majorVersion = object.majorVersion ?? undefined;
    message.revision = object.revision ?? undefined;
    return message;
  },
};

function createBaseTaskWorkerMetadata(): TaskWorkerMetadata {
  return { taskWorkerId: "", latestHeartbeat: undefined, hosts: [] };
}

export const TaskWorkerMetadata = {
  encode(message: TaskWorkerMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskWorkerId !== "") {
      writer.uint32(10).string(message.taskWorkerId);
    }
    if (message.latestHeartbeat !== undefined) {
      Timestamp.encode(toTimestamp(message.latestHeartbeat), writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.hosts) {
      LHHostInfo.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskWorkerMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskWorkerMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskWorkerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestHeartbeat = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hosts.push(LHHostInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TaskWorkerMetadata>): TaskWorkerMetadata {
    return TaskWorkerMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskWorkerMetadata>): TaskWorkerMetadata {
    const message = createBaseTaskWorkerMetadata();
    message.taskWorkerId = object.taskWorkerId ?? "";
    message.latestHeartbeat = object.latestHeartbeat ?? undefined;
    message.hosts = object.hosts?.map((e) => LHHostInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTaskWorkerGroup(): TaskWorkerGroup {
  return { id: undefined, createdAt: undefined, taskWorkers: {} };
}

export const TaskWorkerGroup = {
  encode(message: TaskWorkerGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      TaskWorkerGroupId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.taskWorkers).forEach(([key, value]) => {
      TaskWorkerGroup_TaskWorkersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskWorkerGroup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskWorkerGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = TaskWorkerGroupId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = TaskWorkerGroup_TaskWorkersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.taskWorkers[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TaskWorkerGroup>): TaskWorkerGroup {
    return TaskWorkerGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskWorkerGroup>): TaskWorkerGroup {
    const message = createBaseTaskWorkerGroup();
    message.id = (object.id !== undefined && object.id !== null) ? TaskWorkerGroupId.fromPartial(object.id) : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.taskWorkers = Object.entries(object.taskWorkers ?? {}).reduce<{ [key: string]: TaskWorkerMetadata }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = TaskWorkerMetadata.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTaskWorkerGroup_TaskWorkersEntry(): TaskWorkerGroup_TaskWorkersEntry {
  return { key: "", value: undefined };
}

export const TaskWorkerGroup_TaskWorkersEntry = {
  encode(message: TaskWorkerGroup_TaskWorkersEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TaskWorkerMetadata.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskWorkerGroup_TaskWorkersEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskWorkerGroup_TaskWorkersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TaskWorkerMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TaskWorkerGroup_TaskWorkersEntry>): TaskWorkerGroup_TaskWorkersEntry {
    return TaskWorkerGroup_TaskWorkersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskWorkerGroup_TaskWorkersEntry>): TaskWorkerGroup_TaskWorkersEntry {
    const message = createBaseTaskWorkerGroup_TaskWorkersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TaskWorkerMetadata.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseListTaskRunsRequest(): ListTaskRunsRequest {
  return { wfRunId: undefined };
}

export const ListTaskRunsRequest = {
  encode(message: ListTaskRunsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfRunId !== undefined) {
      WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTaskRunsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTaskRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfRunId = WfRunId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListTaskRunsRequest>): ListTaskRunsRequest {
    return ListTaskRunsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTaskRunsRequest>): ListTaskRunsRequest {
    const message = createBaseListTaskRunsRequest();
    message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
      ? WfRunId.fromPartial(object.wfRunId)
      : undefined;
    return message;
  },
};

function createBaseTaskRunList(): TaskRunList {
  return { results: [] };
}

export const TaskRunList = {
  encode(message: TaskRunList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      TaskRun.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskRunList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(TaskRun.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TaskRunList>): TaskRunList {
    return TaskRunList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunList>): TaskRunList {
    const message = createBaseTaskRunList();
    message.results = object.results?.map((e) => TaskRun.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMigrateWfSpecRequest(): MigrateWfSpecRequest {
  return { oldWfSpec: undefined, migration: undefined };
}

export const MigrateWfSpecRequest = {
  encode(message: MigrateWfSpecRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.oldWfSpec !== undefined) {
      WfSpecId.encode(message.oldWfSpec, writer.uint32(10).fork()).ldelim();
    }
    if (message.migration !== undefined) {
      WfSpecVersionMigration.encode(message.migration, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MigrateWfSpecRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrateWfSpecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.oldWfSpec = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.migration = WfSpecVersionMigration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MigrateWfSpecRequest>): MigrateWfSpecRequest {
    return MigrateWfSpecRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigrateWfSpecRequest>): MigrateWfSpecRequest {
    const message = createBaseMigrateWfSpecRequest();
    message.oldWfSpec = (object.oldWfSpec !== undefined && object.oldWfSpec !== null)
      ? WfSpecId.fromPartial(object.oldWfSpec)
      : undefined;
    message.migration = (object.migration !== undefined && object.migration !== null)
      ? WfSpecVersionMigration.fromPartial(object.migration)
      : undefined;
    return message;
  },
};

function createBaseGetLatestWfSpecRequest(): GetLatestWfSpecRequest {
  return { name: "", majorVersion: undefined };
}

export const GetLatestWfSpecRequest = {
  encode(message: GetLatestWfSpecRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.majorVersion !== undefined) {
      writer.uint32(16).int32(message.majorVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLatestWfSpecRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestWfSpecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.majorVersion = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetLatestWfSpecRequest>): GetLatestWfSpecRequest {
    return GetLatestWfSpecRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLatestWfSpecRequest>): GetLatestWfSpecRequest {
    const message = createBaseGetLatestWfSpecRequest();
    message.name = object.name ?? "";
    message.majorVersion = object.majorVersion ?? undefined;
    return message;
  },
};

function createBaseServerVersion(): ServerVersion {
  return { majorVersion: 0, minorVersion: 0, patchVersion: 0, preReleaseIdentifier: undefined };
}

export const ServerVersion = {
  encode(message: ServerVersion, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.majorVersion !== 0) {
      writer.uint32(8).int32(message.majorVersion);
    }
    if (message.minorVersion !== 0) {
      writer.uint32(16).int32(message.minorVersion);
    }
    if (message.patchVersion !== 0) {
      writer.uint32(24).int32(message.patchVersion);
    }
    if (message.preReleaseIdentifier !== undefined) {
      writer.uint32(34).string(message.preReleaseIdentifier);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServerVersion {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.majorVersion = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minorVersion = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.patchVersion = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.preReleaseIdentifier = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ServerVersion>): ServerVersion {
    return ServerVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServerVersion>): ServerVersion {
    const message = createBaseServerVersion();
    message.majorVersion = object.majorVersion ?? 0;
    message.minorVersion = object.minorVersion ?? 0;
    message.patchVersion = object.patchVersion ?? 0;
    message.preReleaseIdentifier = object.preReleaseIdentifier ?? undefined;
    return message;
  },
};

export type LittleHorseDefinition = typeof LittleHorseDefinition;
export const LittleHorseDefinition = {
  name: "LittleHorse",
  fullName: "littlehorse.LittleHorse",
  methods: {
    /** Creates a TaskDef. */
    putTaskDef: {
      name: "PutTaskDef",
      requestType: PutTaskDefRequest,
      requestStream: false,
      responseType: TaskDef,
      responseStream: false,
      options: {},
    },
    /** Gets a TaskDef. */
    getTaskDef: {
      name: "GetTaskDef",
      requestType: TaskDefId,
      requestStream: false,
      responseType: TaskDef,
      responseStream: false,
      options: {},
    },
    /** Gets the registered task worker group associated with a specific TaskDef. */
    getTaskWorkerGroup: {
      name: "GetTaskWorkerGroup",
      requestType: TaskDefId,
      requestStream: false,
      responseType: TaskWorkerGroup,
      responseStream: false,
      options: {},
    },
    /** Creates an ExternalEventDef. */
    putExternalEventDef: {
      name: "PutExternalEventDef",
      requestType: PutExternalEventDefRequest,
      requestStream: false,
      responseType: ExternalEventDef,
      responseStream: false,
      options: {},
    },
    /** Gets an ExternalEventDef. */
    getExternalEventDef: {
      name: "GetExternalEventDef",
      requestType: ExternalEventDefId,
      requestStream: false,
      responseType: ExternalEventDef,
      responseStream: false,
      options: {},
    },
    /** Creates a WorkflowEventDef. */
    putWorkflowEventDef: {
      name: "PutWorkflowEventDef",
      requestType: PutWorkflowEventDefRequest,
      requestStream: false,
      responseType: WorkflowEventDef,
      responseStream: false,
      options: {},
    },
    /** Creates a WfSpec. */
    putWfSpec: {
      name: "PutWfSpec",
      requestType: PutWfSpecRequest,
      requestStream: false,
      responseType: WfSpec,
      responseStream: false,
      options: {},
    },
    /** Gets a WfSpec. */
    getWfSpec: {
      name: "GetWfSpec",
      requestType: WfSpecId,
      requestStream: false,
      responseType: WfSpec,
      responseStream: false,
      options: {},
    },
    /** Returns the latest WfSpec with a specified name (and optionally a specified Major Version). */
    getLatestWfSpec: {
      name: "GetLatestWfSpec",
      requestType: GetLatestWfSpecRequest,
      requestStream: false,
      responseType: WfSpec,
      responseStream: false,
      options: {},
    },
    /**
     * EXPERIMENTAL: Migrates all WfRun's from one version of a WfSpec onto a newer version of the
     * same WfSpec. This is useful for long-running WfRun's (eg. a 60-day marketing campaign) where
     * you must update WfRun's that are in the RUNNING state rather than allowing them to run to
     * completion.
     *
     * As of 0.7.2, this feature is only partially implemented.
     */
    migrateWfSpec: {
      name: "MigrateWfSpec",
      requestType: MigrateWfSpecRequest,
      requestStream: false,
      responseType: WfSpec,
      responseStream: false,
      options: {},
    },
    /** Creates a UserTaskDef. */
    putUserTaskDef: {
      name: "PutUserTaskDef",
      requestType: PutUserTaskDefRequest,
      requestStream: false,
      responseType: UserTaskDef,
      responseStream: false,
      options: {},
    },
    /**
     * Gets a specific UserTaskDef.
     *
     * This RPC is highly useful for applications built around
     * User Tasks. For example, a UI that dynamically displays form fields based on the User Task
     * might first receive a UserTaskRun, then use that UserTaskRun to look up the UserTaskDef.
     * The frontend would inspect the UserTaskDef and display a form field on the browser page
     * for each field in the UserTaskDef.
     */
    getUserTaskDef: {
      name: "GetUserTaskDef",
      requestType: UserTaskDefId,
      requestStream: false,
      responseType: UserTaskDef,
      responseStream: false,
      options: {},
    },
    /** Returns the most recent UserTaskDef with a specific name. */
    getLatestUserTaskDef: {
      name: "GetLatestUserTaskDef",
      requestType: GetLatestUserTaskDefRequest,
      requestStream: false,
      responseType: UserTaskDef,
      responseStream: false,
      options: {},
    },
    /** Runs a WfSpec to create a WfRun. */
    runWf: {
      name: "RunWf",
      requestType: RunWfRequest,
      requestStream: false,
      responseType: WfRun,
      responseStream: false,
      options: {},
    },
    /** Schedule repeated WfRun based on a cron expression */
    scheduleWf: {
      name: "ScheduleWf",
      requestType: ScheduleWfRequest,
      requestStream: false,
      responseType: ScheduledWfRun,
      responseStream: false,
      options: {},
    },
    /** Search for existing schedules */
    searchScheduledWfRun: {
      name: "SearchScheduledWfRun",
      requestType: SearchScheduledWfRunRequest,
      requestStream: false,
      responseType: ScheduledWfRunIdList,
      responseStream: false,
      options: {},
    },
    /** Find a specific ScheduledWfRun */
    getScheduledWfRun: {
      name: "GetScheduledWfRun",
      requestType: ScheduledWfRunId,
      requestStream: false,
      responseType: ScheduledWfRun,
      responseStream: false,
      options: {},
    },
    /**
     * Gets a WfRun. Although useful for development and debugging, this RPC is not often
     * used by applications.
     */
    getWfRun: {
      name: "GetWfRun",
      requestType: WfRunId,
      requestStream: false,
      responseType: WfRun,
      responseStream: false,
      options: {},
    },
    /**
     * Loads a specific UserTaskRun. It includes information about to whom the UserTask is
     * currently assigned, history of assignments and reassignments, and any context for that
     * UserTaskRun which is specific to the WfRun.
     */
    getUserTaskRun: {
      name: "GetUserTaskRun",
      requestType: UserTaskRunId,
      requestStream: false,
      responseType: UserTaskRun,
      responseStream: false,
      options: {},
    },
    /**
     * Change the ownership of a UserTaskRun to a new userId, userGroup, or both. The
     * action will be reflected in your next call to SearchUserTaskRun. This RPC is useful for
     * applications that are using User Tasks to build an internal task-list and wish to
     * administer the tasks.
     */
    assignUserTaskRun: {
      name: "AssignUserTaskRun",
      requestType: AssignUserTaskRunRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /**
     * Completes a UserTaskRun. Includes the results of the UserTaskRun, the UserTaskRun Id, and
     * the userId of the user who completes the UserTaskRun. Results in the UserTask NodeRun being
     * completed, and unblocks the associated ThreadRun in the WfRun.
     *
     * This RPC is highly useful for applications built around a WfSpec that uses USER_TASK nodes.
     */
    completeUserTaskRun: {
      name: "CompleteUserTaskRun",
      requestType: CompleteUserTaskRunRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Cancels a UserTaskRun. This will result in an EXCEPTION being propagated to the WfRun. */
    cancelUserTaskRun: {
      name: "CancelUserTaskRun",
      requestType: CancelUserTaskRunRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /**
     * Saves the results of a UserTaskRun and logs who saved the content.<br/>
     *
     * <li> Throws FAILED_PRECONDITION if the UserTaskRun is in the `DONE` or `CANCELLED` state.</li>
     * <li> If `policy` is set to `FAIL_IF_CLAIMED_BY_OTHER`, returns `FAILED_PRECONDITION` if the
     * `user_id` field of the `UserTaskRun` does not match the `user_id` of the request.</li>
     */
    saveUserTaskRunProgress: {
      name: "SaveUserTaskRunProgress",
      requestType: SaveUserTaskRunProgressRequest,
      requestStream: false,
      responseType: UserTaskRun,
      responseStream: false,
      options: {},
    },
    /**
     * Lists all UserTaskRun's for a specific WfRun. Can be useful when using a WfRun
     * to model an entity.
     */
    listUserTaskRuns: {
      name: "ListUserTaskRuns",
      requestType: ListUserTaskRunRequest,
      requestStream: false,
      responseType: UserTaskRunList,
      responseStream: false,
      options: {},
    },
    /** Gets a specific NodeRun. */
    getNodeRun: {
      name: "GetNodeRun",
      requestType: NodeRunId,
      requestStream: false,
      responseType: NodeRun,
      responseStream: false,
      options: {},
    },
    /** Lists all NodeRun's for a specific WfRun. */
    listNodeRuns: {
      name: "ListNodeRuns",
      requestType: ListNodeRunsRequest,
      requestStream: false,
      responseType: NodeRunList,
      responseStream: false,
      options: {},
    },
    /** Gets a specific TaskRun. */
    getTaskRun: {
      name: "GetTaskRun",
      requestType: TaskRunId,
      requestStream: false,
      responseType: TaskRun,
      responseStream: false,
      options: {},
    },
    /** Lists all TaskRun's for a specific WfRun. */
    listTaskRuns: {
      name: "ListTaskRuns",
      requestType: ListTaskRunsRequest,
      requestStream: false,
      responseType: TaskRunList,
      responseStream: false,
      options: {},
    },
    /**
     * Get the value of a specific Variable. When using a WfRun to model an entity, this
     * RPC is useful for retrieving information. It is equivalent to looking up the value of a
     * column for a specific row in a SQL table.
     */
    getVariable: {
      name: "GetVariable",
      requestType: VariableId,
      requestStream: false,
      responseType: Variable,
      responseStream: false,
      options: {},
    },
    /** List all Variables from a WfRun. */
    listVariables: {
      name: "ListVariables",
      requestType: ListVariablesRequest,
      requestStream: false,
      responseType: VariableList,
      responseStream: false,
      options: {},
    },
    /** Post an ExternalEvent. This RPC is highly useful for */
    putExternalEvent: {
      name: "PutExternalEvent",
      requestType: PutExternalEventRequest,
      requestStream: false,
      responseType: ExternalEvent,
      responseStream: false,
      options: {},
    },
    /** Get a specific ExternalEvent. */
    getExternalEvent: {
      name: "GetExternalEvent",
      requestType: ExternalEventId,
      requestStream: false,
      responseType: ExternalEvent,
      responseStream: false,
      options: {},
    },
    /**
     * Waits for a WorkflowEvent to be thrown by a given WfRun. Returns immediately if a matching
     * WorkflowEvent has already been thrown; throws a DEADLINE_EXCEEDED error if the WorkflowEvent
     * is not thrown before the deadline specified by the client.
     *
     * To specify the deadline, the client should use GRPC deadlines.
     */
    awaitWorkflowEvent: {
      name: "AwaitWorkflowEvent",
      requestType: AwaitWorkflowEventRequest,
      requestStream: false,
      responseType: WorkflowEvent,
      responseStream: false,
      options: {},
    },
    /** Get a specific WorkflowEventDef. */
    getWorkflowEventDef: {
      name: "GetWorkflowEventDef",
      requestType: WorkflowEventDefId,
      requestStream: false,
      responseType: WorkflowEventDef,
      responseStream: false,
      options: {},
    },
    /** Get a specific WorkflowEvent. */
    getWorkflowEvent: {
      name: "GetWorkflowEvent",
      requestType: WorkflowEventId,
      requestStream: false,
      responseType: WorkflowEvent,
      responseStream: false,
      options: {},
    },
    /** List ExternalEvent's for a specific WfRun. */
    listExternalEvents: {
      name: "ListExternalEvents",
      requestType: ListExternalEventsRequest,
      requestStream: false,
      responseType: ExternalEventList,
      responseStream: false,
      options: {},
    },
    /** List WorkflowEvent's for a specific WfRun. */
    listWorkflowEvents: {
      name: "ListWorkflowEvents",
      requestType: ListWorkflowEventsRequest,
      requestStream: false,
      responseType: WorkflowEventList,
      responseStream: false,
      options: {},
    },
    /**
     * Search for WfRun's. This RPC is highly useful for applications that store data
     * in LittleHorse and need to find a specific WfRun based on certain indexed fields.
     */
    searchWfRun: {
      name: "SearchWfRun",
      requestType: SearchWfRunRequest,
      requestStream: false,
      responseType: WfRunIdList,
      responseStream: false,
      options: {},
    },
    /**
     * Search for NodeRun's. This RPC is useful for monitoring and finding bugs in
     * your workflows or Task Workers.
     */
    searchNodeRun: {
      name: "SearchNodeRun",
      requestType: SearchNodeRunRequest,
      requestStream: false,
      responseType: NodeRunIdList,
      responseStream: false,
      options: {},
    },
    /** Search for TaskRun's. This RPC is useful for finding bugs in your Task Workers. */
    searchTaskRun: {
      name: "SearchTaskRun",
      requestType: SearchTaskRunRequest,
      requestStream: false,
      responseType: TaskRunIdList,
      responseStream: false,
      options: {},
    },
    /**
     * Search for UserTaskRun's. This RPC is highly useful for applications that connect
     * human end-users to LittleHorse: it enables you to find all tasks assigned to a specific
     * person or group of people.
     */
    searchUserTaskRun: {
      name: "SearchUserTaskRun",
      requestType: SearchUserTaskRunRequest,
      requestStream: false,
      responseType: UserTaskRunIdList,
      responseStream: false,
      options: {},
    },
    /**
     * Search for Variable's. This RPC is highly useful for applications that store data
     * in LittleHorse and need to find a specific WfRun based on certain indexed fields.
     */
    searchVariable: {
      name: "SearchVariable",
      requestType: SearchVariableRequest,
      requestStream: false,
      responseType: VariableIdList,
      responseStream: false,
      options: {},
    },
    /** Search for ExternalEvent's. */
    searchExternalEvent: {
      name: "SearchExternalEvent",
      requestType: SearchExternalEventRequest,
      requestStream: false,
      responseType: ExternalEventIdList,
      responseStream: false,
      options: {},
    },
    /** Search for WorkflowEvents's. */
    searchWorkflowEvent: {
      name: "SearchWorkflowEvent",
      requestType: SearchWorkflowEventRequest,
      requestStream: false,
      responseType: WorkflowEventIdList,
      responseStream: false,
      options: {},
    },
    /** Search for TaskDef's. */
    searchTaskDef: {
      name: "SearchTaskDef",
      requestType: SearchTaskDefRequest,
      requestStream: false,
      responseType: TaskDefIdList,
      responseStream: false,
      options: {},
    },
    /** Search for UserTaskDef's. */
    searchUserTaskDef: {
      name: "SearchUserTaskDef",
      requestType: SearchUserTaskDefRequest,
      requestStream: false,
      responseType: UserTaskDefIdList,
      responseStream: false,
      options: {},
    },
    /** Search for WfSpec's. */
    searchWfSpec: {
      name: "SearchWfSpec",
      requestType: SearchWfSpecRequest,
      requestStream: false,
      responseType: WfSpecIdList,
      responseStream: false,
      options: {},
    },
    /** Search for ExternalEventDef's. */
    searchExternalEventDef: {
      name: "SearchExternalEventDef",
      requestType: SearchExternalEventDefRequest,
      requestStream: false,
      responseType: ExternalEventDefIdList,
      responseStream: false,
      options: {},
    },
    /** Search for WorkflowEventDef's. */
    searchWorkflowEventDef: {
      name: "SearchWorkflowEventDef",
      requestType: SearchWorkflowEventDefRequest,
      requestStream: false,
      responseType: WorkflowEventDefIdList,
      responseStream: false,
      options: {},
    },
    /** Search for all available TenantIds for current Principal */
    searchTenant: {
      name: "SearchTenant",
      requestType: SearchTenantRequest,
      requestStream: false,
      responseType: TenantIdList,
      responseStream: false,
      options: {},
    },
    /**  */
    searchPrincipal: {
      name: "SearchPrincipal",
      requestType: SearchPrincipalRequest,
      requestStream: false,
      responseType: PrincipalIdList,
      responseStream: false,
      options: {},
    },
    /**
     * Used by the Task Worker to:
     * 1. Tell the LH Server that the Task Worker has joined the Task Worker Group.
     * 2. Receive the assignemnt of LH Server's to poll from.
     * Generally, you won't use this request manually.
     */
    registerTaskWorker: {
      name: "RegisterTaskWorker",
      requestType: RegisterTaskWorkerRequest,
      requestStream: false,
      responseType: RegisterTaskWorkerResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Used by Task Workers to listen for TaskRuns on the Task Queue. Generally, you won't
     * use this RPC manually.
     */
    pollTask: {
      name: "PollTask",
      requestType: PollTaskRequest,
      requestStream: true,
      responseType: PollTaskResponse,
      responseStream: true,
      options: {},
    },
    /**
     * Used by Task Workers to report the result of a TaskRun. Generally, you won't use
     * this rpc manually.
     */
    reportTask: {
      name: "ReportTask",
      requestType: ReportTaskRun,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Move a WfRun or a specific ThreadRun in that WfRun to the HALTED state. */
    stopWfRun: {
      name: "StopWfRun",
      requestType: StopWfRunRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Resumes a WfRun or a specific ThreadRun of a WfRun. */
    resumeWfRun: {
      name: "ResumeWfRun",
      requestType: ResumeWfRunRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /**
     * Rescues a failed ThreadRun (in the ERROR state only) by restarting it from
     * the point of failure. Useful if a bug in Task Worker implementation caused
     * a WfRun to fail and you did not have a FailureHandler for that NodeRun.
     *
     * The specified `ThreadRun` must be in a state where it's latest `NodeRun` is: <br/>
     * - In the `ERROR` state.<br/>
     * - Has no `FailureHandler` `ThreadRun`s <br/>
     * - The parent `ThreadRun`, or any parent of the parent, has not handled the `Failure`
     * yet.
     *
     * If that is not true, then the `ThreadRun` cannot be rescued and the request
     * will return `FAILED_PRECONDITION`.
     */
    rescueThreadRun: {
      name: "RescueThreadRun",
      requestType: RescueThreadRunRequest,
      requestStream: false,
      responseType: WfRun,
      responseStream: false,
      options: {},
    },
    /** Deletes a WfRun. The WfRun cannot be in the RUNNING state. */
    deleteWfRun: {
      name: "DeleteWfRun",
      requestType: DeleteWfRunRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Deletes a TaskDef. */
    deleteTaskDef: {
      name: "DeleteTaskDef",
      requestType: DeleteTaskDefRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Deletes a WfSpec. */
    deleteWfSpec: {
      name: "DeleteWfSpec",
      requestType: DeleteWfSpecRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Deletes a UserTaskDef. */
    deleteUserTaskDef: {
      name: "DeleteUserTaskDef",
      requestType: DeleteUserTaskDefRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Deletes an ExternalEventDef. */
    deleteExternalEventDef: {
      name: "DeleteExternalEventDef",
      requestType: DeleteExternalEventDefRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    deleteWorkflowEventDef: {
      name: "DeleteWorkflowEventDef",
      requestType: DeleteWorkflowEventDefRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /**
     * Deletes a `Principal`. Fails with `FAILED_PRECONDITION` if the specified `Principal`
     * is the last remaining `Principal` with admin permissions. Admin permissions are defined
     * as having the `global_acls` of `ALL_ACTIONS` over the `ACL_ALL_RESOURCES` scope.
     */
    deletePrincipal: {
      name: "DeletePrincipal",
      requestType: DeletePrincipalRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Deletes a scheduled run and prevents any further associated WfRun from being executed. */
    deleteScheduledWfRun: {
      name: "DeleteScheduledWfRun",
      requestType: DeleteScheduledWfRunRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Returns TaskDef Metrics for a specific TaskDef and a specific time window. */
    getTaskDefMetricsWindow: {
      name: "GetTaskDefMetricsWindow",
      requestType: TaskDefMetricsQueryRequest,
      requestStream: false,
      responseType: TaskDefMetrics,
      responseStream: false,
      options: {},
    },
    /** Returns WfSpec Metrics for a specific WfSpec and a specific time window. */
    getWfSpecMetricsWindow: {
      name: "GetWfSpecMetricsWindow",
      requestType: WfSpecMetricsQueryRequest,
      requestStream: false,
      responseType: WfSpecMetrics,
      responseStream: false,
      options: {},
    },
    /** Returns a list of TaskDef Metrics Windows. */
    listTaskDefMetrics: {
      name: "ListTaskDefMetrics",
      requestType: ListTaskMetricsRequest,
      requestStream: false,
      responseType: ListTaskMetricsResponse,
      responseStream: false,
      options: {},
    },
    /** Returns a list of WfSpec Metrics Windows. */
    listWfSpecMetrics: {
      name: "ListWfSpecMetrics",
      requestType: ListWfMetricsRequest,
      requestStream: false,
      responseType: ListWfMetricsResponse,
      responseStream: false,
      options: {},
    },
    /** EXPERIMENTAL: Creates another Tenant in the LH Server. */
    putTenant: {
      name: "PutTenant",
      requestType: PutTenantRequest,
      requestStream: false,
      responseType: Tenant,
      responseStream: false,
      options: {},
    },
    /** EXPERIMENTAL: Gets a Tenant from the LH Server. */
    getTenant: {
      name: "GetTenant",
      requestType: TenantId,
      requestStream: false,
      responseType: Tenant,
      responseStream: false,
      options: {},
    },
    /** EXPERIMENTAL: Creates an Principal. */
    putPrincipal: {
      name: "PutPrincipal",
      requestType: PutPrincipalRequest,
      requestStream: false,
      responseType: Principal,
      responseStream: false,
      options: {},
    },
    getPrincipal: {
      name: "GetPrincipal",
      requestType: PrincipalId,
      requestStream: false,
      responseType: Principal,
      responseStream: false,
      options: {},
    },
    /** Returns the Principal of the caller. */
    whoami: {
      name: "Whoami",
      requestType: Empty,
      requestStream: false,
      responseType: Principal,
      responseStream: false,
      options: {},
    },
    /** Gets the version of the LH Server. */
    getServerVersion: {
      name: "GetServerVersion",
      requestType: Empty,
      requestStream: false,
      responseType: ServerVersion,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface LittleHorseServiceImplementation<CallContextExt = {}> {
  /** Creates a TaskDef. */
  putTaskDef(request: PutTaskDefRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TaskDef>>;
  /** Gets a TaskDef. */
  getTaskDef(request: TaskDefId, context: CallContext & CallContextExt): Promise<DeepPartial<TaskDef>>;
  /** Gets the registered task worker group associated with a specific TaskDef. */
  getTaskWorkerGroup(request: TaskDefId, context: CallContext & CallContextExt): Promise<DeepPartial<TaskWorkerGroup>>;
  /** Creates an ExternalEventDef. */
  putExternalEventDef(
    request: PutExternalEventDefRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExternalEventDef>>;
  /** Gets an ExternalEventDef. */
  getExternalEventDef(
    request: ExternalEventDefId,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExternalEventDef>>;
  /** Creates a WorkflowEventDef. */
  putWorkflowEventDef(
    request: PutWorkflowEventDefRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<WorkflowEventDef>>;
  /** Creates a WfSpec. */
  putWfSpec(request: PutWfSpecRequest, context: CallContext & CallContextExt): Promise<DeepPartial<WfSpec>>;
  /** Gets a WfSpec. */
  getWfSpec(request: WfSpecId, context: CallContext & CallContextExt): Promise<DeepPartial<WfSpec>>;
  /** Returns the latest WfSpec with a specified name (and optionally a specified Major Version). */
  getLatestWfSpec(request: GetLatestWfSpecRequest, context: CallContext & CallContextExt): Promise<DeepPartial<WfSpec>>;
  /**
   * EXPERIMENTAL: Migrates all WfRun's from one version of a WfSpec onto a newer version of the
   * same WfSpec. This is useful for long-running WfRun's (eg. a 60-day marketing campaign) where
   * you must update WfRun's that are in the RUNNING state rather than allowing them to run to
   * completion.
   *
   * As of 0.7.2, this feature is only partially implemented.
   */
  migrateWfSpec(request: MigrateWfSpecRequest, context: CallContext & CallContextExt): Promise<DeepPartial<WfSpec>>;
  /** Creates a UserTaskDef. */
  putUserTaskDef(
    request: PutUserTaskDefRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UserTaskDef>>;
  /**
   * Gets a specific UserTaskDef.
   *
   * This RPC is highly useful for applications built around
   * User Tasks. For example, a UI that dynamically displays form fields based on the User Task
   * might first receive a UserTaskRun, then use that UserTaskRun to look up the UserTaskDef.
   * The frontend would inspect the UserTaskDef and display a form field on the browser page
   * for each field in the UserTaskDef.
   */
  getUserTaskDef(request: UserTaskDefId, context: CallContext & CallContextExt): Promise<DeepPartial<UserTaskDef>>;
  /** Returns the most recent UserTaskDef with a specific name. */
  getLatestUserTaskDef(
    request: GetLatestUserTaskDefRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UserTaskDef>>;
  /** Runs a WfSpec to create a WfRun. */
  runWf(request: RunWfRequest, context: CallContext & CallContextExt): Promise<DeepPartial<WfRun>>;
  /** Schedule repeated WfRun based on a cron expression */
  scheduleWf(request: ScheduleWfRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ScheduledWfRun>>;
  /** Search for existing schedules */
  searchScheduledWfRun(
    request: SearchScheduledWfRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ScheduledWfRunIdList>>;
  /** Find a specific ScheduledWfRun */
  getScheduledWfRun(
    request: ScheduledWfRunId,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ScheduledWfRun>>;
  /**
   * Gets a WfRun. Although useful for development and debugging, this RPC is not often
   * used by applications.
   */
  getWfRun(request: WfRunId, context: CallContext & CallContextExt): Promise<DeepPartial<WfRun>>;
  /**
   * Loads a specific UserTaskRun. It includes information about to whom the UserTask is
   * currently assigned, history of assignments and reassignments, and any context for that
   * UserTaskRun which is specific to the WfRun.
   */
  getUserTaskRun(request: UserTaskRunId, context: CallContext & CallContextExt): Promise<DeepPartial<UserTaskRun>>;
  /**
   * Change the ownership of a UserTaskRun to a new userId, userGroup, or both. The
   * action will be reflected in your next call to SearchUserTaskRun. This RPC is useful for
   * applications that are using User Tasks to build an internal task-list and wish to
   * administer the tasks.
   */
  assignUserTaskRun(
    request: AssignUserTaskRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Completes a UserTaskRun. Includes the results of the UserTaskRun, the UserTaskRun Id, and
   * the userId of the user who completes the UserTaskRun. Results in the UserTask NodeRun being
   * completed, and unblocks the associated ThreadRun in the WfRun.
   *
   * This RPC is highly useful for applications built around a WfSpec that uses USER_TASK nodes.
   */
  completeUserTaskRun(
    request: CompleteUserTaskRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Cancels a UserTaskRun. This will result in an EXCEPTION being propagated to the WfRun. */
  cancelUserTaskRun(
    request: CancelUserTaskRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Saves the results of a UserTaskRun and logs who saved the content.<br/>
   *
   * <li> Throws FAILED_PRECONDITION if the UserTaskRun is in the `DONE` or `CANCELLED` state.</li>
   * <li> If `policy` is set to `FAIL_IF_CLAIMED_BY_OTHER`, returns `FAILED_PRECONDITION` if the
   * `user_id` field of the `UserTaskRun` does not match the `user_id` of the request.</li>
   */
  saveUserTaskRunProgress(
    request: SaveUserTaskRunProgressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UserTaskRun>>;
  /**
   * Lists all UserTaskRun's for a specific WfRun. Can be useful when using a WfRun
   * to model an entity.
   */
  listUserTaskRuns(
    request: ListUserTaskRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UserTaskRunList>>;
  /** Gets a specific NodeRun. */
  getNodeRun(request: NodeRunId, context: CallContext & CallContextExt): Promise<DeepPartial<NodeRun>>;
  /** Lists all NodeRun's for a specific WfRun. */
  listNodeRuns(request: ListNodeRunsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<NodeRunList>>;
  /** Gets a specific TaskRun. */
  getTaskRun(request: TaskRunId, context: CallContext & CallContextExt): Promise<DeepPartial<TaskRun>>;
  /** Lists all TaskRun's for a specific WfRun. */
  listTaskRuns(request: ListTaskRunsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TaskRunList>>;
  /**
   * Get the value of a specific Variable. When using a WfRun to model an entity, this
   * RPC is useful for retrieving information. It is equivalent to looking up the value of a
   * column for a specific row in a SQL table.
   */
  getVariable(request: VariableId, context: CallContext & CallContextExt): Promise<DeepPartial<Variable>>;
  /** List all Variables from a WfRun. */
  listVariables(
    request: ListVariablesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<VariableList>>;
  /** Post an ExternalEvent. This RPC is highly useful for */
  putExternalEvent(
    request: PutExternalEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExternalEvent>>;
  /** Get a specific ExternalEvent. */
  getExternalEvent(
    request: ExternalEventId,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExternalEvent>>;
  /**
   * Waits for a WorkflowEvent to be thrown by a given WfRun. Returns immediately if a matching
   * WorkflowEvent has already been thrown; throws a DEADLINE_EXCEEDED error if the WorkflowEvent
   * is not thrown before the deadline specified by the client.
   *
   * To specify the deadline, the client should use GRPC deadlines.
   */
  awaitWorkflowEvent(
    request: AwaitWorkflowEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<WorkflowEvent>>;
  /** Get a specific WorkflowEventDef. */
  getWorkflowEventDef(
    request: WorkflowEventDefId,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<WorkflowEventDef>>;
  /** Get a specific WorkflowEvent. */
  getWorkflowEvent(
    request: WorkflowEventId,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<WorkflowEvent>>;
  /** List ExternalEvent's for a specific WfRun. */
  listExternalEvents(
    request: ListExternalEventsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExternalEventList>>;
  /** List WorkflowEvent's for a specific WfRun. */
  listWorkflowEvents(
    request: ListWorkflowEventsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<WorkflowEventList>>;
  /**
   * Search for WfRun's. This RPC is highly useful for applications that store data
   * in LittleHorse and need to find a specific WfRun based on certain indexed fields.
   */
  searchWfRun(request: SearchWfRunRequest, context: CallContext & CallContextExt): Promise<DeepPartial<WfRunIdList>>;
  /**
   * Search for NodeRun's. This RPC is useful for monitoring and finding bugs in
   * your workflows or Task Workers.
   */
  searchNodeRun(
    request: SearchNodeRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<NodeRunIdList>>;
  /** Search for TaskRun's. This RPC is useful for finding bugs in your Task Workers. */
  searchTaskRun(
    request: SearchTaskRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TaskRunIdList>>;
  /**
   * Search for UserTaskRun's. This RPC is highly useful for applications that connect
   * human end-users to LittleHorse: it enables you to find all tasks assigned to a specific
   * person or group of people.
   */
  searchUserTaskRun(
    request: SearchUserTaskRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UserTaskRunIdList>>;
  /**
   * Search for Variable's. This RPC is highly useful for applications that store data
   * in LittleHorse and need to find a specific WfRun based on certain indexed fields.
   */
  searchVariable(
    request: SearchVariableRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<VariableIdList>>;
  /** Search for ExternalEvent's. */
  searchExternalEvent(
    request: SearchExternalEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExternalEventIdList>>;
  /** Search for WorkflowEvents's. */
  searchWorkflowEvent(
    request: SearchWorkflowEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<WorkflowEventIdList>>;
  /** Search for TaskDef's. */
  searchTaskDef(
    request: SearchTaskDefRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TaskDefIdList>>;
  /** Search for UserTaskDef's. */
  searchUserTaskDef(
    request: SearchUserTaskDefRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UserTaskDefIdList>>;
  /** Search for WfSpec's. */
  searchWfSpec(request: SearchWfSpecRequest, context: CallContext & CallContextExt): Promise<DeepPartial<WfSpecIdList>>;
  /** Search for ExternalEventDef's. */
  searchExternalEventDef(
    request: SearchExternalEventDefRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExternalEventDefIdList>>;
  /** Search for WorkflowEventDef's. */
  searchWorkflowEventDef(
    request: SearchWorkflowEventDefRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<WorkflowEventDefIdList>>;
  /** Search for all available TenantIds for current Principal */
  searchTenant(request: SearchTenantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TenantIdList>>;
  /**  */
  searchPrincipal(
    request: SearchPrincipalRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PrincipalIdList>>;
  /**
   * Used by the Task Worker to:
   * 1. Tell the LH Server that the Task Worker has joined the Task Worker Group.
   * 2. Receive the assignemnt of LH Server's to poll from.
   * Generally, you won't use this request manually.
   */
  registerTaskWorker(
    request: RegisterTaskWorkerRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RegisterTaskWorkerResponse>>;
  /**
   * Used by Task Workers to listen for TaskRuns on the Task Queue. Generally, you won't
   * use this RPC manually.
   */
  pollTask(
    request: AsyncIterable<PollTaskRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<PollTaskResponse>>;
  /**
   * Used by Task Workers to report the result of a TaskRun. Generally, you won't use
   * this rpc manually.
   */
  reportTask(request: ReportTaskRun, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Move a WfRun or a specific ThreadRun in that WfRun to the HALTED state. */
  stopWfRun(request: StopWfRunRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Resumes a WfRun or a specific ThreadRun of a WfRun. */
  resumeWfRun(request: ResumeWfRunRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Rescues a failed ThreadRun (in the ERROR state only) by restarting it from
   * the point of failure. Useful if a bug in Task Worker implementation caused
   * a WfRun to fail and you did not have a FailureHandler for that NodeRun.
   *
   * The specified `ThreadRun` must be in a state where it's latest `NodeRun` is: <br/>
   * - In the `ERROR` state.<br/>
   * - Has no `FailureHandler` `ThreadRun`s <br/>
   * - The parent `ThreadRun`, or any parent of the parent, has not handled the `Failure`
   * yet.
   *
   * If that is not true, then the `ThreadRun` cannot be rescued and the request
   * will return `FAILED_PRECONDITION`.
   */
  rescueThreadRun(request: RescueThreadRunRequest, context: CallContext & CallContextExt): Promise<DeepPartial<WfRun>>;
  /** Deletes a WfRun. The WfRun cannot be in the RUNNING state. */
  deleteWfRun(request: DeleteWfRunRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Deletes a TaskDef. */
  deleteTaskDef(request: DeleteTaskDefRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Deletes a WfSpec. */
  deleteWfSpec(request: DeleteWfSpecRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Deletes a UserTaskDef. */
  deleteUserTaskDef(
    request: DeleteUserTaskDefRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Deletes an ExternalEventDef. */
  deleteExternalEventDef(
    request: DeleteExternalEventDefRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  deleteWorkflowEventDef(
    request: DeleteWorkflowEventDefRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Deletes a `Principal`. Fails with `FAILED_PRECONDITION` if the specified `Principal`
   * is the last remaining `Principal` with admin permissions. Admin permissions are defined
   * as having the `global_acls` of `ALL_ACTIONS` over the `ACL_ALL_RESOURCES` scope.
   */
  deletePrincipal(request: DeletePrincipalRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Deletes a scheduled run and prevents any further associated WfRun from being executed. */
  deleteScheduledWfRun(
    request: DeleteScheduledWfRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Returns TaskDef Metrics for a specific TaskDef and a specific time window. */
  getTaskDefMetricsWindow(
    request: TaskDefMetricsQueryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TaskDefMetrics>>;
  /** Returns WfSpec Metrics for a specific WfSpec and a specific time window. */
  getWfSpecMetricsWindow(
    request: WfSpecMetricsQueryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<WfSpecMetrics>>;
  /** Returns a list of TaskDef Metrics Windows. */
  listTaskDefMetrics(
    request: ListTaskMetricsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTaskMetricsResponse>>;
  /** Returns a list of WfSpec Metrics Windows. */
  listWfSpecMetrics(
    request: ListWfMetricsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListWfMetricsResponse>>;
  /** EXPERIMENTAL: Creates another Tenant in the LH Server. */
  putTenant(request: PutTenantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Tenant>>;
  /** EXPERIMENTAL: Gets a Tenant from the LH Server. */
  getTenant(request: TenantId, context: CallContext & CallContextExt): Promise<DeepPartial<Tenant>>;
  /** EXPERIMENTAL: Creates an Principal. */
  putPrincipal(request: PutPrincipalRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Principal>>;
  getPrincipal(request: PrincipalId, context: CallContext & CallContextExt): Promise<DeepPartial<Principal>>;
  /** Returns the Principal of the caller. */
  whoami(request: Empty, context: CallContext & CallContextExt): Promise<DeepPartial<Principal>>;
  /** Gets the version of the LH Server. */
  getServerVersion(request: Empty, context: CallContext & CallContextExt): Promise<DeepPartial<ServerVersion>>;
}

export interface LittleHorseClient<CallOptionsExt = {}> {
  /** Creates a TaskDef. */
  putTaskDef(request: DeepPartial<PutTaskDefRequest>, options?: CallOptions & CallOptionsExt): Promise<TaskDef>;
  /** Gets a TaskDef. */
  getTaskDef(request: DeepPartial<TaskDefId>, options?: CallOptions & CallOptionsExt): Promise<TaskDef>;
  /** Gets the registered task worker group associated with a specific TaskDef. */
  getTaskWorkerGroup(request: DeepPartial<TaskDefId>, options?: CallOptions & CallOptionsExt): Promise<TaskWorkerGroup>;
  /** Creates an ExternalEventDef. */
  putExternalEventDef(
    request: DeepPartial<PutExternalEventDefRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExternalEventDef>;
  /** Gets an ExternalEventDef. */
  getExternalEventDef(
    request: DeepPartial<ExternalEventDefId>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExternalEventDef>;
  /** Creates a WorkflowEventDef. */
  putWorkflowEventDef(
    request: DeepPartial<PutWorkflowEventDefRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WorkflowEventDef>;
  /** Creates a WfSpec. */
  putWfSpec(request: DeepPartial<PutWfSpecRequest>, options?: CallOptions & CallOptionsExt): Promise<WfSpec>;
  /** Gets a WfSpec. */
  getWfSpec(request: DeepPartial<WfSpecId>, options?: CallOptions & CallOptionsExt): Promise<WfSpec>;
  /** Returns the latest WfSpec with a specified name (and optionally a specified Major Version). */
  getLatestWfSpec(
    request: DeepPartial<GetLatestWfSpecRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WfSpec>;
  /**
   * EXPERIMENTAL: Migrates all WfRun's from one version of a WfSpec onto a newer version of the
   * same WfSpec. This is useful for long-running WfRun's (eg. a 60-day marketing campaign) where
   * you must update WfRun's that are in the RUNNING state rather than allowing them to run to
   * completion.
   *
   * As of 0.7.2, this feature is only partially implemented.
   */
  migrateWfSpec(request: DeepPartial<MigrateWfSpecRequest>, options?: CallOptions & CallOptionsExt): Promise<WfSpec>;
  /** Creates a UserTaskDef. */
  putUserTaskDef(
    request: DeepPartial<PutUserTaskDefRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UserTaskDef>;
  /**
   * Gets a specific UserTaskDef.
   *
   * This RPC is highly useful for applications built around
   * User Tasks. For example, a UI that dynamically displays form fields based on the User Task
   * might first receive a UserTaskRun, then use that UserTaskRun to look up the UserTaskDef.
   * The frontend would inspect the UserTaskDef and display a form field on the browser page
   * for each field in the UserTaskDef.
   */
  getUserTaskDef(request: DeepPartial<UserTaskDefId>, options?: CallOptions & CallOptionsExt): Promise<UserTaskDef>;
  /** Returns the most recent UserTaskDef with a specific name. */
  getLatestUserTaskDef(
    request: DeepPartial<GetLatestUserTaskDefRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UserTaskDef>;
  /** Runs a WfSpec to create a WfRun. */
  runWf(request: DeepPartial<RunWfRequest>, options?: CallOptions & CallOptionsExt): Promise<WfRun>;
  /** Schedule repeated WfRun based on a cron expression */
  scheduleWf(request: DeepPartial<ScheduleWfRequest>, options?: CallOptions & CallOptionsExt): Promise<ScheduledWfRun>;
  /** Search for existing schedules */
  searchScheduledWfRun(
    request: DeepPartial<SearchScheduledWfRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ScheduledWfRunIdList>;
  /** Find a specific ScheduledWfRun */
  getScheduledWfRun(
    request: DeepPartial<ScheduledWfRunId>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ScheduledWfRun>;
  /**
   * Gets a WfRun. Although useful for development and debugging, this RPC is not often
   * used by applications.
   */
  getWfRun(request: DeepPartial<WfRunId>, options?: CallOptions & CallOptionsExt): Promise<WfRun>;
  /**
   * Loads a specific UserTaskRun. It includes information about to whom the UserTask is
   * currently assigned, history of assignments and reassignments, and any context for that
   * UserTaskRun which is specific to the WfRun.
   */
  getUserTaskRun(request: DeepPartial<UserTaskRunId>, options?: CallOptions & CallOptionsExt): Promise<UserTaskRun>;
  /**
   * Change the ownership of a UserTaskRun to a new userId, userGroup, or both. The
   * action will be reflected in your next call to SearchUserTaskRun. This RPC is useful for
   * applications that are using User Tasks to build an internal task-list and wish to
   * administer the tasks.
   */
  assignUserTaskRun(
    request: DeepPartial<AssignUserTaskRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Completes a UserTaskRun. Includes the results of the UserTaskRun, the UserTaskRun Id, and
   * the userId of the user who completes the UserTaskRun. Results in the UserTask NodeRun being
   * completed, and unblocks the associated ThreadRun in the WfRun.
   *
   * This RPC is highly useful for applications built around a WfSpec that uses USER_TASK nodes.
   */
  completeUserTaskRun(
    request: DeepPartial<CompleteUserTaskRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Cancels a UserTaskRun. This will result in an EXCEPTION being propagated to the WfRun. */
  cancelUserTaskRun(
    request: DeepPartial<CancelUserTaskRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Saves the results of a UserTaskRun and logs who saved the content.<br/>
   *
   * <li> Throws FAILED_PRECONDITION if the UserTaskRun is in the `DONE` or `CANCELLED` state.</li>
   * <li> If `policy` is set to `FAIL_IF_CLAIMED_BY_OTHER`, returns `FAILED_PRECONDITION` if the
   * `user_id` field of the `UserTaskRun` does not match the `user_id` of the request.</li>
   */
  saveUserTaskRunProgress(
    request: DeepPartial<SaveUserTaskRunProgressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UserTaskRun>;
  /**
   * Lists all UserTaskRun's for a specific WfRun. Can be useful when using a WfRun
   * to model an entity.
   */
  listUserTaskRuns(
    request: DeepPartial<ListUserTaskRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UserTaskRunList>;
  /** Gets a specific NodeRun. */
  getNodeRun(request: DeepPartial<NodeRunId>, options?: CallOptions & CallOptionsExt): Promise<NodeRun>;
  /** Lists all NodeRun's for a specific WfRun. */
  listNodeRuns(request: DeepPartial<ListNodeRunsRequest>, options?: CallOptions & CallOptionsExt): Promise<NodeRunList>;
  /** Gets a specific TaskRun. */
  getTaskRun(request: DeepPartial<TaskRunId>, options?: CallOptions & CallOptionsExt): Promise<TaskRun>;
  /** Lists all TaskRun's for a specific WfRun. */
  listTaskRuns(request: DeepPartial<ListTaskRunsRequest>, options?: CallOptions & CallOptionsExt): Promise<TaskRunList>;
  /**
   * Get the value of a specific Variable. When using a WfRun to model an entity, this
   * RPC is useful for retrieving information. It is equivalent to looking up the value of a
   * column for a specific row in a SQL table.
   */
  getVariable(request: DeepPartial<VariableId>, options?: CallOptions & CallOptionsExt): Promise<Variable>;
  /** List all Variables from a WfRun. */
  listVariables(
    request: DeepPartial<ListVariablesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<VariableList>;
  /** Post an ExternalEvent. This RPC is highly useful for */
  putExternalEvent(
    request: DeepPartial<PutExternalEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExternalEvent>;
  /** Get a specific ExternalEvent. */
  getExternalEvent(
    request: DeepPartial<ExternalEventId>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExternalEvent>;
  /**
   * Waits for a WorkflowEvent to be thrown by a given WfRun. Returns immediately if a matching
   * WorkflowEvent has already been thrown; throws a DEADLINE_EXCEEDED error if the WorkflowEvent
   * is not thrown before the deadline specified by the client.
   *
   * To specify the deadline, the client should use GRPC deadlines.
   */
  awaitWorkflowEvent(
    request: DeepPartial<AwaitWorkflowEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WorkflowEvent>;
  /** Get a specific WorkflowEventDef. */
  getWorkflowEventDef(
    request: DeepPartial<WorkflowEventDefId>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WorkflowEventDef>;
  /** Get a specific WorkflowEvent. */
  getWorkflowEvent(
    request: DeepPartial<WorkflowEventId>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WorkflowEvent>;
  /** List ExternalEvent's for a specific WfRun. */
  listExternalEvents(
    request: DeepPartial<ListExternalEventsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExternalEventList>;
  /** List WorkflowEvent's for a specific WfRun. */
  listWorkflowEvents(
    request: DeepPartial<ListWorkflowEventsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WorkflowEventList>;
  /**
   * Search for WfRun's. This RPC is highly useful for applications that store data
   * in LittleHorse and need to find a specific WfRun based on certain indexed fields.
   */
  searchWfRun(request: DeepPartial<SearchWfRunRequest>, options?: CallOptions & CallOptionsExt): Promise<WfRunIdList>;
  /**
   * Search for NodeRun's. This RPC is useful for monitoring and finding bugs in
   * your workflows or Task Workers.
   */
  searchNodeRun(
    request: DeepPartial<SearchNodeRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<NodeRunIdList>;
  /** Search for TaskRun's. This RPC is useful for finding bugs in your Task Workers. */
  searchTaskRun(
    request: DeepPartial<SearchTaskRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TaskRunIdList>;
  /**
   * Search for UserTaskRun's. This RPC is highly useful for applications that connect
   * human end-users to LittleHorse: it enables you to find all tasks assigned to a specific
   * person or group of people.
   */
  searchUserTaskRun(
    request: DeepPartial<SearchUserTaskRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UserTaskRunIdList>;
  /**
   * Search for Variable's. This RPC is highly useful for applications that store data
   * in LittleHorse and need to find a specific WfRun based on certain indexed fields.
   */
  searchVariable(
    request: DeepPartial<SearchVariableRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<VariableIdList>;
  /** Search for ExternalEvent's. */
  searchExternalEvent(
    request: DeepPartial<SearchExternalEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExternalEventIdList>;
  /** Search for WorkflowEvents's. */
  searchWorkflowEvent(
    request: DeepPartial<SearchWorkflowEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WorkflowEventIdList>;
  /** Search for TaskDef's. */
  searchTaskDef(
    request: DeepPartial<SearchTaskDefRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TaskDefIdList>;
  /** Search for UserTaskDef's. */
  searchUserTaskDef(
    request: DeepPartial<SearchUserTaskDefRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UserTaskDefIdList>;
  /** Search for WfSpec's. */
  searchWfSpec(
    request: DeepPartial<SearchWfSpecRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WfSpecIdList>;
  /** Search for ExternalEventDef's. */
  searchExternalEventDef(
    request: DeepPartial<SearchExternalEventDefRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExternalEventDefIdList>;
  /** Search for WorkflowEventDef's. */
  searchWorkflowEventDef(
    request: DeepPartial<SearchWorkflowEventDefRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WorkflowEventDefIdList>;
  /** Search for all available TenantIds for current Principal */
  searchTenant(
    request: DeepPartial<SearchTenantRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TenantIdList>;
  /**  */
  searchPrincipal(
    request: DeepPartial<SearchPrincipalRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PrincipalIdList>;
  /**
   * Used by the Task Worker to:
   * 1. Tell the LH Server that the Task Worker has joined the Task Worker Group.
   * 2. Receive the assignemnt of LH Server's to poll from.
   * Generally, you won't use this request manually.
   */
  registerTaskWorker(
    request: DeepPartial<RegisterTaskWorkerRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RegisterTaskWorkerResponse>;
  /**
   * Used by Task Workers to listen for TaskRuns on the Task Queue. Generally, you won't
   * use this RPC manually.
   */
  pollTask(
    request: AsyncIterable<DeepPartial<PollTaskRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<PollTaskResponse>;
  /**
   * Used by Task Workers to report the result of a TaskRun. Generally, you won't use
   * this rpc manually.
   */
  reportTask(request: DeepPartial<ReportTaskRun>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Move a WfRun or a specific ThreadRun in that WfRun to the HALTED state. */
  stopWfRun(request: DeepPartial<StopWfRunRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Resumes a WfRun or a specific ThreadRun of a WfRun. */
  resumeWfRun(request: DeepPartial<ResumeWfRunRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Rescues a failed ThreadRun (in the ERROR state only) by restarting it from
   * the point of failure. Useful if a bug in Task Worker implementation caused
   * a WfRun to fail and you did not have a FailureHandler for that NodeRun.
   *
   * The specified `ThreadRun` must be in a state where it's latest `NodeRun` is: <br/>
   * - In the `ERROR` state.<br/>
   * - Has no `FailureHandler` `ThreadRun`s <br/>
   * - The parent `ThreadRun`, or any parent of the parent, has not handled the `Failure`
   * yet.
   *
   * If that is not true, then the `ThreadRun` cannot be rescued and the request
   * will return `FAILED_PRECONDITION`.
   */
  rescueThreadRun(request: DeepPartial<RescueThreadRunRequest>, options?: CallOptions & CallOptionsExt): Promise<WfRun>;
  /** Deletes a WfRun. The WfRun cannot be in the RUNNING state. */
  deleteWfRun(request: DeepPartial<DeleteWfRunRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Deletes a TaskDef. */
  deleteTaskDef(request: DeepPartial<DeleteTaskDefRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Deletes a WfSpec. */
  deleteWfSpec(request: DeepPartial<DeleteWfSpecRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Deletes a UserTaskDef. */
  deleteUserTaskDef(
    request: DeepPartial<DeleteUserTaskDefRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Deletes an ExternalEventDef. */
  deleteExternalEventDef(
    request: DeepPartial<DeleteExternalEventDefRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  deleteWorkflowEventDef(
    request: DeepPartial<DeleteWorkflowEventDefRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Deletes a `Principal`. Fails with `FAILED_PRECONDITION` if the specified `Principal`
   * is the last remaining `Principal` with admin permissions. Admin permissions are defined
   * as having the `global_acls` of `ALL_ACTIONS` over the `ACL_ALL_RESOURCES` scope.
   */
  deletePrincipal(request: DeepPartial<DeletePrincipalRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Deletes a scheduled run and prevents any further associated WfRun from being executed. */
  deleteScheduledWfRun(
    request: DeepPartial<DeleteScheduledWfRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Returns TaskDef Metrics for a specific TaskDef and a specific time window. */
  getTaskDefMetricsWindow(
    request: DeepPartial<TaskDefMetricsQueryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TaskDefMetrics>;
  /** Returns WfSpec Metrics for a specific WfSpec and a specific time window. */
  getWfSpecMetricsWindow(
    request: DeepPartial<WfSpecMetricsQueryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WfSpecMetrics>;
  /** Returns a list of TaskDef Metrics Windows. */
  listTaskDefMetrics(
    request: DeepPartial<ListTaskMetricsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTaskMetricsResponse>;
  /** Returns a list of WfSpec Metrics Windows. */
  listWfSpecMetrics(
    request: DeepPartial<ListWfMetricsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListWfMetricsResponse>;
  /** EXPERIMENTAL: Creates another Tenant in the LH Server. */
  putTenant(request: DeepPartial<PutTenantRequest>, options?: CallOptions & CallOptionsExt): Promise<Tenant>;
  /** EXPERIMENTAL: Gets a Tenant from the LH Server. */
  getTenant(request: DeepPartial<TenantId>, options?: CallOptions & CallOptionsExt): Promise<Tenant>;
  /** EXPERIMENTAL: Creates an Principal. */
  putPrincipal(request: DeepPartial<PutPrincipalRequest>, options?: CallOptions & CallOptionsExt): Promise<Principal>;
  getPrincipal(request: DeepPartial<PrincipalId>, options?: CallOptions & CallOptionsExt): Promise<Principal>;
  /** Returns the Principal of the caller. */
  whoami(request: DeepPartial<Empty>, options?: CallOptions & CallOptionsExt): Promise<Principal>;
  /** Gets the version of the LH Server. */
  getServerVersion(request: DeepPartial<Empty>, options?: CallOptions & CallOptionsExt): Promise<ServerVersion>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };
