// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v4.23.4
// source: wf_spec.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  MetadataStatus,
  metadataStatusFromJSON,
  metadataStatusToJSON,
  metadataStatusToNumber,
  VariableType,
  variableTypeFromJSON,
  variableTypeToJSON,
  variableTypeToNumber,
} from "./common_enums";
import {
  Comparator,
  comparatorFromJSON,
  comparatorToJSON,
  comparatorToNumber,
  TaskNode,
  UTActionTrigger,
  VariableAssignment,
  VariableDef,
  VariableMutation,
} from "./common_wfspec";
import { Timestamp } from "./google/protobuf/timestamp";
import { ExternalEventDefId, WfSpecId, WorkflowEventDefId } from "./object_id";

/** Determines the Access Level for a Variable in a ThreadSpec/WfSpec. */
export enum WfRunVariableAccessLevel {
  /** PUBLIC_VAR - A `PUBLIC_VAR` can be accessed (read + mutated) by child `WfRun`'s. */
  PUBLIC_VAR = "PUBLIC_VAR",
  /** PRIVATE_VAR - A `PRIVATE_VAR` cannot be accessed by a child `WfRun`. */
  PRIVATE_VAR = "PRIVATE_VAR",
  /**
   * INHERITED_VAR - An `INHERITED_VAR` is inherited from the parent `WfRun`. Only valid in a `WfSpec` that
   * has a parent. Also can only be declared in the Entrypoint Thread.
   */
  INHERITED_VAR = "INHERITED_VAR",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function wfRunVariableAccessLevelFromJSON(object: any): WfRunVariableAccessLevel {
  switch (object) {
    case 0:
    case "PUBLIC_VAR":
      return WfRunVariableAccessLevel.PUBLIC_VAR;
    case 1:
    case "PRIVATE_VAR":
      return WfRunVariableAccessLevel.PRIVATE_VAR;
    case 2:
    case "INHERITED_VAR":
      return WfRunVariableAccessLevel.INHERITED_VAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WfRunVariableAccessLevel.UNRECOGNIZED;
  }
}

export function wfRunVariableAccessLevelToJSON(object: WfRunVariableAccessLevel): string {
  switch (object) {
    case WfRunVariableAccessLevel.PUBLIC_VAR:
      return "PUBLIC_VAR";
    case WfRunVariableAccessLevel.PRIVATE_VAR:
      return "PRIVATE_VAR";
    case WfRunVariableAccessLevel.INHERITED_VAR:
      return "INHERITED_VAR";
    case WfRunVariableAccessLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function wfRunVariableAccessLevelToNumber(object: WfRunVariableAccessLevel): number {
  switch (object) {
    case WfRunVariableAccessLevel.PUBLIC_VAR:
      return 0;
    case WfRunVariableAccessLevel.PRIVATE_VAR:
      return 1;
    case WfRunVariableAccessLevel.INHERITED_VAR:
      return 2;
    case WfRunVariableAccessLevel.UNRECOGNIZED:
    default:
      return -1;
  }
}

/**
 * A `WfSpec` defines the logic for a workflow in LittleHorse. It is a metadata object
 * and is a blueprint for a `WfRun` execution.
 */
export interface WfSpec {
  /**
   * The ID of the `WfSpec`. Note that this ID is versioned with both a major
   * version and a minor revision. Creating new WfSpec's with the same name
   * and different specifications results in a completely new `WfSpec` object
   * whose `id.name` is the same but with different version.
   */
  id:
    | WfSpecId
    | undefined;
  /** The timestamp at which the `WfSpec` was created. */
  createdAt:
    | string
    | undefined;
  /**
   * Variables whose types cannot be changed without causing a Breaking Change between
   * the versions.
   */
  frozenVariables: ThreadVarDef[];
  /**
   * The Status of the `WfSpec`. Currently, only `ACTIVE` exists. This field will be
   * used in the future when de-commissioning a WfSpec gracefully.
   */
  status: MetadataStatus;
  /**
   * The various ThreadSpec's in this `WfSpec`. Each `ThreadSpec` defines a blueprint for
   * a parallel thread of execution (a `ThreadRun`). They are referred to by their names.
   */
  threadSpecs: { [key: string]: ThreadSpec };
  /**
   * The name of the `ENTRYPOINT` ThreadSpec. The Entrypoint is the `ThreadSpec` for the
   * Entrypoint ThreadRun, which is the `ThreadRun` that is created upon starting the
   * `WfRun`.
   */
  entrypointThreadName: string;
  /**
   * Optional policy that configures cleaning up old `WfRun`'s after they are completed or
   * failed. Recommended for production settings to avoid running out of disk space; unless
   * you are using a `WfRun` as a data record, in which case the application should
   * clean up `WfRun`'s as appropriate.
   */
  retentionPolicy?:
    | WorkflowRetentionPolicy
    | undefined;
  /** EXPERIMENTAL: ongoing migration from one version of a `WfSpec` to another. */
  migration?:
    | WfSpecVersionMigration
    | undefined;
  /**
   * Reference to the parent WfSpec. If this is set, all WfRun's for this WfSpec must be the
   * child of a WfRun belonging to the referenced WfSpec.
   */
  parentWfSpec?: WfSpec_ParentWfSpecReference | undefined;
}

export interface WfSpec_ThreadSpecsEntry {
  key: string;
  value: ThreadSpec | undefined;
}

/**
 * Reference to another WfSpec. If a WfSpec has a ParentWfSpecReference, then all
 * WfRun's for that WfSpec *MUST* be the child of a WfRun of the provided WfSpec; meaning
 * that the RunWf RPC must provide a `parent_wf_run_id` that belongs to the specified
 * WfSpec.
 *
 * Currently, only reference by names is supported.
 */
export interface WfSpec_ParentWfSpecReference {
  /** Name of the Parent WfSpec */
  wfSpecName: string;
  /**
   * FOR NOW: no validation of variables on parent. In the future we will pass
   * wf_spec_major_version, but we should probably examine the rules for
   * evolution in the future.
   */
  wfSpecMajorVersion: number;
}

/**
 * A WorkflowRetentionPolicy configures how long a WfRun is retained in the data store before
 * being deleted after it is completed or failed.
 */
export interface WorkflowRetentionPolicy {
  wfGcPolicy?: { $case: "secondsAfterWfTermination"; value: number } | undefined;
}

/**
 * Defines an index to make a JSON_OBJ or JSON_ARR variable searchable over a specific
 * JSON Path.
 */
export interface JsonIndex {
  /**
   * Denotes the path in JSONPath format (according to the Java Jayway library) that
   * has a field we should index.
   */
  fieldPath: string;
  /** Is the type of the field we are indexing. */
  fieldType: VariableType;
}

/** Denotes a variable declaration at the ThreadSpec level. */
export interface ThreadVarDef {
  /** Is the actual VariableDefinition containing name and type. */
  varDef:
    | VariableDef
    | undefined;
  /** Whether the variable is required as input to the threadRun. */
  required: boolean;
  /** Whether this variable has an index configured. */
  searchable: boolean;
  /**
   * Valid for JSON_OBJ and JSON_ARR variables only. List of JSON fields
   * to index.
   */
  jsonIndexes: JsonIndex[];
  /** The Access Level of this variable. */
  accessLevel: WfRunVariableAccessLevel;
}

/**
 * Defines a blueprint for a ThreadRun, which is a thread of execution inside a
 * WfRun.
 */
export interface ThreadSpec {
  /** The Nodes inside this ThreadSpec. Maps from name to Node. */
  nodes: { [key: string]: Node };
  /** Defines Variables that are local to ThreadRun's of this ThreadSpec. */
  variableDefs: ThreadVarDef[];
  /** Defines all interrupts for this ThreadSpec. */
  interruptDefs: InterruptDef[];
  /**
   * Optional retention policy to clean up ThreadRun's of this ThreadSpec after they
   * have been completed. This is important for long-lived WfRun's that could have
   * hundreds of ThreadRun's, because a ThreadRun has a record inside the WfRun itself.
   */
  retentionPolicy?: ThreadRetentionPolicy | undefined;
}

export interface ThreadSpec_NodesEntry {
  key: string;
  value: Node | undefined;
}

/**
 * ThreadRetentionPolicy specifies how long to keep record of a ThreadRun and its associated
 * NodeRun's and TaskRun's and Variables after the ThreadRun has been completed.
 */
export interface ThreadRetentionPolicy {
  threadGcPolicy?: { $case: "secondsAfterThreadTermination"; value: number } | undefined;
}

/**
 * Defines an Interrupt for a ThreadSpec. An Interrupt means that when an ExternalEvent
 * of a certain type is registered to the WfRun, then the affected ThreadRun is HALTED
 * and a handler ThreadRun is run as an interrupt handler. The interrupted ThreadRun
 * is resumed once the interrupt handler completes.
 */
export interface InterruptDef {
  /**
   * The ID of the ExternalEventDef which triggers an Interrupt for this ThreadSpec.
   * Note that as of 0.9.0, you cannot use an ExternalEventDefId for both an InterruptDef
   * and an ExternalEventNode in the same WfSpec.
   */
  externalEventDefId:
    | ExternalEventDefId
    | undefined;
  /** The name of the ThreadSpec that we run as the interrupt handler. */
  handlerSpecName: string;
}

/** Starts a Child ThreadRun with a specific ThreadSpec. */
export interface StartThreadNode {
  /** The name of the ThreadSpec to spawn. */
  threadSpecName: string;
  /** The input variables to pass into the Child ThreadRun. */
  variables: { [key: string]: VariableAssignment };
}

export interface StartThreadNode_VariablesEntry {
  key: string;
  value: VariableAssignment | undefined;
}

/**
 * Iterates over a JSON_ARR and starts a Child ThreadRun for each element in the
 * list.
 *
 * Returns a JSON_ARR containing the thread_run_number of each spawned child.
 */
export interface StartMultipleThreadsNode {
  /** The name of the ThreadSpec to spawn. */
  threadSpecName: string;
  /**
   * Variables which are passed into the child ThreadRuns. These assignments are
   * the same for all spawned threads.
   */
  variables: { [key: string]: VariableAssignment };
  /**
   * Assignment that resolves to a JSON_ARR. For each element in the list, a child
   * ThreadRun is started. The reserved `INPUT` variable for each Child is set to the
   * corresponding item in the list.
   */
  iterable: VariableAssignment | undefined;
}

export interface StartMultipleThreadsNode_VariablesEntry {
  key: string;
  value: VariableAssignment | undefined;
}

/**
 * Specifies a Failure Handler which can run in case of a certain Failure to allow
 * the ThreadRun to run compensatory logic and gracefully continue rather than
 * failing immediately.
 */
export interface FailureHandlerDef {
  /** The name of the ThreadSpec to run as a */
  handlerSpecName: string;
  failureToCatch?: { $case: "specificFailure"; value: string } | {
    $case: "anyFailureOfType";
    value: FailureHandlerDef_LHFailureType;
  } | undefined;
}

/** Specifies a type of Failure */
export enum FailureHandlerDef_LHFailureType {
  /** FAILURE_TYPE_ERROR - FAILURE_TYPE_ERROR specifies any technical `ERROR`. */
  FAILURE_TYPE_ERROR = "FAILURE_TYPE_ERROR",
  /** FAILURE_TYPE_EXCEPTION - Specifies a user-defined, business-related `EXCEPTION`. */
  FAILURE_TYPE_EXCEPTION = "FAILURE_TYPE_EXCEPTION",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function failureHandlerDef_LHFailureTypeFromJSON(object: any): FailureHandlerDef_LHFailureType {
  switch (object) {
    case 0:
    case "FAILURE_TYPE_ERROR":
      return FailureHandlerDef_LHFailureType.FAILURE_TYPE_ERROR;
    case 1:
    case "FAILURE_TYPE_EXCEPTION":
      return FailureHandlerDef_LHFailureType.FAILURE_TYPE_EXCEPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FailureHandlerDef_LHFailureType.UNRECOGNIZED;
  }
}

export function failureHandlerDef_LHFailureTypeToJSON(object: FailureHandlerDef_LHFailureType): string {
  switch (object) {
    case FailureHandlerDef_LHFailureType.FAILURE_TYPE_ERROR:
      return "FAILURE_TYPE_ERROR";
    case FailureHandlerDef_LHFailureType.FAILURE_TYPE_EXCEPTION:
      return "FAILURE_TYPE_EXCEPTION";
    case FailureHandlerDef_LHFailureType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function failureHandlerDef_LHFailureTypeToNumber(object: FailureHandlerDef_LHFailureType): number {
  switch (object) {
    case FailureHandlerDef_LHFailureType.FAILURE_TYPE_ERROR:
      return 0;
    case FailureHandlerDef_LHFailureType.FAILURE_TYPE_EXCEPTION:
      return 1;
    case FailureHandlerDef_LHFailureType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/**
 * Specifies that a ThreadRun will wait for certain specified Child ThreadRun's to
 * complete or fail before the WfRun continues. If one of the Child ThreadRun's
 * throws a Failure that is not caught by the `per_thread_failure_handlers`,
 * then the Child ThreadRun's Failure is thrown by the WaitForThreadsRun.
 *
 * No output.
 */
export interface WaitForThreadsNode {
  threadsToWaitFor?:
    | { $case: "threads"; value: WaitForThreadsNode_ThreadsToWaitFor }
    | { $case: "threadList"; value: VariableAssignment }
    | undefined;
  /**
   * If any of the child ThreadRun's that we are waiting for throw a Failure, we will
   * evaluate it against these FailureHandlerDef's and run the first matching FailureHandler
   * (if any). The FailureHandler will be a child of the child, which means that it has
   * access to all of the variables in the scope of the failed Child ThreadRun.
   *
   * This is different from Node-level Failure Handlers, which would be _siblings_ of the
   * ThreadRuns that we're waiting for, and would run only when the overall nodeRun has
   * failed.
   */
  perThreadFailureHandlers: FailureHandlerDef[];
}

export interface WaitForThreadsNode_ThreadToWaitFor {
  /**
   * Causes the WaitForThreadsNodeRun to wait for the ThreadRun whose number
   * matches the value specified here. Must resolve to an INT.
   */
  threadRunNumber: VariableAssignment | undefined;
}

export interface WaitForThreadsNode_ThreadsToWaitFor {
  /** Wait for one or more ThreadRun's */
  threads: WaitForThreadsNode_ThreadToWaitFor[];
}

/**
 * An ExternalEventNode causes the WfRun to stop and wait for an ExternalEvent
 * to arrive before continuing onwards.
 *
 * The output is just the content of the ExternalEvent.
 */
export interface ExternalEventNode {
  /** The ID of the ExternalEventDef that we are waiting for. */
  externalEventDefId:
    | ExternalEventDefId
    | undefined;
  /**
   * Determines the maximum amount of time that the NodeRun will wait for the
   * ExternalEvent to arrive.
   */
  timeoutSeconds:
    | VariableAssignment
    | undefined;
  /**
   * If set, it will be possible to complete this ExternalEventNode with a CorrelatedEvent
   * using the correlation key provided here.
   */
  correlationKey?:
    | VariableAssignment
    | undefined;
  /**
   * Specifies whether the correlation key is sensitive data which should be masked.
   * Ignored if correlation_key is not set.
   */
  maskCorrelationKey: boolean;
}

/**
 * Defines the beginning of the ThreadRun execution.
 *
 * Output is NULL
 */
export interface EntrypointNode {
}

/** Defines the end of the ThreadRun execution. */
export interface ExitNode {
  result?:
    | { $case: "failureDef"; value: FailureDef }
    | { $case: "returnContent"; value: VariableAssignment }
    | undefined;
}

/** Defines a Failure that can be thrown. */
export interface FailureDef {
  /**
   * The code for the failure. If in UPPER_CASE, it must be one of the LHErrorType
   * enums, and represents an ERROR. If it is in kebab-case, then it is a user-defined
   * EXCEPTION.
   */
  failureName: string;
  /** Human-readable message denoting why the Failure occurred. */
  message: string;
  /** If specified, the thrown Failure will have this content. */
  content?: VariableAssignment | undefined;
}

/** A Node is a step in a ThreadRun. */
export interface Node {
  /** Defines the flow of execution and determines where the ThreadRun goes next. */
  outgoingEdges: Edge[];
  /**
   * Specifies handlers for failures (EXCEPTION or ERROR or both) which might be thrown
   * by the NodeRun. If a Failure is thrown by the Node execution, then the first
   * matching Failure Handler (if present) is run. If there is a matching Failure Handler
   * and it runs to completion, then the ThreadRun advances from the Node; else, it
   * fails.
   */
  failureHandlers: FailureHandlerDef[];
  node?:
    | { $case: "entrypoint"; value: EntrypointNode }
    | { $case: "exit"; value: ExitNode }
    | { $case: "task"; value: TaskNode }
    | { $case: "externalEvent"; value: ExternalEventNode }
    | { $case: "startThread"; value: StartThreadNode }
    | { $case: "waitForThreads"; value: WaitForThreadsNode }
    | { $case: "nop"; value: NopNode }
    | { $case: "sleep"; value: SleepNode }
    | { $case: "userTask"; value: UserTaskNode }
    | { $case: "startMultipleThreads"; value: StartMultipleThreadsNode }
    | { $case: "throwEvent"; value: ThrowEventNode }
    | { $case: "waitForCondition"; value: WaitForConditionNode }
    | undefined;
}

/**
 * A SubNode that blocks until a condition is satisfied in the WfRun.
 * There is no output.
 */
export interface WaitForConditionNode {
  /** The condition that this node will block for. */
  condition: EdgeCondition | undefined;
}

/** A SubNode that throws a WorkflowEvent of a specific type. There is no output. */
export interface ThrowEventNode {
  /** The WorkflowEventDefId of the WorkflowEvent that is thrown */
  eventDefId:
    | WorkflowEventDefId
    | undefined;
  /** A VariableAssignment defining the content of the WorkflowEvent that is thrown */
  content: VariableAssignment | undefined;
}

/**
 * The UserTaskNode creates a UserTaskRun, which is used to get input from a human
 * user into the workflow.
 *
 * The output is a JSON_OBJ variable with one key/value pair for each UserTaskField.
 */
export interface UserTaskNode {
  /** Denotes the name of the `UserTaskDef` that should create the `UserTaskRun`. */
  userTaskDefName: string;
  /** Denotes the user_group to which the UserTaskRun is assigned upon creation. */
  userGroup?:
    | VariableAssignment
    | undefined;
  /** Denotes the user_id to which the UserTaskRun is assigned upon creation. */
  userId?:
    | VariableAssignment
    | undefined;
  /**
   * Specifies a list of actions that happen on various time-based triggers. Actions
   * include reassigning the UserTaskRun, cancelling the UserTaskRun, or executing
   * a "reminder" TaskRun.
   */
  actions: UTActionTrigger[];
  /**
   * This is not set in PutWfSpecRequest, and is automatically set by the Metadata
   * processor to be the latest available version of the UserTaskDef. That way, the
   * WfSpec always runs with the same version of the UserTaskDef.
   */
  userTaskDefVersion?:
    | number
    | undefined;
  /** Specifies the value to be displayed on the `notes` field of the UserTaskRun. */
  notes?:
    | VariableAssignment
    | undefined;
  /**
   * Specifies the name of the exception thrown when the User Task is canceled. If
   * not set, then the cancellation or timeout of a User Task Run throws an ERROR
   * rather than an EXCEPTION.
   */
  onCancellationExceptionName?: VariableAssignment | undefined;
}

/** This is a boolean expression used to evaluate whether an Edge is valid. */
export interface EdgeCondition {
  /** The Operator used to evaluate the left versus the right. */
  comparator: Comparator;
  /** The left side of the boolean expression. */
  left:
    | VariableAssignment
    | undefined;
  /** The right side of the Boolean Expression. */
  right: VariableAssignment | undefined;
}

/** The Edge is the line in the workflow that connects one Node to another. */
export interface Edge {
  /** The name of the Node that the Edge points to. */
  sinkNodeName: string;
  /**
   * The Condition on which this Edge will be traversed. When choosing an Edge
   * to travel after the completion of a NodeRun, the Edges are evaluated in
   * order. The first one to either have no condition or have a condition which
   * evaluates to `true` is taken.
   */
  condition?:
    | EdgeCondition
    | undefined;
  /** Ordered list of Variable Mutations to execute when traversing this Edge. */
  variableMutations: VariableMutation[];
}

/** NOP node has no operations and is used for conditional branching. */
export interface NopNode {
}

/**
 * Sleep Node causes the WfRun to wait a specified time and then resume.
 *
 * There is no output.
 */
export interface SleepNode {
  sleepLength?:
    | { $case: "rawSeconds"; value: VariableAssignment }
    | { $case: "timestamp"; value: VariableAssignment }
    | { $case: "isoDate"; value: VariableAssignment }
    | undefined;
}

/**
 * EXPERIMENTAL: Specification for how to migrate an in-flight WfRun from one WfSpec
 * to another WfSpec version.
 */
export interface WfSpecVersionMigration {
  /** The major version of the WfSpec that we are migrating to. */
  newMajorVersion: number;
  /** The revision of the WfSpec that we are migrating to. */
  newRevision: number;
  /**
   * Map from ThreadSpec name to a specifier determining how to migrate ThreadRun's
   * to the new version of the WfSpec.
   */
  threadSpecMigrations: { [key: string]: ThreadSpecMigration };
}

export interface WfSpecVersionMigration_ThreadSpecMigrationsEntry {
  key: string;
  value: ThreadSpecMigration | undefined;
}

/**
 * EXPERIMENTAL: Specification for how to migrate a ThreadRun of a specific ThreadSpec
 * from one WfSpec to another WfSpec version.
 */
export interface ThreadSpecMigration {
  /**
   * The name of the ThreadSpec in the new WfSpec that this ThreadSpec should
   * migrate to.
   */
  newThreadSpecName: string;
  /**
   * Map from name of the nodes on the current ThreadSpec to the migration
   * to perform on it to move it to a new WfSpec.
   */
  nodeMigrations: { [key: string]: NodeMigration };
}

export interface ThreadSpecMigration_NodeMigrationsEntry {
  key: string;
  value: NodeMigration | undefined;
}

/**
 * EXPERIMENTAL: Specification for migrating a WfRun from a Node in one WfSpec
 * to a Node in another WfSpec version.
 */
export interface NodeMigration {
  /** The name of the Node on the new WfSpec to move to. */
  newNodeName: string;
}

function createBaseWfSpec(): WfSpec {
  return {
    id: undefined,
    createdAt: undefined,
    frozenVariables: [],
    status: MetadataStatus.ACTIVE,
    threadSpecs: {},
    entrypointThreadName: "",
    retentionPolicy: undefined,
    migration: undefined,
    parentWfSpec: undefined,
  };
}

export const WfSpec = {
  encode(message: WfSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      WfSpecId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.frozenVariables) {
      ThreadVarDef.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.status !== MetadataStatus.ACTIVE) {
      writer.uint32(32).int32(metadataStatusToNumber(message.status));
    }
    Object.entries(message.threadSpecs).forEach(([key, value]) => {
      WfSpec_ThreadSpecsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    if (message.entrypointThreadName !== "") {
      writer.uint32(50).string(message.entrypointThreadName);
    }
    if (message.retentionPolicy !== undefined) {
      WorkflowRetentionPolicy.encode(message.retentionPolicy, writer.uint32(58).fork()).ldelim();
    }
    if (message.migration !== undefined) {
      WfSpecVersionMigration.encode(message.migration, writer.uint32(66).fork()).ldelim();
    }
    if (message.parentWfSpec !== undefined) {
      WfSpec_ParentWfSpecReference.encode(message.parentWfSpec, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpec {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.frozenVariables.push(ThreadVarDef.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = metadataStatusFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = WfSpec_ThreadSpecsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.threadSpecs[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.entrypointThreadName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.retentionPolicy = WorkflowRetentionPolicy.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.migration = WfSpecVersionMigration.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.parentWfSpec = WfSpec_ParentWfSpecReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WfSpec {
    return {
      id: isSet(object.id) ? WfSpecId.fromJSON(object.id) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : undefined,
      frozenVariables: globalThis.Array.isArray(object?.frozenVariables)
        ? object.frozenVariables.map((e: any) => ThreadVarDef.fromJSON(e))
        : [],
      status: isSet(object.status) ? metadataStatusFromJSON(object.status) : MetadataStatus.ACTIVE,
      threadSpecs: isObject(object.threadSpecs)
        ? Object.entries(object.threadSpecs).reduce<{ [key: string]: ThreadSpec }>((acc, [key, value]) => {
          acc[key] = ThreadSpec.fromJSON(value);
          return acc;
        }, {})
        : {},
      entrypointThreadName: isSet(object.entrypointThreadName) ? globalThis.String(object.entrypointThreadName) : "",
      retentionPolicy: isSet(object.retentionPolicy)
        ? WorkflowRetentionPolicy.fromJSON(object.retentionPolicy)
        : undefined,
      migration: isSet(object.migration) ? WfSpecVersionMigration.fromJSON(object.migration) : undefined,
      parentWfSpec: isSet(object.parentWfSpec) ? WfSpec_ParentWfSpecReference.fromJSON(object.parentWfSpec) : undefined,
    };
  },

  toJSON(message: WfSpec): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = WfSpecId.toJSON(message.id);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt;
    }
    if (message.frozenVariables?.length) {
      obj.frozenVariables = message.frozenVariables.map((e) => ThreadVarDef.toJSON(e));
    }
    if (message.status !== MetadataStatus.ACTIVE) {
      obj.status = metadataStatusToJSON(message.status);
    }
    if (message.threadSpecs) {
      const entries = Object.entries(message.threadSpecs);
      if (entries.length > 0) {
        obj.threadSpecs = {};
        entries.forEach(([k, v]) => {
          obj.threadSpecs[k] = ThreadSpec.toJSON(v);
        });
      }
    }
    if (message.entrypointThreadName !== "") {
      obj.entrypointThreadName = message.entrypointThreadName;
    }
    if (message.retentionPolicy !== undefined) {
      obj.retentionPolicy = WorkflowRetentionPolicy.toJSON(message.retentionPolicy);
    }
    if (message.migration !== undefined) {
      obj.migration = WfSpecVersionMigration.toJSON(message.migration);
    }
    if (message.parentWfSpec !== undefined) {
      obj.parentWfSpec = WfSpec_ParentWfSpecReference.toJSON(message.parentWfSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<WfSpec>): WfSpec {
    return WfSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WfSpec>): WfSpec {
    const message = createBaseWfSpec();
    message.id = (object.id !== undefined && object.id !== null) ? WfSpecId.fromPartial(object.id) : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.frozenVariables = object.frozenVariables?.map((e) => ThreadVarDef.fromPartial(e)) || [];
    message.status = object.status ?? MetadataStatus.ACTIVE;
    message.threadSpecs = Object.entries(object.threadSpecs ?? {}).reduce<{ [key: string]: ThreadSpec }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ThreadSpec.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.entrypointThreadName = object.entrypointThreadName ?? "";
    message.retentionPolicy = (object.retentionPolicy !== undefined && object.retentionPolicy !== null)
      ? WorkflowRetentionPolicy.fromPartial(object.retentionPolicy)
      : undefined;
    message.migration = (object.migration !== undefined && object.migration !== null)
      ? WfSpecVersionMigration.fromPartial(object.migration)
      : undefined;
    message.parentWfSpec = (object.parentWfSpec !== undefined && object.parentWfSpec !== null)
      ? WfSpec_ParentWfSpecReference.fromPartial(object.parentWfSpec)
      : undefined;
    return message;
  },
};

function createBaseWfSpec_ThreadSpecsEntry(): WfSpec_ThreadSpecsEntry {
  return { key: "", value: undefined };
}

export const WfSpec_ThreadSpecsEntry = {
  encode(message: WfSpec_ThreadSpecsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ThreadSpec.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpec_ThreadSpecsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpec_ThreadSpecsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ThreadSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WfSpec_ThreadSpecsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ThreadSpec.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: WfSpec_ThreadSpecsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ThreadSpec.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<WfSpec_ThreadSpecsEntry>): WfSpec_ThreadSpecsEntry {
    return WfSpec_ThreadSpecsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WfSpec_ThreadSpecsEntry>): WfSpec_ThreadSpecsEntry {
    const message = createBaseWfSpec_ThreadSpecsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ThreadSpec.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseWfSpec_ParentWfSpecReference(): WfSpec_ParentWfSpecReference {
  return { wfSpecName: "", wfSpecMajorVersion: 0 };
}

export const WfSpec_ParentWfSpecReference = {
  encode(message: WfSpec_ParentWfSpecReference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpecName !== "") {
      writer.uint32(10).string(message.wfSpecName);
    }
    if (message.wfSpecMajorVersion !== 0) {
      writer.uint32(16).int32(message.wfSpecMajorVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpec_ParentWfSpecReference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpec_ParentWfSpecReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpecName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.wfSpecMajorVersion = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WfSpec_ParentWfSpecReference {
    return {
      wfSpecName: isSet(object.wfSpecName) ? globalThis.String(object.wfSpecName) : "",
      wfSpecMajorVersion: isSet(object.wfSpecMajorVersion) ? globalThis.Number(object.wfSpecMajorVersion) : 0,
    };
  },

  toJSON(message: WfSpec_ParentWfSpecReference): unknown {
    const obj: any = {};
    if (message.wfSpecName !== "") {
      obj.wfSpecName = message.wfSpecName;
    }
    if (message.wfSpecMajorVersion !== 0) {
      obj.wfSpecMajorVersion = Math.round(message.wfSpecMajorVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<WfSpec_ParentWfSpecReference>): WfSpec_ParentWfSpecReference {
    return WfSpec_ParentWfSpecReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WfSpec_ParentWfSpecReference>): WfSpec_ParentWfSpecReference {
    const message = createBaseWfSpec_ParentWfSpecReference();
    message.wfSpecName = object.wfSpecName ?? "";
    message.wfSpecMajorVersion = object.wfSpecMajorVersion ?? 0;
    return message;
  },
};

function createBaseWorkflowRetentionPolicy(): WorkflowRetentionPolicy {
  return { wfGcPolicy: undefined };
}

export const WorkflowRetentionPolicy = {
  encode(message: WorkflowRetentionPolicy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.wfGcPolicy?.$case) {
      case "secondsAfterWfTermination":
        writer.uint32(8).int64(message.wfGcPolicy.value);
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowRetentionPolicy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowRetentionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.wfGcPolicy = { $case: "secondsAfterWfTermination", value: longToNumber(reader.int64() as Long) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowRetentionPolicy {
    return {
      wfGcPolicy: isSet(object.secondsAfterWfTermination)
        ? { $case: "secondsAfterWfTermination", value: globalThis.Number(object.secondsAfterWfTermination) }
        : undefined,
    };
  },

  toJSON(message: WorkflowRetentionPolicy): unknown {
    const obj: any = {};
    if (message.wfGcPolicy?.$case === "secondsAfterWfTermination") {
      obj.secondsAfterWfTermination = Math.round(message.wfGcPolicy.value);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkflowRetentionPolicy>): WorkflowRetentionPolicy {
    return WorkflowRetentionPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowRetentionPolicy>): WorkflowRetentionPolicy {
    const message = createBaseWorkflowRetentionPolicy();
    if (
      object.wfGcPolicy?.$case === "secondsAfterWfTermination" &&
      object.wfGcPolicy?.value !== undefined &&
      object.wfGcPolicy?.value !== null
    ) {
      message.wfGcPolicy = { $case: "secondsAfterWfTermination", value: object.wfGcPolicy.value };
    }
    return message;
  },
};

function createBaseJsonIndex(): JsonIndex {
  return { fieldPath: "", fieldType: VariableType.JSON_OBJ };
}

export const JsonIndex = {
  encode(message: JsonIndex, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fieldPath !== "") {
      writer.uint32(10).string(message.fieldPath);
    }
    if (message.fieldType !== VariableType.JSON_OBJ) {
      writer.uint32(16).int32(variableTypeToNumber(message.fieldType));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): JsonIndex {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsonIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldPath = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fieldType = variableTypeFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JsonIndex {
    return {
      fieldPath: isSet(object.fieldPath) ? globalThis.String(object.fieldPath) : "",
      fieldType: isSet(object.fieldType) ? variableTypeFromJSON(object.fieldType) : VariableType.JSON_OBJ,
    };
  },

  toJSON(message: JsonIndex): unknown {
    const obj: any = {};
    if (message.fieldPath !== "") {
      obj.fieldPath = message.fieldPath;
    }
    if (message.fieldType !== VariableType.JSON_OBJ) {
      obj.fieldType = variableTypeToJSON(message.fieldType);
    }
    return obj;
  },

  create(base?: DeepPartial<JsonIndex>): JsonIndex {
    return JsonIndex.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JsonIndex>): JsonIndex {
    const message = createBaseJsonIndex();
    message.fieldPath = object.fieldPath ?? "";
    message.fieldType = object.fieldType ?? VariableType.JSON_OBJ;
    return message;
  },
};

function createBaseThreadVarDef(): ThreadVarDef {
  return {
    varDef: undefined,
    required: false,
    searchable: false,
    jsonIndexes: [],
    accessLevel: WfRunVariableAccessLevel.PUBLIC_VAR,
  };
}

export const ThreadVarDef = {
  encode(message: ThreadVarDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.varDef !== undefined) {
      VariableDef.encode(message.varDef, writer.uint32(10).fork()).ldelim();
    }
    if (message.required !== false) {
      writer.uint32(16).bool(message.required);
    }
    if (message.searchable !== false) {
      writer.uint32(24).bool(message.searchable);
    }
    for (const v of message.jsonIndexes) {
      JsonIndex.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.accessLevel !== WfRunVariableAccessLevel.PUBLIC_VAR) {
      writer.uint32(40).int32(wfRunVariableAccessLevelToNumber(message.accessLevel));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadVarDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadVarDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.varDef = VariableDef.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.required = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.searchable = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.jsonIndexes.push(JsonIndex.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.accessLevel = wfRunVariableAccessLevelFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThreadVarDef {
    return {
      varDef: isSet(object.varDef) ? VariableDef.fromJSON(object.varDef) : undefined,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      searchable: isSet(object.searchable) ? globalThis.Boolean(object.searchable) : false,
      jsonIndexes: globalThis.Array.isArray(object?.jsonIndexes)
        ? object.jsonIndexes.map((e: any) => JsonIndex.fromJSON(e))
        : [],
      accessLevel: isSet(object.accessLevel)
        ? wfRunVariableAccessLevelFromJSON(object.accessLevel)
        : WfRunVariableAccessLevel.PUBLIC_VAR,
    };
  },

  toJSON(message: ThreadVarDef): unknown {
    const obj: any = {};
    if (message.varDef !== undefined) {
      obj.varDef = VariableDef.toJSON(message.varDef);
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.searchable !== false) {
      obj.searchable = message.searchable;
    }
    if (message.jsonIndexes?.length) {
      obj.jsonIndexes = message.jsonIndexes.map((e) => JsonIndex.toJSON(e));
    }
    if (message.accessLevel !== WfRunVariableAccessLevel.PUBLIC_VAR) {
      obj.accessLevel = wfRunVariableAccessLevelToJSON(message.accessLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<ThreadVarDef>): ThreadVarDef {
    return ThreadVarDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreadVarDef>): ThreadVarDef {
    const message = createBaseThreadVarDef();
    message.varDef = (object.varDef !== undefined && object.varDef !== null)
      ? VariableDef.fromPartial(object.varDef)
      : undefined;
    message.required = object.required ?? false;
    message.searchable = object.searchable ?? false;
    message.jsonIndexes = object.jsonIndexes?.map((e) => JsonIndex.fromPartial(e)) || [];
    message.accessLevel = object.accessLevel ?? WfRunVariableAccessLevel.PUBLIC_VAR;
    return message;
  },
};

function createBaseThreadSpec(): ThreadSpec {
  return { nodes: {}, variableDefs: [], interruptDefs: [], retentionPolicy: undefined };
}

export const ThreadSpec = {
  encode(message: ThreadSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.nodes).forEach(([key, value]) => {
      ThreadSpec_NodesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    for (const v of message.variableDefs) {
      ThreadVarDef.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.interruptDefs) {
      InterruptDef.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.retentionPolicy !== undefined) {
      ThreadRetentionPolicy.encode(message.retentionPolicy, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadSpec {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ThreadSpec_NodesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.nodes[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.variableDefs.push(ThreadVarDef.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.interruptDefs.push(InterruptDef.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.retentionPolicy = ThreadRetentionPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThreadSpec {
    return {
      nodes: isObject(object.nodes)
        ? Object.entries(object.nodes).reduce<{ [key: string]: Node }>((acc, [key, value]) => {
          acc[key] = Node.fromJSON(value);
          return acc;
        }, {})
        : {},
      variableDefs: globalThis.Array.isArray(object?.variableDefs)
        ? object.variableDefs.map((e: any) => ThreadVarDef.fromJSON(e))
        : [],
      interruptDefs: globalThis.Array.isArray(object?.interruptDefs)
        ? object.interruptDefs.map((e: any) => InterruptDef.fromJSON(e))
        : [],
      retentionPolicy: isSet(object.retentionPolicy)
        ? ThreadRetentionPolicy.fromJSON(object.retentionPolicy)
        : undefined,
    };
  },

  toJSON(message: ThreadSpec): unknown {
    const obj: any = {};
    if (message.nodes) {
      const entries = Object.entries(message.nodes);
      if (entries.length > 0) {
        obj.nodes = {};
        entries.forEach(([k, v]) => {
          obj.nodes[k] = Node.toJSON(v);
        });
      }
    }
    if (message.variableDefs?.length) {
      obj.variableDefs = message.variableDefs.map((e) => ThreadVarDef.toJSON(e));
    }
    if (message.interruptDefs?.length) {
      obj.interruptDefs = message.interruptDefs.map((e) => InterruptDef.toJSON(e));
    }
    if (message.retentionPolicy !== undefined) {
      obj.retentionPolicy = ThreadRetentionPolicy.toJSON(message.retentionPolicy);
    }
    return obj;
  },

  create(base?: DeepPartial<ThreadSpec>): ThreadSpec {
    return ThreadSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreadSpec>): ThreadSpec {
    const message = createBaseThreadSpec();
    message.nodes = Object.entries(object.nodes ?? {}).reduce<{ [key: string]: Node }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Node.fromPartial(value);
      }
      return acc;
    }, {});
    message.variableDefs = object.variableDefs?.map((e) => ThreadVarDef.fromPartial(e)) || [];
    message.interruptDefs = object.interruptDefs?.map((e) => InterruptDef.fromPartial(e)) || [];
    message.retentionPolicy = (object.retentionPolicy !== undefined && object.retentionPolicy !== null)
      ? ThreadRetentionPolicy.fromPartial(object.retentionPolicy)
      : undefined;
    return message;
  },
};

function createBaseThreadSpec_NodesEntry(): ThreadSpec_NodesEntry {
  return { key: "", value: undefined };
}

export const ThreadSpec_NodesEntry = {
  encode(message: ThreadSpec_NodesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Node.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadSpec_NodesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadSpec_NodesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Node.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThreadSpec_NodesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Node.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ThreadSpec_NodesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Node.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ThreadSpec_NodesEntry>): ThreadSpec_NodesEntry {
    return ThreadSpec_NodesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreadSpec_NodesEntry>): ThreadSpec_NodesEntry {
    const message = createBaseThreadSpec_NodesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Node.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseThreadRetentionPolicy(): ThreadRetentionPolicy {
  return { threadGcPolicy: undefined };
}

export const ThreadRetentionPolicy = {
  encode(message: ThreadRetentionPolicy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.threadGcPolicy?.$case) {
      case "secondsAfterThreadTermination":
        writer.uint32(8).int64(message.threadGcPolicy.value);
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadRetentionPolicy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadRetentionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.threadGcPolicy = {
            $case: "secondsAfterThreadTermination",
            value: longToNumber(reader.int64() as Long),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThreadRetentionPolicy {
    return {
      threadGcPolicy: isSet(object.secondsAfterThreadTermination)
        ? { $case: "secondsAfterThreadTermination", value: globalThis.Number(object.secondsAfterThreadTermination) }
        : undefined,
    };
  },

  toJSON(message: ThreadRetentionPolicy): unknown {
    const obj: any = {};
    if (message.threadGcPolicy?.$case === "secondsAfterThreadTermination") {
      obj.secondsAfterThreadTermination = Math.round(message.threadGcPolicy.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ThreadRetentionPolicy>): ThreadRetentionPolicy {
    return ThreadRetentionPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreadRetentionPolicy>): ThreadRetentionPolicy {
    const message = createBaseThreadRetentionPolicy();
    if (
      object.threadGcPolicy?.$case === "secondsAfterThreadTermination" &&
      object.threadGcPolicy?.value !== undefined &&
      object.threadGcPolicy?.value !== null
    ) {
      message.threadGcPolicy = { $case: "secondsAfterThreadTermination", value: object.threadGcPolicy.value };
    }
    return message;
  },
};

function createBaseInterruptDef(): InterruptDef {
  return { externalEventDefId: undefined, handlerSpecName: "" };
}

export const InterruptDef = {
  encode(message: InterruptDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.externalEventDefId !== undefined) {
      ExternalEventDefId.encode(message.externalEventDefId, writer.uint32(10).fork()).ldelim();
    }
    if (message.handlerSpecName !== "") {
      writer.uint32(18).string(message.handlerSpecName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InterruptDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterruptDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalEventDefId = ExternalEventDefId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.handlerSpecName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterruptDef {
    return {
      externalEventDefId: isSet(object.externalEventDefId)
        ? ExternalEventDefId.fromJSON(object.externalEventDefId)
        : undefined,
      handlerSpecName: isSet(object.handlerSpecName) ? globalThis.String(object.handlerSpecName) : "",
    };
  },

  toJSON(message: InterruptDef): unknown {
    const obj: any = {};
    if (message.externalEventDefId !== undefined) {
      obj.externalEventDefId = ExternalEventDefId.toJSON(message.externalEventDefId);
    }
    if (message.handlerSpecName !== "") {
      obj.handlerSpecName = message.handlerSpecName;
    }
    return obj;
  },

  create(base?: DeepPartial<InterruptDef>): InterruptDef {
    return InterruptDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterruptDef>): InterruptDef {
    const message = createBaseInterruptDef();
    message.externalEventDefId = (object.externalEventDefId !== undefined && object.externalEventDefId !== null)
      ? ExternalEventDefId.fromPartial(object.externalEventDefId)
      : undefined;
    message.handlerSpecName = object.handlerSpecName ?? "";
    return message;
  },
};

function createBaseStartThreadNode(): StartThreadNode {
  return { threadSpecName: "", variables: {} };
}

export const StartThreadNode = {
  encode(message: StartThreadNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.threadSpecName !== "") {
      writer.uint32(10).string(message.threadSpecName);
    }
    Object.entries(message.variables).forEach(([key, value]) => {
      StartThreadNode_VariablesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartThreadNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartThreadNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threadSpecName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = StartThreadNode_VariablesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.variables[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartThreadNode {
    return {
      threadSpecName: isSet(object.threadSpecName) ? globalThis.String(object.threadSpecName) : "",
      variables: isObject(object.variables)
        ? Object.entries(object.variables).reduce<{ [key: string]: VariableAssignment }>((acc, [key, value]) => {
          acc[key] = VariableAssignment.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: StartThreadNode): unknown {
    const obj: any = {};
    if (message.threadSpecName !== "") {
      obj.threadSpecName = message.threadSpecName;
    }
    if (message.variables) {
      const entries = Object.entries(message.variables);
      if (entries.length > 0) {
        obj.variables = {};
        entries.forEach(([k, v]) => {
          obj.variables[k] = VariableAssignment.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<StartThreadNode>): StartThreadNode {
    return StartThreadNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartThreadNode>): StartThreadNode {
    const message = createBaseStartThreadNode();
    message.threadSpecName = object.threadSpecName ?? "";
    message.variables = Object.entries(object.variables ?? {}).reduce<{ [key: string]: VariableAssignment }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = VariableAssignment.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseStartThreadNode_VariablesEntry(): StartThreadNode_VariablesEntry {
  return { key: "", value: undefined };
}

export const StartThreadNode_VariablesEntry = {
  encode(message: StartThreadNode_VariablesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      VariableAssignment.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartThreadNode_VariablesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartThreadNode_VariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartThreadNode_VariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? VariableAssignment.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: StartThreadNode_VariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = VariableAssignment.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<StartThreadNode_VariablesEntry>): StartThreadNode_VariablesEntry {
    return StartThreadNode_VariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartThreadNode_VariablesEntry>): StartThreadNode_VariablesEntry {
    const message = createBaseStartThreadNode_VariablesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableAssignment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseStartMultipleThreadsNode(): StartMultipleThreadsNode {
  return { threadSpecName: "", variables: {}, iterable: undefined };
}

export const StartMultipleThreadsNode = {
  encode(message: StartMultipleThreadsNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.threadSpecName !== "") {
      writer.uint32(10).string(message.threadSpecName);
    }
    Object.entries(message.variables).forEach(([key, value]) => {
      StartMultipleThreadsNode_VariablesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.iterable !== undefined) {
      VariableAssignment.encode(message.iterable, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartMultipleThreadsNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartMultipleThreadsNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threadSpecName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = StartMultipleThreadsNode_VariablesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.variables[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.iterable = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartMultipleThreadsNode {
    return {
      threadSpecName: isSet(object.threadSpecName) ? globalThis.String(object.threadSpecName) : "",
      variables: isObject(object.variables)
        ? Object.entries(object.variables).reduce<{ [key: string]: VariableAssignment }>((acc, [key, value]) => {
          acc[key] = VariableAssignment.fromJSON(value);
          return acc;
        }, {})
        : {},
      iterable: isSet(object.iterable) ? VariableAssignment.fromJSON(object.iterable) : undefined,
    };
  },

  toJSON(message: StartMultipleThreadsNode): unknown {
    const obj: any = {};
    if (message.threadSpecName !== "") {
      obj.threadSpecName = message.threadSpecName;
    }
    if (message.variables) {
      const entries = Object.entries(message.variables);
      if (entries.length > 0) {
        obj.variables = {};
        entries.forEach(([k, v]) => {
          obj.variables[k] = VariableAssignment.toJSON(v);
        });
      }
    }
    if (message.iterable !== undefined) {
      obj.iterable = VariableAssignment.toJSON(message.iterable);
    }
    return obj;
  },

  create(base?: DeepPartial<StartMultipleThreadsNode>): StartMultipleThreadsNode {
    return StartMultipleThreadsNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartMultipleThreadsNode>): StartMultipleThreadsNode {
    const message = createBaseStartMultipleThreadsNode();
    message.threadSpecName = object.threadSpecName ?? "";
    message.variables = Object.entries(object.variables ?? {}).reduce<{ [key: string]: VariableAssignment }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = VariableAssignment.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.iterable = (object.iterable !== undefined && object.iterable !== null)
      ? VariableAssignment.fromPartial(object.iterable)
      : undefined;
    return message;
  },
};

function createBaseStartMultipleThreadsNode_VariablesEntry(): StartMultipleThreadsNode_VariablesEntry {
  return { key: "", value: undefined };
}

export const StartMultipleThreadsNode_VariablesEntry = {
  encode(message: StartMultipleThreadsNode_VariablesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      VariableAssignment.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartMultipleThreadsNode_VariablesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartMultipleThreadsNode_VariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartMultipleThreadsNode_VariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? VariableAssignment.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: StartMultipleThreadsNode_VariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = VariableAssignment.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<StartMultipleThreadsNode_VariablesEntry>): StartMultipleThreadsNode_VariablesEntry {
    return StartMultipleThreadsNode_VariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartMultipleThreadsNode_VariablesEntry>): StartMultipleThreadsNode_VariablesEntry {
    const message = createBaseStartMultipleThreadsNode_VariablesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableAssignment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFailureHandlerDef(): FailureHandlerDef {
  return { handlerSpecName: "", failureToCatch: undefined };
}

export const FailureHandlerDef = {
  encode(message: FailureHandlerDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.handlerSpecName !== "") {
      writer.uint32(18).string(message.handlerSpecName);
    }
    switch (message.failureToCatch?.$case) {
      case "specificFailure":
        writer.uint32(10).string(message.failureToCatch.value);
        break;
      case "anyFailureOfType":
        writer.uint32(24).int32(failureHandlerDef_LHFailureTypeToNumber(message.failureToCatch.value));
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FailureHandlerDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailureHandlerDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.handlerSpecName = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.failureToCatch = { $case: "specificFailure", value: reader.string() };
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failureToCatch = {
            $case: "anyFailureOfType",
            value: failureHandlerDef_LHFailureTypeFromJSON(reader.int32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FailureHandlerDef {
    return {
      handlerSpecName: isSet(object.handlerSpecName) ? globalThis.String(object.handlerSpecName) : "",
      failureToCatch: isSet(object.specificFailure)
        ? { $case: "specificFailure", value: globalThis.String(object.specificFailure) }
        : isSet(object.anyFailureOfType)
        ? { $case: "anyFailureOfType", value: failureHandlerDef_LHFailureTypeFromJSON(object.anyFailureOfType) }
        : undefined,
    };
  },

  toJSON(message: FailureHandlerDef): unknown {
    const obj: any = {};
    if (message.handlerSpecName !== "") {
      obj.handlerSpecName = message.handlerSpecName;
    }
    if (message.failureToCatch?.$case === "specificFailure") {
      obj.specificFailure = message.failureToCatch.value;
    }
    if (message.failureToCatch?.$case === "anyFailureOfType") {
      obj.anyFailureOfType = failureHandlerDef_LHFailureTypeToJSON(message.failureToCatch.value);
    }
    return obj;
  },

  create(base?: DeepPartial<FailureHandlerDef>): FailureHandlerDef {
    return FailureHandlerDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FailureHandlerDef>): FailureHandlerDef {
    const message = createBaseFailureHandlerDef();
    message.handlerSpecName = object.handlerSpecName ?? "";
    if (
      object.failureToCatch?.$case === "specificFailure" &&
      object.failureToCatch?.value !== undefined &&
      object.failureToCatch?.value !== null
    ) {
      message.failureToCatch = { $case: "specificFailure", value: object.failureToCatch.value };
    }
    if (
      object.failureToCatch?.$case === "anyFailureOfType" &&
      object.failureToCatch?.value !== undefined &&
      object.failureToCatch?.value !== null
    ) {
      message.failureToCatch = { $case: "anyFailureOfType", value: object.failureToCatch.value };
    }
    return message;
  },
};

function createBaseWaitForThreadsNode(): WaitForThreadsNode {
  return { threadsToWaitFor: undefined, perThreadFailureHandlers: [] };
}

export const WaitForThreadsNode = {
  encode(message: WaitForThreadsNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.threadsToWaitFor?.$case) {
      case "threads":
        WaitForThreadsNode_ThreadsToWaitFor.encode(message.threadsToWaitFor.value, writer.uint32(10).fork()).ldelim();
        break;
      case "threadList":
        VariableAssignment.encode(message.threadsToWaitFor.value, writer.uint32(18).fork()).ldelim();
        break;
    }
    for (const v of message.perThreadFailureHandlers) {
      FailureHandlerDef.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WaitForThreadsNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitForThreadsNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threadsToWaitFor = {
            $case: "threads",
            value: WaitForThreadsNode_ThreadsToWaitFor.decode(reader, reader.uint32()),
          };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.threadsToWaitFor = { $case: "threadList", value: VariableAssignment.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.perThreadFailureHandlers.push(FailureHandlerDef.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WaitForThreadsNode {
    return {
      threadsToWaitFor: isSet(object.threads)
        ? { $case: "threads", value: WaitForThreadsNode_ThreadsToWaitFor.fromJSON(object.threads) }
        : isSet(object.threadList)
        ? { $case: "threadList", value: VariableAssignment.fromJSON(object.threadList) }
        : undefined,
      perThreadFailureHandlers: globalThis.Array.isArray(object?.perThreadFailureHandlers)
        ? object.perThreadFailureHandlers.map((e: any) => FailureHandlerDef.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WaitForThreadsNode): unknown {
    const obj: any = {};
    if (message.threadsToWaitFor?.$case === "threads") {
      obj.threads = WaitForThreadsNode_ThreadsToWaitFor.toJSON(message.threadsToWaitFor.value);
    }
    if (message.threadsToWaitFor?.$case === "threadList") {
      obj.threadList = VariableAssignment.toJSON(message.threadsToWaitFor.value);
    }
    if (message.perThreadFailureHandlers?.length) {
      obj.perThreadFailureHandlers = message.perThreadFailureHandlers.map((e) => FailureHandlerDef.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WaitForThreadsNode>): WaitForThreadsNode {
    return WaitForThreadsNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WaitForThreadsNode>): WaitForThreadsNode {
    const message = createBaseWaitForThreadsNode();
    if (
      object.threadsToWaitFor?.$case === "threads" &&
      object.threadsToWaitFor?.value !== undefined &&
      object.threadsToWaitFor?.value !== null
    ) {
      message.threadsToWaitFor = {
        $case: "threads",
        value: WaitForThreadsNode_ThreadsToWaitFor.fromPartial(object.threadsToWaitFor.value),
      };
    }
    if (
      object.threadsToWaitFor?.$case === "threadList" &&
      object.threadsToWaitFor?.value !== undefined &&
      object.threadsToWaitFor?.value !== null
    ) {
      message.threadsToWaitFor = {
        $case: "threadList",
        value: VariableAssignment.fromPartial(object.threadsToWaitFor.value),
      };
    }
    message.perThreadFailureHandlers = object.perThreadFailureHandlers?.map((e) => FailureHandlerDef.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseWaitForThreadsNode_ThreadToWaitFor(): WaitForThreadsNode_ThreadToWaitFor {
  return { threadRunNumber: undefined };
}

export const WaitForThreadsNode_ThreadToWaitFor = {
  encode(message: WaitForThreadsNode_ThreadToWaitFor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.threadRunNumber !== undefined) {
      VariableAssignment.encode(message.threadRunNumber, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WaitForThreadsNode_ThreadToWaitFor {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitForThreadsNode_ThreadToWaitFor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threadRunNumber = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WaitForThreadsNode_ThreadToWaitFor {
    return {
      threadRunNumber: isSet(object.threadRunNumber) ? VariableAssignment.fromJSON(object.threadRunNumber) : undefined,
    };
  },

  toJSON(message: WaitForThreadsNode_ThreadToWaitFor): unknown {
    const obj: any = {};
    if (message.threadRunNumber !== undefined) {
      obj.threadRunNumber = VariableAssignment.toJSON(message.threadRunNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<WaitForThreadsNode_ThreadToWaitFor>): WaitForThreadsNode_ThreadToWaitFor {
    return WaitForThreadsNode_ThreadToWaitFor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WaitForThreadsNode_ThreadToWaitFor>): WaitForThreadsNode_ThreadToWaitFor {
    const message = createBaseWaitForThreadsNode_ThreadToWaitFor();
    message.threadRunNumber = (object.threadRunNumber !== undefined && object.threadRunNumber !== null)
      ? VariableAssignment.fromPartial(object.threadRunNumber)
      : undefined;
    return message;
  },
};

function createBaseWaitForThreadsNode_ThreadsToWaitFor(): WaitForThreadsNode_ThreadsToWaitFor {
  return { threads: [] };
}

export const WaitForThreadsNode_ThreadsToWaitFor = {
  encode(message: WaitForThreadsNode_ThreadsToWaitFor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.threads) {
      WaitForThreadsNode_ThreadToWaitFor.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WaitForThreadsNode_ThreadsToWaitFor {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitForThreadsNode_ThreadsToWaitFor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threads.push(WaitForThreadsNode_ThreadToWaitFor.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WaitForThreadsNode_ThreadsToWaitFor {
    return {
      threads: globalThis.Array.isArray(object?.threads)
        ? object.threads.map((e: any) => WaitForThreadsNode_ThreadToWaitFor.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WaitForThreadsNode_ThreadsToWaitFor): unknown {
    const obj: any = {};
    if (message.threads?.length) {
      obj.threads = message.threads.map((e) => WaitForThreadsNode_ThreadToWaitFor.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WaitForThreadsNode_ThreadsToWaitFor>): WaitForThreadsNode_ThreadsToWaitFor {
    return WaitForThreadsNode_ThreadsToWaitFor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WaitForThreadsNode_ThreadsToWaitFor>): WaitForThreadsNode_ThreadsToWaitFor {
    const message = createBaseWaitForThreadsNode_ThreadsToWaitFor();
    message.threads = object.threads?.map((e) => WaitForThreadsNode_ThreadToWaitFor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExternalEventNode(): ExternalEventNode {
  return {
    externalEventDefId: undefined,
    timeoutSeconds: undefined,
    correlationKey: undefined,
    maskCorrelationKey: false,
  };
}

export const ExternalEventNode = {
  encode(message: ExternalEventNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.externalEventDefId !== undefined) {
      ExternalEventDefId.encode(message.externalEventDefId, writer.uint32(10).fork()).ldelim();
    }
    if (message.timeoutSeconds !== undefined) {
      VariableAssignment.encode(message.timeoutSeconds, writer.uint32(18).fork()).ldelim();
    }
    if (message.correlationKey !== undefined) {
      VariableAssignment.encode(message.correlationKey, writer.uint32(26).fork()).ldelim();
    }
    if (message.maskCorrelationKey !== false) {
      writer.uint32(32).bool(message.maskCorrelationKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExternalEventNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalEventNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalEventDefId = ExternalEventDefId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeoutSeconds = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.correlationKey = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maskCorrelationKey = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalEventNode {
    return {
      externalEventDefId: isSet(object.externalEventDefId)
        ? ExternalEventDefId.fromJSON(object.externalEventDefId)
        : undefined,
      timeoutSeconds: isSet(object.timeoutSeconds) ? VariableAssignment.fromJSON(object.timeoutSeconds) : undefined,
      correlationKey: isSet(object.correlationKey) ? VariableAssignment.fromJSON(object.correlationKey) : undefined,
      maskCorrelationKey: isSet(object.maskCorrelationKey) ? globalThis.Boolean(object.maskCorrelationKey) : false,
    };
  },

  toJSON(message: ExternalEventNode): unknown {
    const obj: any = {};
    if (message.externalEventDefId !== undefined) {
      obj.externalEventDefId = ExternalEventDefId.toJSON(message.externalEventDefId);
    }
    if (message.timeoutSeconds !== undefined) {
      obj.timeoutSeconds = VariableAssignment.toJSON(message.timeoutSeconds);
    }
    if (message.correlationKey !== undefined) {
      obj.correlationKey = VariableAssignment.toJSON(message.correlationKey);
    }
    if (message.maskCorrelationKey !== false) {
      obj.maskCorrelationKey = message.maskCorrelationKey;
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalEventNode>): ExternalEventNode {
    return ExternalEventNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalEventNode>): ExternalEventNode {
    const message = createBaseExternalEventNode();
    message.externalEventDefId = (object.externalEventDefId !== undefined && object.externalEventDefId !== null)
      ? ExternalEventDefId.fromPartial(object.externalEventDefId)
      : undefined;
    message.timeoutSeconds = (object.timeoutSeconds !== undefined && object.timeoutSeconds !== null)
      ? VariableAssignment.fromPartial(object.timeoutSeconds)
      : undefined;
    message.correlationKey = (object.correlationKey !== undefined && object.correlationKey !== null)
      ? VariableAssignment.fromPartial(object.correlationKey)
      : undefined;
    message.maskCorrelationKey = object.maskCorrelationKey ?? false;
    return message;
  },
};

function createBaseEntrypointNode(): EntrypointNode {
  return {};
}

export const EntrypointNode = {
  encode(_: EntrypointNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EntrypointNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntrypointNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EntrypointNode {
    return {};
  },

  toJSON(_: EntrypointNode): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<EntrypointNode>): EntrypointNode {
    return EntrypointNode.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<EntrypointNode>): EntrypointNode {
    const message = createBaseEntrypointNode();
    return message;
  },
};

function createBaseExitNode(): ExitNode {
  return { result: undefined };
}

export const ExitNode = {
  encode(message: ExitNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.result?.$case) {
      case "failureDef":
        FailureDef.encode(message.result.value, writer.uint32(10).fork()).ldelim();
        break;
      case "returnContent":
        VariableAssignment.encode(message.result.value, writer.uint32(18).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExitNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExitNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = { $case: "failureDef", value: FailureDef.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result = { $case: "returnContent", value: VariableAssignment.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExitNode {
    return {
      result: isSet(object.failureDef)
        ? { $case: "failureDef", value: FailureDef.fromJSON(object.failureDef) }
        : isSet(object.returnContent)
        ? { $case: "returnContent", value: VariableAssignment.fromJSON(object.returnContent) }
        : undefined,
    };
  },

  toJSON(message: ExitNode): unknown {
    const obj: any = {};
    if (message.result?.$case === "failureDef") {
      obj.failureDef = FailureDef.toJSON(message.result.value);
    }
    if (message.result?.$case === "returnContent") {
      obj.returnContent = VariableAssignment.toJSON(message.result.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ExitNode>): ExitNode {
    return ExitNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExitNode>): ExitNode {
    const message = createBaseExitNode();
    if (object.result?.$case === "failureDef" && object.result?.value !== undefined && object.result?.value !== null) {
      message.result = { $case: "failureDef", value: FailureDef.fromPartial(object.result.value) };
    }
    if (
      object.result?.$case === "returnContent" && object.result?.value !== undefined && object.result?.value !== null
    ) {
      message.result = { $case: "returnContent", value: VariableAssignment.fromPartial(object.result.value) };
    }
    return message;
  },
};

function createBaseFailureDef(): FailureDef {
  return { failureName: "", message: "", content: undefined };
}

export const FailureDef = {
  encode(message: FailureDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.failureName !== "") {
      writer.uint32(10).string(message.failureName);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.content !== undefined) {
      VariableAssignment.encode(message.content, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FailureDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailureDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.failureName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FailureDef {
    return {
      failureName: isSet(object.failureName) ? globalThis.String(object.failureName) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      content: isSet(object.content) ? VariableAssignment.fromJSON(object.content) : undefined,
    };
  },

  toJSON(message: FailureDef): unknown {
    const obj: any = {};
    if (message.failureName !== "") {
      obj.failureName = message.failureName;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.content !== undefined) {
      obj.content = VariableAssignment.toJSON(message.content);
    }
    return obj;
  },

  create(base?: DeepPartial<FailureDef>): FailureDef {
    return FailureDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FailureDef>): FailureDef {
    const message = createBaseFailureDef();
    message.failureName = object.failureName ?? "";
    message.message = object.message ?? "";
    message.content = (object.content !== undefined && object.content !== null)
      ? VariableAssignment.fromPartial(object.content)
      : undefined;
    return message;
  },
};

function createBaseNode(): Node {
  return { outgoingEdges: [], failureHandlers: [], node: undefined };
}

export const Node = {
  encode(message: Node, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.outgoingEdges) {
      Edge.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.failureHandlers) {
      FailureHandlerDef.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    switch (message.node?.$case) {
      case "entrypoint":
        EntrypointNode.encode(message.node.value, writer.uint32(42).fork()).ldelim();
        break;
      case "exit":
        ExitNode.encode(message.node.value, writer.uint32(50).fork()).ldelim();
        break;
      case "task":
        TaskNode.encode(message.node.value, writer.uint32(58).fork()).ldelim();
        break;
      case "externalEvent":
        ExternalEventNode.encode(message.node.value, writer.uint32(66).fork()).ldelim();
        break;
      case "startThread":
        StartThreadNode.encode(message.node.value, writer.uint32(74).fork()).ldelim();
        break;
      case "waitForThreads":
        WaitForThreadsNode.encode(message.node.value, writer.uint32(82).fork()).ldelim();
        break;
      case "nop":
        NopNode.encode(message.node.value, writer.uint32(90).fork()).ldelim();
        break;
      case "sleep":
        SleepNode.encode(message.node.value, writer.uint32(98).fork()).ldelim();
        break;
      case "userTask":
        UserTaskNode.encode(message.node.value, writer.uint32(106).fork()).ldelim();
        break;
      case "startMultipleThreads":
        StartMultipleThreadsNode.encode(message.node.value, writer.uint32(122).fork()).ldelim();
        break;
      case "throwEvent":
        ThrowEventNode.encode(message.node.value, writer.uint32(130).fork()).ldelim();
        break;
      case "waitForCondition":
        WaitForConditionNode.encode(message.node.value, writer.uint32(138).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Node {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outgoingEdges.push(Edge.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.failureHandlers.push(FailureHandlerDef.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.node = { $case: "entrypoint", value: EntrypointNode.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.node = { $case: "exit", value: ExitNode.decode(reader, reader.uint32()) };
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.node = { $case: "task", value: TaskNode.decode(reader, reader.uint32()) };
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.node = { $case: "externalEvent", value: ExternalEventNode.decode(reader, reader.uint32()) };
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.node = { $case: "startThread", value: StartThreadNode.decode(reader, reader.uint32()) };
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.node = { $case: "waitForThreads", value: WaitForThreadsNode.decode(reader, reader.uint32()) };
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.node = { $case: "nop", value: NopNode.decode(reader, reader.uint32()) };
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.node = { $case: "sleep", value: SleepNode.decode(reader, reader.uint32()) };
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.node = { $case: "userTask", value: UserTaskNode.decode(reader, reader.uint32()) };
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.node = {
            $case: "startMultipleThreads",
            value: StartMultipleThreadsNode.decode(reader, reader.uint32()),
          };
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.node = { $case: "throwEvent", value: ThrowEventNode.decode(reader, reader.uint32()) };
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.node = { $case: "waitForCondition", value: WaitForConditionNode.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      outgoingEdges: globalThis.Array.isArray(object?.outgoingEdges)
        ? object.outgoingEdges.map((e: any) => Edge.fromJSON(e))
        : [],
      failureHandlers: globalThis.Array.isArray(object?.failureHandlers)
        ? object.failureHandlers.map((e: any) => FailureHandlerDef.fromJSON(e))
        : [],
      node: isSet(object.entrypoint)
        ? { $case: "entrypoint", value: EntrypointNode.fromJSON(object.entrypoint) }
        : isSet(object.exit)
        ? { $case: "exit", value: ExitNode.fromJSON(object.exit) }
        : isSet(object.task)
        ? { $case: "task", value: TaskNode.fromJSON(object.task) }
        : isSet(object.externalEvent)
        ? { $case: "externalEvent", value: ExternalEventNode.fromJSON(object.externalEvent) }
        : isSet(object.startThread)
        ? { $case: "startThread", value: StartThreadNode.fromJSON(object.startThread) }
        : isSet(object.waitForThreads)
        ? { $case: "waitForThreads", value: WaitForThreadsNode.fromJSON(object.waitForThreads) }
        : isSet(object.nop)
        ? { $case: "nop", value: NopNode.fromJSON(object.nop) }
        : isSet(object.sleep)
        ? { $case: "sleep", value: SleepNode.fromJSON(object.sleep) }
        : isSet(object.userTask)
        ? { $case: "userTask", value: UserTaskNode.fromJSON(object.userTask) }
        : isSet(object.startMultipleThreads)
        ? { $case: "startMultipleThreads", value: StartMultipleThreadsNode.fromJSON(object.startMultipleThreads) }
        : isSet(object.throwEvent)
        ? { $case: "throwEvent", value: ThrowEventNode.fromJSON(object.throwEvent) }
        : isSet(object.waitForCondition)
        ? { $case: "waitForCondition", value: WaitForConditionNode.fromJSON(object.waitForCondition) }
        : undefined,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.outgoingEdges?.length) {
      obj.outgoingEdges = message.outgoingEdges.map((e) => Edge.toJSON(e));
    }
    if (message.failureHandlers?.length) {
      obj.failureHandlers = message.failureHandlers.map((e) => FailureHandlerDef.toJSON(e));
    }
    if (message.node?.$case === "entrypoint") {
      obj.entrypoint = EntrypointNode.toJSON(message.node.value);
    }
    if (message.node?.$case === "exit") {
      obj.exit = ExitNode.toJSON(message.node.value);
    }
    if (message.node?.$case === "task") {
      obj.task = TaskNode.toJSON(message.node.value);
    }
    if (message.node?.$case === "externalEvent") {
      obj.externalEvent = ExternalEventNode.toJSON(message.node.value);
    }
    if (message.node?.$case === "startThread") {
      obj.startThread = StartThreadNode.toJSON(message.node.value);
    }
    if (message.node?.$case === "waitForThreads") {
      obj.waitForThreads = WaitForThreadsNode.toJSON(message.node.value);
    }
    if (message.node?.$case === "nop") {
      obj.nop = NopNode.toJSON(message.node.value);
    }
    if (message.node?.$case === "sleep") {
      obj.sleep = SleepNode.toJSON(message.node.value);
    }
    if (message.node?.$case === "userTask") {
      obj.userTask = UserTaskNode.toJSON(message.node.value);
    }
    if (message.node?.$case === "startMultipleThreads") {
      obj.startMultipleThreads = StartMultipleThreadsNode.toJSON(message.node.value);
    }
    if (message.node?.$case === "throwEvent") {
      obj.throwEvent = ThrowEventNode.toJSON(message.node.value);
    }
    if (message.node?.$case === "waitForCondition") {
      obj.waitForCondition = WaitForConditionNode.toJSON(message.node.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Node>): Node {
    return Node.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node>): Node {
    const message = createBaseNode();
    message.outgoingEdges = object.outgoingEdges?.map((e) => Edge.fromPartial(e)) || [];
    message.failureHandlers = object.failureHandlers?.map((e) => FailureHandlerDef.fromPartial(e)) || [];
    if (object.node?.$case === "entrypoint" && object.node?.value !== undefined && object.node?.value !== null) {
      message.node = { $case: "entrypoint", value: EntrypointNode.fromPartial(object.node.value) };
    }
    if (object.node?.$case === "exit" && object.node?.value !== undefined && object.node?.value !== null) {
      message.node = { $case: "exit", value: ExitNode.fromPartial(object.node.value) };
    }
    if (object.node?.$case === "task" && object.node?.value !== undefined && object.node?.value !== null) {
      message.node = { $case: "task", value: TaskNode.fromPartial(object.node.value) };
    }
    if (object.node?.$case === "externalEvent" && object.node?.value !== undefined && object.node?.value !== null) {
      message.node = { $case: "externalEvent", value: ExternalEventNode.fromPartial(object.node.value) };
    }
    if (object.node?.$case === "startThread" && object.node?.value !== undefined && object.node?.value !== null) {
      message.node = { $case: "startThread", value: StartThreadNode.fromPartial(object.node.value) };
    }
    if (object.node?.$case === "waitForThreads" && object.node?.value !== undefined && object.node?.value !== null) {
      message.node = { $case: "waitForThreads", value: WaitForThreadsNode.fromPartial(object.node.value) };
    }
    if (object.node?.$case === "nop" && object.node?.value !== undefined && object.node?.value !== null) {
      message.node = { $case: "nop", value: NopNode.fromPartial(object.node.value) };
    }
    if (object.node?.$case === "sleep" && object.node?.value !== undefined && object.node?.value !== null) {
      message.node = { $case: "sleep", value: SleepNode.fromPartial(object.node.value) };
    }
    if (object.node?.$case === "userTask" && object.node?.value !== undefined && object.node?.value !== null) {
      message.node = { $case: "userTask", value: UserTaskNode.fromPartial(object.node.value) };
    }
    if (
      object.node?.$case === "startMultipleThreads" && object.node?.value !== undefined && object.node?.value !== null
    ) {
      message.node = { $case: "startMultipleThreads", value: StartMultipleThreadsNode.fromPartial(object.node.value) };
    }
    if (object.node?.$case === "throwEvent" && object.node?.value !== undefined && object.node?.value !== null) {
      message.node = { $case: "throwEvent", value: ThrowEventNode.fromPartial(object.node.value) };
    }
    if (object.node?.$case === "waitForCondition" && object.node?.value !== undefined && object.node?.value !== null) {
      message.node = { $case: "waitForCondition", value: WaitForConditionNode.fromPartial(object.node.value) };
    }
    return message;
  },
};

function createBaseWaitForConditionNode(): WaitForConditionNode {
  return { condition: undefined };
}

export const WaitForConditionNode = {
  encode(message: WaitForConditionNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.condition !== undefined) {
      EdgeCondition.encode(message.condition, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WaitForConditionNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitForConditionNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.condition = EdgeCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WaitForConditionNode {
    return { condition: isSet(object.condition) ? EdgeCondition.fromJSON(object.condition) : undefined };
  },

  toJSON(message: WaitForConditionNode): unknown {
    const obj: any = {};
    if (message.condition !== undefined) {
      obj.condition = EdgeCondition.toJSON(message.condition);
    }
    return obj;
  },

  create(base?: DeepPartial<WaitForConditionNode>): WaitForConditionNode {
    return WaitForConditionNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WaitForConditionNode>): WaitForConditionNode {
    const message = createBaseWaitForConditionNode();
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? EdgeCondition.fromPartial(object.condition)
      : undefined;
    return message;
  },
};

function createBaseThrowEventNode(): ThrowEventNode {
  return { eventDefId: undefined, content: undefined };
}

export const ThrowEventNode = {
  encode(message: ThrowEventNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventDefId !== undefined) {
      WorkflowEventDefId.encode(message.eventDefId, writer.uint32(10).fork()).ldelim();
    }
    if (message.content !== undefined) {
      VariableAssignment.encode(message.content, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThrowEventNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThrowEventNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventDefId = WorkflowEventDefId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThrowEventNode {
    return {
      eventDefId: isSet(object.eventDefId) ? WorkflowEventDefId.fromJSON(object.eventDefId) : undefined,
      content: isSet(object.content) ? VariableAssignment.fromJSON(object.content) : undefined,
    };
  },

  toJSON(message: ThrowEventNode): unknown {
    const obj: any = {};
    if (message.eventDefId !== undefined) {
      obj.eventDefId = WorkflowEventDefId.toJSON(message.eventDefId);
    }
    if (message.content !== undefined) {
      obj.content = VariableAssignment.toJSON(message.content);
    }
    return obj;
  },

  create(base?: DeepPartial<ThrowEventNode>): ThrowEventNode {
    return ThrowEventNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThrowEventNode>): ThrowEventNode {
    const message = createBaseThrowEventNode();
    message.eventDefId = (object.eventDefId !== undefined && object.eventDefId !== null)
      ? WorkflowEventDefId.fromPartial(object.eventDefId)
      : undefined;
    message.content = (object.content !== undefined && object.content !== null)
      ? VariableAssignment.fromPartial(object.content)
      : undefined;
    return message;
  },
};

function createBaseUserTaskNode(): UserTaskNode {
  return {
    userTaskDefName: "",
    userGroup: undefined,
    userId: undefined,
    actions: [],
    userTaskDefVersion: undefined,
    notes: undefined,
    onCancellationExceptionName: undefined,
  };
}

export const UserTaskNode = {
  encode(message: UserTaskNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userTaskDefName !== "") {
      writer.uint32(10).string(message.userTaskDefName);
    }
    if (message.userGroup !== undefined) {
      VariableAssignment.encode(message.userGroup, writer.uint32(18).fork()).ldelim();
    }
    if (message.userId !== undefined) {
      VariableAssignment.encode(message.userId, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.actions) {
      UTActionTrigger.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.userTaskDefVersion !== undefined) {
      writer.uint32(40).int32(message.userTaskDefVersion);
    }
    if (message.notes !== undefined) {
      VariableAssignment.encode(message.notes, writer.uint32(50).fork()).ldelim();
    }
    if (message.onCancellationExceptionName !== undefined) {
      VariableAssignment.encode(message.onCancellationExceptionName, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userTaskDefName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userGroup = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.actions.push(UTActionTrigger.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.userTaskDefVersion = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.notes = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.onCancellationExceptionName = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTaskNode {
    return {
      userTaskDefName: isSet(object.userTaskDefName) ? globalThis.String(object.userTaskDefName) : "",
      userGroup: isSet(object.userGroup) ? VariableAssignment.fromJSON(object.userGroup) : undefined,
      userId: isSet(object.userId) ? VariableAssignment.fromJSON(object.userId) : undefined,
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => UTActionTrigger.fromJSON(e))
        : [],
      userTaskDefVersion: isSet(object.userTaskDefVersion) ? globalThis.Number(object.userTaskDefVersion) : undefined,
      notes: isSet(object.notes) ? VariableAssignment.fromJSON(object.notes) : undefined,
      onCancellationExceptionName: isSet(object.onCancellationExceptionName)
        ? VariableAssignment.fromJSON(object.onCancellationExceptionName)
        : undefined,
    };
  },

  toJSON(message: UserTaskNode): unknown {
    const obj: any = {};
    if (message.userTaskDefName !== "") {
      obj.userTaskDefName = message.userTaskDefName;
    }
    if (message.userGroup !== undefined) {
      obj.userGroup = VariableAssignment.toJSON(message.userGroup);
    }
    if (message.userId !== undefined) {
      obj.userId = VariableAssignment.toJSON(message.userId);
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => UTActionTrigger.toJSON(e));
    }
    if (message.userTaskDefVersion !== undefined) {
      obj.userTaskDefVersion = Math.round(message.userTaskDefVersion);
    }
    if (message.notes !== undefined) {
      obj.notes = VariableAssignment.toJSON(message.notes);
    }
    if (message.onCancellationExceptionName !== undefined) {
      obj.onCancellationExceptionName = VariableAssignment.toJSON(message.onCancellationExceptionName);
    }
    return obj;
  },

  create(base?: DeepPartial<UserTaskNode>): UserTaskNode {
    return UserTaskNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskNode>): UserTaskNode {
    const message = createBaseUserTaskNode();
    message.userTaskDefName = object.userTaskDefName ?? "";
    message.userGroup = (object.userGroup !== undefined && object.userGroup !== null)
      ? VariableAssignment.fromPartial(object.userGroup)
      : undefined;
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? VariableAssignment.fromPartial(object.userId)
      : undefined;
    message.actions = object.actions?.map((e) => UTActionTrigger.fromPartial(e)) || [];
    message.userTaskDefVersion = object.userTaskDefVersion ?? undefined;
    message.notes = (object.notes !== undefined && object.notes !== null)
      ? VariableAssignment.fromPartial(object.notes)
      : undefined;
    message.onCancellationExceptionName =
      (object.onCancellationExceptionName !== undefined && object.onCancellationExceptionName !== null)
        ? VariableAssignment.fromPartial(object.onCancellationExceptionName)
        : undefined;
    return message;
  },
};

function createBaseEdgeCondition(): EdgeCondition {
  return { comparator: Comparator.LESS_THAN, left: undefined, right: undefined };
}

export const EdgeCondition = {
  encode(message: EdgeCondition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.comparator !== Comparator.LESS_THAN) {
      writer.uint32(8).int32(comparatorToNumber(message.comparator));
    }
    if (message.left !== undefined) {
      VariableAssignment.encode(message.left, writer.uint32(18).fork()).ldelim();
    }
    if (message.right !== undefined) {
      VariableAssignment.encode(message.right, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EdgeCondition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdgeCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.comparator = comparatorFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.left = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.right = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EdgeCondition {
    return {
      comparator: isSet(object.comparator) ? comparatorFromJSON(object.comparator) : Comparator.LESS_THAN,
      left: isSet(object.left) ? VariableAssignment.fromJSON(object.left) : undefined,
      right: isSet(object.right) ? VariableAssignment.fromJSON(object.right) : undefined,
    };
  },

  toJSON(message: EdgeCondition): unknown {
    const obj: any = {};
    if (message.comparator !== Comparator.LESS_THAN) {
      obj.comparator = comparatorToJSON(message.comparator);
    }
    if (message.left !== undefined) {
      obj.left = VariableAssignment.toJSON(message.left);
    }
    if (message.right !== undefined) {
      obj.right = VariableAssignment.toJSON(message.right);
    }
    return obj;
  },

  create(base?: DeepPartial<EdgeCondition>): EdgeCondition {
    return EdgeCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EdgeCondition>): EdgeCondition {
    const message = createBaseEdgeCondition();
    message.comparator = object.comparator ?? Comparator.LESS_THAN;
    message.left = (object.left !== undefined && object.left !== null)
      ? VariableAssignment.fromPartial(object.left)
      : undefined;
    message.right = (object.right !== undefined && object.right !== null)
      ? VariableAssignment.fromPartial(object.right)
      : undefined;
    return message;
  },
};

function createBaseEdge(): Edge {
  return { sinkNodeName: "", condition: undefined, variableMutations: [] };
}

export const Edge = {
  encode(message: Edge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sinkNodeName !== "") {
      writer.uint32(10).string(message.sinkNodeName);
    }
    if (message.condition !== undefined) {
      EdgeCondition.encode(message.condition, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.variableMutations) {
      VariableMutation.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Edge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sinkNodeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.condition = EdgeCondition.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.variableMutations.push(VariableMutation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Edge {
    return {
      sinkNodeName: isSet(object.sinkNodeName) ? globalThis.String(object.sinkNodeName) : "",
      condition: isSet(object.condition) ? EdgeCondition.fromJSON(object.condition) : undefined,
      variableMutations: globalThis.Array.isArray(object?.variableMutations)
        ? object.variableMutations.map((e: any) => VariableMutation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Edge): unknown {
    const obj: any = {};
    if (message.sinkNodeName !== "") {
      obj.sinkNodeName = message.sinkNodeName;
    }
    if (message.condition !== undefined) {
      obj.condition = EdgeCondition.toJSON(message.condition);
    }
    if (message.variableMutations?.length) {
      obj.variableMutations = message.variableMutations.map((e) => VariableMutation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Edge>): Edge {
    return Edge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Edge>): Edge {
    const message = createBaseEdge();
    message.sinkNodeName = object.sinkNodeName ?? "";
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? EdgeCondition.fromPartial(object.condition)
      : undefined;
    message.variableMutations = object.variableMutations?.map((e) => VariableMutation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNopNode(): NopNode {
  return {};
}

export const NopNode = {
  encode(_: NopNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NopNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNopNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NopNode {
    return {};
  },

  toJSON(_: NopNode): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<NopNode>): NopNode {
    return NopNode.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<NopNode>): NopNode {
    const message = createBaseNopNode();
    return message;
  },
};

function createBaseSleepNode(): SleepNode {
  return { sleepLength: undefined };
}

export const SleepNode = {
  encode(message: SleepNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.sleepLength?.$case) {
      case "rawSeconds":
        VariableAssignment.encode(message.sleepLength.value, writer.uint32(10).fork()).ldelim();
        break;
      case "timestamp":
        VariableAssignment.encode(message.sleepLength.value, writer.uint32(18).fork()).ldelim();
        break;
      case "isoDate":
        VariableAssignment.encode(message.sleepLength.value, writer.uint32(26).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SleepNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSleepNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sleepLength = { $case: "rawSeconds", value: VariableAssignment.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sleepLength = { $case: "timestamp", value: VariableAssignment.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sleepLength = { $case: "isoDate", value: VariableAssignment.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SleepNode {
    return {
      sleepLength: isSet(object.rawSeconds)
        ? { $case: "rawSeconds", value: VariableAssignment.fromJSON(object.rawSeconds) }
        : isSet(object.timestamp)
        ? { $case: "timestamp", value: VariableAssignment.fromJSON(object.timestamp) }
        : isSet(object.isoDate)
        ? { $case: "isoDate", value: VariableAssignment.fromJSON(object.isoDate) }
        : undefined,
    };
  },

  toJSON(message: SleepNode): unknown {
    const obj: any = {};
    if (message.sleepLength?.$case === "rawSeconds") {
      obj.rawSeconds = VariableAssignment.toJSON(message.sleepLength.value);
    }
    if (message.sleepLength?.$case === "timestamp") {
      obj.timestamp = VariableAssignment.toJSON(message.sleepLength.value);
    }
    if (message.sleepLength?.$case === "isoDate") {
      obj.isoDate = VariableAssignment.toJSON(message.sleepLength.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SleepNode>): SleepNode {
    return SleepNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SleepNode>): SleepNode {
    const message = createBaseSleepNode();
    if (
      object.sleepLength?.$case === "rawSeconds" &&
      object.sleepLength?.value !== undefined &&
      object.sleepLength?.value !== null
    ) {
      message.sleepLength = { $case: "rawSeconds", value: VariableAssignment.fromPartial(object.sleepLength.value) };
    }
    if (
      object.sleepLength?.$case === "timestamp" &&
      object.sleepLength?.value !== undefined &&
      object.sleepLength?.value !== null
    ) {
      message.sleepLength = { $case: "timestamp", value: VariableAssignment.fromPartial(object.sleepLength.value) };
    }
    if (
      object.sleepLength?.$case === "isoDate" &&
      object.sleepLength?.value !== undefined &&
      object.sleepLength?.value !== null
    ) {
      message.sleepLength = { $case: "isoDate", value: VariableAssignment.fromPartial(object.sleepLength.value) };
    }
    return message;
  },
};

function createBaseWfSpecVersionMigration(): WfSpecVersionMigration {
  return { newMajorVersion: 0, newRevision: 0, threadSpecMigrations: {} };
}

export const WfSpecVersionMigration = {
  encode(message: WfSpecVersionMigration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.newMajorVersion !== 0) {
      writer.uint32(8).int32(message.newMajorVersion);
    }
    if (message.newRevision !== 0) {
      writer.uint32(16).int32(message.newRevision);
    }
    Object.entries(message.threadSpecMigrations).forEach(([key, value]) => {
      WfSpecVersionMigration_ThreadSpecMigrationsEntry.encode({ key: key as any, value }, writer.uint32(26).fork())
        .ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpecVersionMigration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpecVersionMigration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.newMajorVersion = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.newRevision = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = WfSpecVersionMigration_ThreadSpecMigrationsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.threadSpecMigrations[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WfSpecVersionMigration {
    return {
      newMajorVersion: isSet(object.newMajorVersion) ? globalThis.Number(object.newMajorVersion) : 0,
      newRevision: isSet(object.newRevision) ? globalThis.Number(object.newRevision) : 0,
      threadSpecMigrations: isObject(object.threadSpecMigrations)
        ? Object.entries(object.threadSpecMigrations).reduce<{ [key: string]: ThreadSpecMigration }>(
          (acc, [key, value]) => {
            acc[key] = ThreadSpecMigration.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: WfSpecVersionMigration): unknown {
    const obj: any = {};
    if (message.newMajorVersion !== 0) {
      obj.newMajorVersion = Math.round(message.newMajorVersion);
    }
    if (message.newRevision !== 0) {
      obj.newRevision = Math.round(message.newRevision);
    }
    if (message.threadSpecMigrations) {
      const entries = Object.entries(message.threadSpecMigrations);
      if (entries.length > 0) {
        obj.threadSpecMigrations = {};
        entries.forEach(([k, v]) => {
          obj.threadSpecMigrations[k] = ThreadSpecMigration.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<WfSpecVersionMigration>): WfSpecVersionMigration {
    return WfSpecVersionMigration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WfSpecVersionMigration>): WfSpecVersionMigration {
    const message = createBaseWfSpecVersionMigration();
    message.newMajorVersion = object.newMajorVersion ?? 0;
    message.newRevision = object.newRevision ?? 0;
    message.threadSpecMigrations = Object.entries(object.threadSpecMigrations ?? {}).reduce<
      { [key: string]: ThreadSpecMigration }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = ThreadSpecMigration.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseWfSpecVersionMigration_ThreadSpecMigrationsEntry(): WfSpecVersionMigration_ThreadSpecMigrationsEntry {
  return { key: "", value: undefined };
}

export const WfSpecVersionMigration_ThreadSpecMigrationsEntry = {
  encode(
    message: WfSpecVersionMigration_ThreadSpecMigrationsEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ThreadSpecMigration.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpecVersionMigration_ThreadSpecMigrationsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpecVersionMigration_ThreadSpecMigrationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ThreadSpecMigration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WfSpecVersionMigration_ThreadSpecMigrationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ThreadSpecMigration.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: WfSpecVersionMigration_ThreadSpecMigrationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ThreadSpecMigration.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<WfSpecVersionMigration_ThreadSpecMigrationsEntry>,
  ): WfSpecVersionMigration_ThreadSpecMigrationsEntry {
    return WfSpecVersionMigration_ThreadSpecMigrationsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WfSpecVersionMigration_ThreadSpecMigrationsEntry>,
  ): WfSpecVersionMigration_ThreadSpecMigrationsEntry {
    const message = createBaseWfSpecVersionMigration_ThreadSpecMigrationsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ThreadSpecMigration.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseThreadSpecMigration(): ThreadSpecMigration {
  return { newThreadSpecName: "", nodeMigrations: {} };
}

export const ThreadSpecMigration = {
  encode(message: ThreadSpecMigration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.newThreadSpecName !== "") {
      writer.uint32(10).string(message.newThreadSpecName);
    }
    Object.entries(message.nodeMigrations).forEach(([key, value]) => {
      ThreadSpecMigration_NodeMigrationsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadSpecMigration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadSpecMigration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.newThreadSpecName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = ThreadSpecMigration_NodeMigrationsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.nodeMigrations[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThreadSpecMigration {
    return {
      newThreadSpecName: isSet(object.newThreadSpecName) ? globalThis.String(object.newThreadSpecName) : "",
      nodeMigrations: isObject(object.nodeMigrations)
        ? Object.entries(object.nodeMigrations).reduce<{ [key: string]: NodeMigration }>((acc, [key, value]) => {
          acc[key] = NodeMigration.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ThreadSpecMigration): unknown {
    const obj: any = {};
    if (message.newThreadSpecName !== "") {
      obj.newThreadSpecName = message.newThreadSpecName;
    }
    if (message.nodeMigrations) {
      const entries = Object.entries(message.nodeMigrations);
      if (entries.length > 0) {
        obj.nodeMigrations = {};
        entries.forEach(([k, v]) => {
          obj.nodeMigrations[k] = NodeMigration.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ThreadSpecMigration>): ThreadSpecMigration {
    return ThreadSpecMigration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreadSpecMigration>): ThreadSpecMigration {
    const message = createBaseThreadSpecMigration();
    message.newThreadSpecName = object.newThreadSpecName ?? "";
    message.nodeMigrations = Object.entries(object.nodeMigrations ?? {}).reduce<{ [key: string]: NodeMigration }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = NodeMigration.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseThreadSpecMigration_NodeMigrationsEntry(): ThreadSpecMigration_NodeMigrationsEntry {
  return { key: "", value: undefined };
}

export const ThreadSpecMigration_NodeMigrationsEntry = {
  encode(message: ThreadSpecMigration_NodeMigrationsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      NodeMigration.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadSpecMigration_NodeMigrationsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadSpecMigration_NodeMigrationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = NodeMigration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThreadSpecMigration_NodeMigrationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? NodeMigration.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ThreadSpecMigration_NodeMigrationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = NodeMigration.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ThreadSpecMigration_NodeMigrationsEntry>): ThreadSpecMigration_NodeMigrationsEntry {
    return ThreadSpecMigration_NodeMigrationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreadSpecMigration_NodeMigrationsEntry>): ThreadSpecMigration_NodeMigrationsEntry {
    const message = createBaseThreadSpecMigration_NodeMigrationsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? NodeMigration.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseNodeMigration(): NodeMigration {
  return { newNodeName: "" };
}

export const NodeMigration = {
  encode(message: NodeMigration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.newNodeName !== "") {
      writer.uint32(10).string(message.newNodeName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeMigration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeMigration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.newNodeName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeMigration {
    return { newNodeName: isSet(object.newNodeName) ? globalThis.String(object.newNodeName) : "" };
  },

  toJSON(message: NodeMigration): unknown {
    const obj: any = {};
    if (message.newNodeName !== "") {
      obj.newNodeName = message.newNodeName;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeMigration>): NodeMigration {
    return NodeMigration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeMigration>): NodeMigration {
    const message = createBaseNodeMigration();
    message.newNodeName = object.newNodeName ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
