// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v4.23.4
// source: wf_spec.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  MetadataStatus,
  metadataStatusFromJSON,
  metadataStatusToNumber,
  VariableType,
  variableTypeFromJSON,
  variableTypeToNumber,
} from "./common_enums";
import {
  Comparator,
  comparatorFromJSON,
  comparatorToNumber,
  TaskNode,
  UTActionTrigger,
  VariableAssignment,
  VariableDef,
  VariableMutation,
} from "./common_wfspec";
import { Timestamp } from "./google/protobuf/timestamp";
import { ExternalEventDefId, WfSpecId, WorkflowEventDefId } from "./object_id";

/** Determines the Access Level for a Variable in a ThreadSpec/WfSpec. */
export enum WfRunVariableAccessLevel {
  /** PUBLIC_VAR - A `PUBLIC_VAR` can be accessed (read + mutated) by child `WfRun`'s. */
  PUBLIC_VAR = "PUBLIC_VAR",
  /** PRIVATE_VAR - A `PRIVATE_VAR` cannot be accessed by a child `WfRun`. */
  PRIVATE_VAR = "PRIVATE_VAR",
  /**
   * INHERITED_VAR - An `INHERITED_VAR` is inherited from the parent `WfRun`. Only valid in a `WfSpec` that
   * has a parent. Also can only be declared in the Entrypoint Thread.
   */
  INHERITED_VAR = "INHERITED_VAR",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function wfRunVariableAccessLevelFromJSON(object: any): WfRunVariableAccessLevel {
  switch (object) {
    case 0:
    case "PUBLIC_VAR":
      return WfRunVariableAccessLevel.PUBLIC_VAR;
    case 1:
    case "PRIVATE_VAR":
      return WfRunVariableAccessLevel.PRIVATE_VAR;
    case 2:
    case "INHERITED_VAR":
      return WfRunVariableAccessLevel.INHERITED_VAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WfRunVariableAccessLevel.UNRECOGNIZED;
  }
}

export function wfRunVariableAccessLevelToNumber(object: WfRunVariableAccessLevel): number {
  switch (object) {
    case WfRunVariableAccessLevel.PUBLIC_VAR:
      return 0;
    case WfRunVariableAccessLevel.PRIVATE_VAR:
      return 1;
    case WfRunVariableAccessLevel.INHERITED_VAR:
      return 2;
    case WfRunVariableAccessLevel.UNRECOGNIZED:
    default:
      return -1;
  }
}

/**
 * A `WfSpec` defines the logic for a workflow in LittleHorse. It is a metadata object
 * and is a blueprint for a `WfRun` execution.
 */
export interface WfSpec {
  /**
   * The ID of the `WfSpec`. Note that this ID is versioned with both a major
   * version and a minor revision. Creating new WfSpec's with the same name
   * and different specifications results in a completely new `WfSpec` object
   * whose `id.name` is the same but with different version.
   */
  id:
    | WfSpecId
    | undefined;
  /** The timestamp at which the `WfSpec` was created. */
  createdAt:
    | string
    | undefined;
  /**
   * Variables whose types cannot be changed without causing a Breaking Change between
   * the versions.
   */
  frozenVariables: ThreadVarDef[];
  /**
   * The Status of the `WfSpec`. Currently, only `ACTIVE` exists. This field will be
   * used in the future when de-commissioning a WfSpec gracefully.
   */
  status: MetadataStatus;
  /**
   * The various ThreadSpec's in this `WfSpec`. Each `ThreadSpec` defines a blueprint for
   * a parallel thread of execution (a `ThreadRun`). They are referred to by their names.
   */
  threadSpecs: { [key: string]: ThreadSpec };
  /**
   * The name of the `ENTRYPOINT` ThreadSpec. The Entrypoint is the `ThreadSpec` for the
   * Entrypoint ThreadRun, which is the `ThreadRun` that is created upon starting the
   * `WfRun`.
   */
  entrypointThreadName: string;
  /**
   * Optional policy that configures cleaning up old `WfRun`'s after they are completed or
   * failed. Recommended for production settings to avoid running out of disk space; unless
   * you are using a `WfRun` as a data record, in which case the application should
   * clean up `WfRun`'s as appropriate.
   */
  retentionPolicy?:
    | WorkflowRetentionPolicy
    | undefined;
  /** EXPERIMENTAL: ongoing migration from one version of a `WfSpec` to another. */
  migration?:
    | WfSpecVersionMigration
    | undefined;
  /**
   * Reference to the parent WfSpec. If this is set, all WfRun's for this WfSpec must be the
   * child of a WfRun belonging to the referenced WfSpec.
   */
  parentWfSpec?: WfSpec_ParentWfSpecReference | undefined;
}

export interface WfSpec_ThreadSpecsEntry {
  key: string;
  value: ThreadSpec | undefined;
}

/**
 * Reference to another WfSpec. If a WfSpec has a ParentWfSpecReference, then all
 * WfRun's for that WfSpec *MUST* be the child of a WfRun of the provided WfSpec; meaning
 * that the RunWf RPC must provide a `parent_wf_run_id` that belongs to the specified
 * WfSpec.
 *
 * Currently, only reference by names is supported.
 */
export interface WfSpec_ParentWfSpecReference {
  /** Name of the Parent WfSpec */
  wfSpecName: string;
  /**
   * FOR NOW: no validation of variables on parent. In the future we will pass
   * wf_spec_major_version, but we should probably examine the rules for
   * evolution in the future.
   */
  wfSpecMajorVersion: number;
}

/**
 * A WorkflowRetentionPolicy configures how long a WfRun is retained in the data store before
 * being deleted after it is completed or failed.
 */
export interface WorkflowRetentionPolicy {
  wfGcPolicy?: { $case: "secondsAfterWfTermination"; secondsAfterWfTermination: number } | undefined;
}

/**
 * Defines an index to make a JSON_OBJ or JSON_ARR variable searchable over a specific
 * JSON Path.
 */
export interface JsonIndex {
  /**
   * Denotes the path in JSONPath format (according to the Java Jayway library) that
   * has a field we should index.
   */
  fieldPath: string;
  /** Is the type of the field we are indexing. */
  fieldType: VariableType;
}

/** Denotes a variable declaration at the ThreadSpec level. */
export interface ThreadVarDef {
  /** Is the actual VariableDefinition containing name and type. */
  varDef:
    | VariableDef
    | undefined;
  /** Whether the variable is required as input to the threadRun. */
  required: boolean;
  /** Whether this variable has an index configured. */
  searchable: boolean;
  /**
   * Valid for JSON_OBJ and JSON_ARR variables only. List of JSON fields
   * to index.
   */
  jsonIndexes: JsonIndex[];
  /** The Access Level of this variable. */
  accessLevel: WfRunVariableAccessLevel;
}

/**
 * Defines a blueprint for a ThreadRun, which is a thread of execution inside a
 * WfRun.
 */
export interface ThreadSpec {
  /** The Nodes inside this ThreadSpec. Maps from name to Node. */
  nodes: { [key: string]: Node };
  /** Defines Variables that are local to ThreadRun's of this ThreadSpec. */
  variableDefs: ThreadVarDef[];
  /** Defines all interrupts for this ThreadSpec. */
  interruptDefs: InterruptDef[];
  /**
   * Optional retention policy to clean up ThreadRun's of this ThreadSpec after they
   * have been completed. This is important for long-lived WfRun's that could have
   * hundreds of ThreadRun's, because a ThreadRun has a record inside the WfRun itself.
   */
  retentionPolicy?: ThreadRetentionPolicy | undefined;
}

export interface ThreadSpec_NodesEntry {
  key: string;
  value: Node | undefined;
}

/**
 * ThreadRetentionPolicy specifies how long to keep record of a ThreadRun and its associated
 * NodeRun's and TaskRun's and Variables after the ThreadRun has been completed.
 */
export interface ThreadRetentionPolicy {
  threadGcPolicy?: { $case: "secondsAfterThreadTermination"; secondsAfterThreadTermination: number } | undefined;
}

/**
 * Defines an Interrupt for a ThreadSpec. An Interrupt means that when an ExternalEvent
 * of a certain type is registered to the WfRun, then the affected ThreadRun is HALTED
 * and a handler ThreadRun is run as an interrupt handler. The interrupted ThreadRun
 * is resumed once the interrupt handler completes.
 */
export interface InterruptDef {
  /**
   * The ID of the ExternalEventDef which triggers an Interrupt for this ThreadSpec.
   * Note that as of 0.9.0, you cannot use an ExternalEventDefId for both an InterruptDef
   * and an ExternalEventNode in the same WfSpec.
   */
  externalEventDefId:
    | ExternalEventDefId
    | undefined;
  /** The name of the ThreadSpec that we run as the interrupt handler. */
  handlerSpecName: string;
}

/** Starts a Child ThreadRun with a specific ThreadSpec. */
export interface StartThreadNode {
  /** The name of the ThreadSpec to spawn. */
  threadSpecName: string;
  /** The input variables to pass into the Child ThreadRun. */
  variables: { [key: string]: VariableAssignment };
}

export interface StartThreadNode_VariablesEntry {
  key: string;
  value: VariableAssignment | undefined;
}

/**
 * Iterates over a JSON_ARR and starts a Child ThreadRun for each element in the
 * list.
 *
 * Returns a JSON_ARR containing the thread_run_number of each spawned child.
 */
export interface StartMultipleThreadsNode {
  /** The name of the ThreadSpec to spawn. */
  threadSpecName: string;
  /**
   * Variables which are passed into the child ThreadRuns. These assignments are
   * the same for all spawned threads.
   */
  variables: { [key: string]: VariableAssignment };
  /**
   * Assignment that resolves to a JSON_ARR. For each element in the list, a child
   * ThreadRun is started. The reserved `INPUT` variable for each Child is set to the
   * corresponding item in the list.
   */
  iterable: VariableAssignment | undefined;
}

export interface StartMultipleThreadsNode_VariablesEntry {
  key: string;
  value: VariableAssignment | undefined;
}

/**
 * Specifies a Failure Handler which can run in case of a certain Failure to allow
 * the ThreadRun to run compensatory logic and gracefully continue rather than
 * failing immediately.
 */
export interface FailureHandlerDef {
  /** The name of the ThreadSpec to run as a */
  handlerSpecName: string;
  failureToCatch?: { $case: "specificFailure"; specificFailure: string } | {
    $case: "anyFailureOfType";
    anyFailureOfType: FailureHandlerDef_LHFailureType;
  } | undefined;
}

/** Specifies a type of Failure */
export enum FailureHandlerDef_LHFailureType {
  /** FAILURE_TYPE_ERROR - FAILURE_TYPE_ERROR specifies any technical `ERROR`. */
  FAILURE_TYPE_ERROR = "FAILURE_TYPE_ERROR",
  /** FAILURE_TYPE_EXCEPTION - Specifies a user-defined, business-related `EXCEPTION`. */
  FAILURE_TYPE_EXCEPTION = "FAILURE_TYPE_EXCEPTION",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function failureHandlerDef_LHFailureTypeFromJSON(object: any): FailureHandlerDef_LHFailureType {
  switch (object) {
    case 0:
    case "FAILURE_TYPE_ERROR":
      return FailureHandlerDef_LHFailureType.FAILURE_TYPE_ERROR;
    case 1:
    case "FAILURE_TYPE_EXCEPTION":
      return FailureHandlerDef_LHFailureType.FAILURE_TYPE_EXCEPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FailureHandlerDef_LHFailureType.UNRECOGNIZED;
  }
}

export function failureHandlerDef_LHFailureTypeToNumber(object: FailureHandlerDef_LHFailureType): number {
  switch (object) {
    case FailureHandlerDef_LHFailureType.FAILURE_TYPE_ERROR:
      return 0;
    case FailureHandlerDef_LHFailureType.FAILURE_TYPE_EXCEPTION:
      return 1;
    case FailureHandlerDef_LHFailureType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/**
 * Specifies that a ThreadRun will wait for certain specified Child ThreadRun's to
 * complete or fail before the WfRun continues. If one of the Child ThreadRun's
 * throws a Failure that is not caught by the `per_thread_failure_handlers`,
 * then the Child ThreadRun's Failure is thrown by the WaitForThreadsRun.
 *
 * No output.
 */
export interface WaitForThreadsNode {
  threadsToWaitFor?:
    | { $case: "threads"; threads: WaitForThreadsNode_ThreadsToWaitFor }
    | { $case: "threadList"; threadList: VariableAssignment }
    | undefined;
  /**
   * If any of the child ThreadRun's that we are waiting for throw a Failure, we will
   * evaluate it against these FailureHandlerDef's and run the first matching FailureHandler
   * (if any). The FailureHandler will be a child of the child, which means that it has
   * access to all of the variables in the scope of the failed Child ThreadRun.
   *
   * This is different from Node-level Failure Handlers, which would be _siblings_ of the
   * ThreadRuns that we're waiting for, and would run only when the overall nodeRun has
   * failed.
   */
  perThreadFailureHandlers: FailureHandlerDef[];
}

export interface WaitForThreadsNode_ThreadToWaitFor {
  /**
   * Causes the WaitForThreadsNodeRun to wait for the ThreadRun whose number
   * matches the value specified here. Must resolve to an INT.
   */
  threadRunNumber: VariableAssignment | undefined;
}

export interface WaitForThreadsNode_ThreadsToWaitFor {
  /** Wait for one or more ThreadRun's */
  threads: WaitForThreadsNode_ThreadToWaitFor[];
}

/**
 * An ExternalEventNode causes the WfRun to stop and wait for an ExternalEvent
 * to arrive before continuing onwards.
 *
 * The output is just the content of the ExternalEvent.
 */
export interface ExternalEventNode {
  /** The ID of the ExternalEventDef that we are waiting for. */
  externalEventDefId:
    | ExternalEventDefId
    | undefined;
  /**
   * Determines the maximum amount of time that the NodeRun will wait for the
   * ExternalEvent to arrive.
   */
  timeoutSeconds:
    | VariableAssignment
    | undefined;
  /**
   * If set, it will be possible to complete this ExternalEventNode with a CorrelatedEvent
   * using the correlation key provided here.
   */
  correlationKey?:
    | VariableAssignment
    | undefined;
  /**
   * Specifies whether the correlation key is sensitive data which should be masked.
   * Ignored if correlation_key is not set.
   */
  maskCorrelationKey: boolean;
}

/**
 * Defines the beginning of the ThreadRun execution.
 *
 * Output is NULL
 */
export interface EntrypointNode {
}

/** Defines the end of the ThreadRun execution. */
export interface ExitNode {
  /**
   * If set, this ExitNode throws the specified Failure upon arrival. Note that Failures
   * are propagated up to the parent ThreadRun (or cause the entire WfRun to fail if sent
   * by the entrypoint ThreadRun).
   *
   * If this is not set, then a ThreadRun arriving at this Exit Node will be COMPLETED.
   */
  failureDef?: FailureDef | undefined;
}

/** Defines a Failure that can be thrown. */
export interface FailureDef {
  /**
   * The code for the failure. If in UPPER_CASE, it must be one of the LHErrorType
   * enums, and represents an ERROR. If it is in kebab-case, then it is a user-defined
   * EXCEPTION.
   */
  failureName: string;
  /** Human-readable message denoting why the Failure occurred. */
  message: string;
  /** If specified, the thrown Failure will have this content. */
  content?: VariableAssignment | undefined;
}

/** A Node is a step in a ThreadRun. */
export interface Node {
  /** Defines the flow of execution and determines where the ThreadRun goes next. */
  outgoingEdges: Edge[];
  /**
   * Specifies handlers for failures (EXCEPTION or ERROR or both) which might be thrown
   * by the NodeRun. If a Failure is thrown by the Node execution, then the first
   * matching Failure Handler (if present) is run. If there is a matching Failure Handler
   * and it runs to completion, then the ThreadRun advances from the Node; else, it
   * fails.
   */
  failureHandlers: FailureHandlerDef[];
  node?:
    | { $case: "entrypoint"; entrypoint: EntrypointNode }
    | { $case: "exit"; exit: ExitNode }
    | { $case: "task"; task: TaskNode }
    | { $case: "externalEvent"; externalEvent: ExternalEventNode }
    | { $case: "startThread"; startThread: StartThreadNode }
    | { $case: "waitForThreads"; waitForThreads: WaitForThreadsNode }
    | { $case: "nop"; nop: NopNode }
    | { $case: "sleep"; sleep: SleepNode }
    | { $case: "userTask"; userTask: UserTaskNode }
    | { $case: "startMultipleThreads"; startMultipleThreads: StartMultipleThreadsNode }
    | { $case: "throwEvent"; throwEvent: ThrowEventNode }
    | { $case: "waitForCondition"; waitForCondition: WaitForConditionNode }
    | { $case: "startChildWf"; startChildWf: StartChildWfNode }
    | undefined;
}

/**
 * A SubNode that blocks until a condition is satisfied in the WfRun.
 * There is no output.
 */
export interface WaitForConditionNode {
  /** The condition that this node will block for. */
  condition: EdgeCondition | undefined;
}

/** A SubNode that throws a WorkflowEvent of a specific type. There is no output. */
export interface ThrowEventNode {
  /** The WorkflowEventDefId of the WorkflowEvent that is thrown */
  eventDefId:
    | WorkflowEventDefId
    | undefined;
  /** A VariableAssignment defining the content of the WorkflowEvent that is thrown */
  content: VariableAssignment | undefined;
}

/**
 * The UserTaskNode creates a UserTaskRun, which is used to get input from a human
 * user into the workflow.
 *
 * The output is a JSON_OBJ variable with one key/value pair for each UserTaskField.
 */
export interface UserTaskNode {
  /** Denotes the name of the `UserTaskDef` that should create the `UserTaskRun`. */
  userTaskDefName: string;
  /** Denotes the user_group to which the UserTaskRun is assigned upon creation. */
  userGroup?:
    | VariableAssignment
    | undefined;
  /** Denotes the user_id to which the UserTaskRun is assigned upon creation. */
  userId?:
    | VariableAssignment
    | undefined;
  /**
   * Specifies a list of actions that happen on various time-based triggers. Actions
   * include reassigning the UserTaskRun, cancelling the UserTaskRun, or executing
   * a "reminder" TaskRun.
   */
  actions: UTActionTrigger[];
  /**
   * This is not set in PutWfSpecRequest, and is automatically set by the Metadata
   * processor to be the latest available version of the UserTaskDef. That way, the
   * WfSpec always runs with the same version of the UserTaskDef.
   */
  userTaskDefVersion?:
    | number
    | undefined;
  /** Specifies the value to be displayed on the `notes` field of the UserTaskRun. */
  notes?:
    | VariableAssignment
    | undefined;
  /**
   * Specifies the name of the exception thrown when the User Task is canceled. If
   * not set, then the cancellation or timeout of a User Task Run throws an ERROR
   * rather than an EXCEPTION.
   */
  onCancellationExceptionName?: VariableAssignment | undefined;
}

/** This is a boolean expression used to evaluate whether an Edge is valid. */
export interface EdgeCondition {
  /** The Operator used to evaluate the left versus the right. */
  comparator: Comparator;
  /** The left side of the boolean expression. */
  left:
    | VariableAssignment
    | undefined;
  /** The right side of the Boolean Expression. */
  right: VariableAssignment | undefined;
}

/** The Edge is the line in the workflow that connects one Node to another. */
export interface Edge {
  /** The name of the Node that the Edge points to. */
  sinkNodeName: string;
  /**
   * The Condition on which this Edge will be traversed. When choosing an Edge
   * to travel after the completion of a NodeRun, the Edges are evaluated in
   * order. The first one to either have no condition or have a condition which
   * evaluates to `true` is taken.
   */
  condition?:
    | EdgeCondition
    | undefined;
  /** Ordered list of Variable Mutations to execute when traversing this Edge. */
  variableMutations: VariableMutation[];
}

/** NOP node has no operations and is used for conditional branching. */
export interface NopNode {
}

/**
 * Sleep Node causes the WfRun to wait a specified time and then resume.
 *
 * There is no output.
 */
export interface SleepNode {
  sleepLength?:
    | { $case: "rawSeconds"; rawSeconds: VariableAssignment }
    | { $case: "timestamp"; timestamp: VariableAssignment }
    | { $case: "isoDate"; isoDate: VariableAssignment }
    | undefined;
}

/**
 * EXPERIMENTAL: Specification for how to migrate an in-flight WfRun from one WfSpec
 * to another WfSpec version.
 */
export interface WfSpecVersionMigration {
  /** The major version of the WfSpec that we are migrating to. */
  newMajorVersion: number;
  /** The revision of the WfSpec that we are migrating to. */
  newRevision: number;
  /**
   * Map from ThreadSpec name to a specifier determining how to migrate ThreadRun's
   * to the new version of the WfSpec.
   */
  threadSpecMigrations: { [key: string]: ThreadSpecMigration };
}

export interface WfSpecVersionMigration_ThreadSpecMigrationsEntry {
  key: string;
  value: ThreadSpecMigration | undefined;
}

/**
 * EXPERIMENTAL: Specification for how to migrate a ThreadRun of a specific ThreadSpec
 * from one WfSpec to another WfSpec version.
 */
export interface ThreadSpecMigration {
  /**
   * The name of the ThreadSpec in the new WfSpec that this ThreadSpec should
   * migrate to.
   */
  newThreadSpecName: string;
  /**
   * Map from name of the nodes on the current ThreadSpec to the migration
   * to perform on it to move it to a new WfSpec.
   */
  nodeMigrations: { [key: string]: NodeMigration };
}

export interface ThreadSpecMigration_NodeMigrationsEntry {
  key: string;
  value: NodeMigration | undefined;
}

/**
 * EXPERIMENTAL: Specification for migrating a WfRun from a Node in one WfSpec
 * to a Node in another WfSpec version.
 */
export interface NodeMigration {
  /** The name of the Node on the new WfSpec to move to. */
  newNodeName: string;
}

/**
 * A SubNode used to start a child workflow.
 * This node spawns a new WfRun based on the specified WfSpec, and it
 * returns the WfRunId of the newly created child workflow.
 */
export interface StartChildWfNode {
  /** The name of the WfSpec to run. */
  wfSpecName: string;
  /** The major version of the WfSpec to spawn for the child workflow. */
  majorVersion?:
    | number
    | undefined;
  /**
   * The input variables to pass into the Child ThreadRun. These variables can
   * be specified as key-value pairs and will be made available to the new
   * WfRun.
   */
  variables: { [key: string]: VariableAssignment };
}

export interface StartChildWfNode_VariablesEntry {
  key: string;
  value: VariableAssignment | undefined;
}

function createBaseWfSpec(): WfSpec {
  return {
    id: undefined,
    createdAt: undefined,
    frozenVariables: [],
    status: MetadataStatus.ACTIVE,
    threadSpecs: {},
    entrypointThreadName: "",
    retentionPolicy: undefined,
    migration: undefined,
    parentWfSpec: undefined,
  };
}

export const WfSpec = {
  encode(message: WfSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      WfSpecId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.frozenVariables) {
      ThreadVarDef.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.status !== MetadataStatus.ACTIVE) {
      writer.uint32(32).int32(metadataStatusToNumber(message.status));
    }
    Object.entries(message.threadSpecs).forEach(([key, value]) => {
      WfSpec_ThreadSpecsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    if (message.entrypointThreadName !== "") {
      writer.uint32(50).string(message.entrypointThreadName);
    }
    if (message.retentionPolicy !== undefined) {
      WorkflowRetentionPolicy.encode(message.retentionPolicy, writer.uint32(58).fork()).ldelim();
    }
    if (message.migration !== undefined) {
      WfSpecVersionMigration.encode(message.migration, writer.uint32(66).fork()).ldelim();
    }
    if (message.parentWfSpec !== undefined) {
      WfSpec_ParentWfSpecReference.encode(message.parentWfSpec, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpec {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = WfSpecId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.frozenVariables.push(ThreadVarDef.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = metadataStatusFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = WfSpec_ThreadSpecsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.threadSpecs[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.entrypointThreadName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.retentionPolicy = WorkflowRetentionPolicy.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.migration = WfSpecVersionMigration.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.parentWfSpec = WfSpec_ParentWfSpecReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WfSpec>): WfSpec {
    return WfSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WfSpec>): WfSpec {
    const message = createBaseWfSpec();
    message.id = (object.id !== undefined && object.id !== null) ? WfSpecId.fromPartial(object.id) : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.frozenVariables = object.frozenVariables?.map((e) => ThreadVarDef.fromPartial(e)) || [];
    message.status = object.status ?? MetadataStatus.ACTIVE;
    message.threadSpecs = Object.entries(object.threadSpecs ?? {}).reduce<{ [key: string]: ThreadSpec }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ThreadSpec.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.entrypointThreadName = object.entrypointThreadName ?? "";
    message.retentionPolicy = (object.retentionPolicy !== undefined && object.retentionPolicy !== null)
      ? WorkflowRetentionPolicy.fromPartial(object.retentionPolicy)
      : undefined;
    message.migration = (object.migration !== undefined && object.migration !== null)
      ? WfSpecVersionMigration.fromPartial(object.migration)
      : undefined;
    message.parentWfSpec = (object.parentWfSpec !== undefined && object.parentWfSpec !== null)
      ? WfSpec_ParentWfSpecReference.fromPartial(object.parentWfSpec)
      : undefined;
    return message;
  },
};

function createBaseWfSpec_ThreadSpecsEntry(): WfSpec_ThreadSpecsEntry {
  return { key: "", value: undefined };
}

export const WfSpec_ThreadSpecsEntry = {
  encode(message: WfSpec_ThreadSpecsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ThreadSpec.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpec_ThreadSpecsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpec_ThreadSpecsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ThreadSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WfSpec_ThreadSpecsEntry>): WfSpec_ThreadSpecsEntry {
    return WfSpec_ThreadSpecsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WfSpec_ThreadSpecsEntry>): WfSpec_ThreadSpecsEntry {
    const message = createBaseWfSpec_ThreadSpecsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ThreadSpec.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseWfSpec_ParentWfSpecReference(): WfSpec_ParentWfSpecReference {
  return { wfSpecName: "", wfSpecMajorVersion: 0 };
}

export const WfSpec_ParentWfSpecReference = {
  encode(message: WfSpec_ParentWfSpecReference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpecName !== "") {
      writer.uint32(10).string(message.wfSpecName);
    }
    if (message.wfSpecMajorVersion !== 0) {
      writer.uint32(16).int32(message.wfSpecMajorVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpec_ParentWfSpecReference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpec_ParentWfSpecReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpecName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.wfSpecMajorVersion = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WfSpec_ParentWfSpecReference>): WfSpec_ParentWfSpecReference {
    return WfSpec_ParentWfSpecReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WfSpec_ParentWfSpecReference>): WfSpec_ParentWfSpecReference {
    const message = createBaseWfSpec_ParentWfSpecReference();
    message.wfSpecName = object.wfSpecName ?? "";
    message.wfSpecMajorVersion = object.wfSpecMajorVersion ?? 0;
    return message;
  },
};

function createBaseWorkflowRetentionPolicy(): WorkflowRetentionPolicy {
  return { wfGcPolicy: undefined };
}

export const WorkflowRetentionPolicy = {
  encode(message: WorkflowRetentionPolicy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.wfGcPolicy?.$case) {
      case "secondsAfterWfTermination":
        writer.uint32(8).int64(message.wfGcPolicy.secondsAfterWfTermination);
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowRetentionPolicy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowRetentionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.wfGcPolicy = {
            $case: "secondsAfterWfTermination",
            secondsAfterWfTermination: longToNumber(reader.int64() as Long),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkflowRetentionPolicy>): WorkflowRetentionPolicy {
    return WorkflowRetentionPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowRetentionPolicy>): WorkflowRetentionPolicy {
    const message = createBaseWorkflowRetentionPolicy();
    if (
      object.wfGcPolicy?.$case === "secondsAfterWfTermination" &&
      object.wfGcPolicy?.secondsAfterWfTermination !== undefined &&
      object.wfGcPolicy?.secondsAfterWfTermination !== null
    ) {
      message.wfGcPolicy = {
        $case: "secondsAfterWfTermination",
        secondsAfterWfTermination: object.wfGcPolicy.secondsAfterWfTermination,
      };
    }
    return message;
  },
};

function createBaseJsonIndex(): JsonIndex {
  return { fieldPath: "", fieldType: VariableType.JSON_OBJ };
}

export const JsonIndex = {
  encode(message: JsonIndex, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fieldPath !== "") {
      writer.uint32(10).string(message.fieldPath);
    }
    if (message.fieldType !== VariableType.JSON_OBJ) {
      writer.uint32(16).int32(variableTypeToNumber(message.fieldType));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): JsonIndex {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsonIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldPath = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fieldType = variableTypeFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<JsonIndex>): JsonIndex {
    return JsonIndex.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JsonIndex>): JsonIndex {
    const message = createBaseJsonIndex();
    message.fieldPath = object.fieldPath ?? "";
    message.fieldType = object.fieldType ?? VariableType.JSON_OBJ;
    return message;
  },
};

function createBaseThreadVarDef(): ThreadVarDef {
  return {
    varDef: undefined,
    required: false,
    searchable: false,
    jsonIndexes: [],
    accessLevel: WfRunVariableAccessLevel.PUBLIC_VAR,
  };
}

export const ThreadVarDef = {
  encode(message: ThreadVarDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.varDef !== undefined) {
      VariableDef.encode(message.varDef, writer.uint32(10).fork()).ldelim();
    }
    if (message.required !== false) {
      writer.uint32(16).bool(message.required);
    }
    if (message.searchable !== false) {
      writer.uint32(24).bool(message.searchable);
    }
    for (const v of message.jsonIndexes) {
      JsonIndex.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.accessLevel !== WfRunVariableAccessLevel.PUBLIC_VAR) {
      writer.uint32(40).int32(wfRunVariableAccessLevelToNumber(message.accessLevel));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadVarDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadVarDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.varDef = VariableDef.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.required = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.searchable = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.jsonIndexes.push(JsonIndex.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.accessLevel = wfRunVariableAccessLevelFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ThreadVarDef>): ThreadVarDef {
    return ThreadVarDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreadVarDef>): ThreadVarDef {
    const message = createBaseThreadVarDef();
    message.varDef = (object.varDef !== undefined && object.varDef !== null)
      ? VariableDef.fromPartial(object.varDef)
      : undefined;
    message.required = object.required ?? false;
    message.searchable = object.searchable ?? false;
    message.jsonIndexes = object.jsonIndexes?.map((e) => JsonIndex.fromPartial(e)) || [];
    message.accessLevel = object.accessLevel ?? WfRunVariableAccessLevel.PUBLIC_VAR;
    return message;
  },
};

function createBaseThreadSpec(): ThreadSpec {
  return { nodes: {}, variableDefs: [], interruptDefs: [], retentionPolicy: undefined };
}

export const ThreadSpec = {
  encode(message: ThreadSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.nodes).forEach(([key, value]) => {
      ThreadSpec_NodesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    for (const v of message.variableDefs) {
      ThreadVarDef.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.interruptDefs) {
      InterruptDef.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.retentionPolicy !== undefined) {
      ThreadRetentionPolicy.encode(message.retentionPolicy, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadSpec {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ThreadSpec_NodesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.nodes[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.variableDefs.push(ThreadVarDef.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.interruptDefs.push(InterruptDef.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.retentionPolicy = ThreadRetentionPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ThreadSpec>): ThreadSpec {
    return ThreadSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreadSpec>): ThreadSpec {
    const message = createBaseThreadSpec();
    message.nodes = Object.entries(object.nodes ?? {}).reduce<{ [key: string]: Node }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Node.fromPartial(value);
      }
      return acc;
    }, {});
    message.variableDefs = object.variableDefs?.map((e) => ThreadVarDef.fromPartial(e)) || [];
    message.interruptDefs = object.interruptDefs?.map((e) => InterruptDef.fromPartial(e)) || [];
    message.retentionPolicy = (object.retentionPolicy !== undefined && object.retentionPolicy !== null)
      ? ThreadRetentionPolicy.fromPartial(object.retentionPolicy)
      : undefined;
    return message;
  },
};

function createBaseThreadSpec_NodesEntry(): ThreadSpec_NodesEntry {
  return { key: "", value: undefined };
}

export const ThreadSpec_NodesEntry = {
  encode(message: ThreadSpec_NodesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Node.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadSpec_NodesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadSpec_NodesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Node.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ThreadSpec_NodesEntry>): ThreadSpec_NodesEntry {
    return ThreadSpec_NodesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreadSpec_NodesEntry>): ThreadSpec_NodesEntry {
    const message = createBaseThreadSpec_NodesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Node.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseThreadRetentionPolicy(): ThreadRetentionPolicy {
  return { threadGcPolicy: undefined };
}

export const ThreadRetentionPolicy = {
  encode(message: ThreadRetentionPolicy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.threadGcPolicy?.$case) {
      case "secondsAfterThreadTermination":
        writer.uint32(8).int64(message.threadGcPolicy.secondsAfterThreadTermination);
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadRetentionPolicy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadRetentionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.threadGcPolicy = {
            $case: "secondsAfterThreadTermination",
            secondsAfterThreadTermination: longToNumber(reader.int64() as Long),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ThreadRetentionPolicy>): ThreadRetentionPolicy {
    return ThreadRetentionPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreadRetentionPolicy>): ThreadRetentionPolicy {
    const message = createBaseThreadRetentionPolicy();
    if (
      object.threadGcPolicy?.$case === "secondsAfterThreadTermination" &&
      object.threadGcPolicy?.secondsAfterThreadTermination !== undefined &&
      object.threadGcPolicy?.secondsAfterThreadTermination !== null
    ) {
      message.threadGcPolicy = {
        $case: "secondsAfterThreadTermination",
        secondsAfterThreadTermination: object.threadGcPolicy.secondsAfterThreadTermination,
      };
    }
    return message;
  },
};

function createBaseInterruptDef(): InterruptDef {
  return { externalEventDefId: undefined, handlerSpecName: "" };
}

export const InterruptDef = {
  encode(message: InterruptDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.externalEventDefId !== undefined) {
      ExternalEventDefId.encode(message.externalEventDefId, writer.uint32(10).fork()).ldelim();
    }
    if (message.handlerSpecName !== "") {
      writer.uint32(18).string(message.handlerSpecName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InterruptDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterruptDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalEventDefId = ExternalEventDefId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.handlerSpecName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<InterruptDef>): InterruptDef {
    return InterruptDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterruptDef>): InterruptDef {
    const message = createBaseInterruptDef();
    message.externalEventDefId = (object.externalEventDefId !== undefined && object.externalEventDefId !== null)
      ? ExternalEventDefId.fromPartial(object.externalEventDefId)
      : undefined;
    message.handlerSpecName = object.handlerSpecName ?? "";
    return message;
  },
};

function createBaseStartThreadNode(): StartThreadNode {
  return { threadSpecName: "", variables: {} };
}

export const StartThreadNode = {
  encode(message: StartThreadNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.threadSpecName !== "") {
      writer.uint32(10).string(message.threadSpecName);
    }
    Object.entries(message.variables).forEach(([key, value]) => {
      StartThreadNode_VariablesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartThreadNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartThreadNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threadSpecName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = StartThreadNode_VariablesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.variables[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StartThreadNode>): StartThreadNode {
    return StartThreadNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartThreadNode>): StartThreadNode {
    const message = createBaseStartThreadNode();
    message.threadSpecName = object.threadSpecName ?? "";
    message.variables = Object.entries(object.variables ?? {}).reduce<{ [key: string]: VariableAssignment }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = VariableAssignment.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseStartThreadNode_VariablesEntry(): StartThreadNode_VariablesEntry {
  return { key: "", value: undefined };
}

export const StartThreadNode_VariablesEntry = {
  encode(message: StartThreadNode_VariablesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      VariableAssignment.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartThreadNode_VariablesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartThreadNode_VariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StartThreadNode_VariablesEntry>): StartThreadNode_VariablesEntry {
    return StartThreadNode_VariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartThreadNode_VariablesEntry>): StartThreadNode_VariablesEntry {
    const message = createBaseStartThreadNode_VariablesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableAssignment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseStartMultipleThreadsNode(): StartMultipleThreadsNode {
  return { threadSpecName: "", variables: {}, iterable: undefined };
}

export const StartMultipleThreadsNode = {
  encode(message: StartMultipleThreadsNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.threadSpecName !== "") {
      writer.uint32(10).string(message.threadSpecName);
    }
    Object.entries(message.variables).forEach(([key, value]) => {
      StartMultipleThreadsNode_VariablesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.iterable !== undefined) {
      VariableAssignment.encode(message.iterable, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartMultipleThreadsNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartMultipleThreadsNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threadSpecName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = StartMultipleThreadsNode_VariablesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.variables[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.iterable = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StartMultipleThreadsNode>): StartMultipleThreadsNode {
    return StartMultipleThreadsNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartMultipleThreadsNode>): StartMultipleThreadsNode {
    const message = createBaseStartMultipleThreadsNode();
    message.threadSpecName = object.threadSpecName ?? "";
    message.variables = Object.entries(object.variables ?? {}).reduce<{ [key: string]: VariableAssignment }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = VariableAssignment.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.iterable = (object.iterable !== undefined && object.iterable !== null)
      ? VariableAssignment.fromPartial(object.iterable)
      : undefined;
    return message;
  },
};

function createBaseStartMultipleThreadsNode_VariablesEntry(): StartMultipleThreadsNode_VariablesEntry {
  return { key: "", value: undefined };
}

export const StartMultipleThreadsNode_VariablesEntry = {
  encode(message: StartMultipleThreadsNode_VariablesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      VariableAssignment.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartMultipleThreadsNode_VariablesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartMultipleThreadsNode_VariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StartMultipleThreadsNode_VariablesEntry>): StartMultipleThreadsNode_VariablesEntry {
    return StartMultipleThreadsNode_VariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartMultipleThreadsNode_VariablesEntry>): StartMultipleThreadsNode_VariablesEntry {
    const message = createBaseStartMultipleThreadsNode_VariablesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableAssignment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFailureHandlerDef(): FailureHandlerDef {
  return { handlerSpecName: "", failureToCatch: undefined };
}

export const FailureHandlerDef = {
  encode(message: FailureHandlerDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.handlerSpecName !== "") {
      writer.uint32(18).string(message.handlerSpecName);
    }
    switch (message.failureToCatch?.$case) {
      case "specificFailure":
        writer.uint32(10).string(message.failureToCatch.specificFailure);
        break;
      case "anyFailureOfType":
        writer.uint32(24).int32(failureHandlerDef_LHFailureTypeToNumber(message.failureToCatch.anyFailureOfType));
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FailureHandlerDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailureHandlerDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.handlerSpecName = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.failureToCatch = { $case: "specificFailure", specificFailure: reader.string() };
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failureToCatch = {
            $case: "anyFailureOfType",
            anyFailureOfType: failureHandlerDef_LHFailureTypeFromJSON(reader.int32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FailureHandlerDef>): FailureHandlerDef {
    return FailureHandlerDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FailureHandlerDef>): FailureHandlerDef {
    const message = createBaseFailureHandlerDef();
    message.handlerSpecName = object.handlerSpecName ?? "";
    if (
      object.failureToCatch?.$case === "specificFailure" &&
      object.failureToCatch?.specificFailure !== undefined &&
      object.failureToCatch?.specificFailure !== null
    ) {
      message.failureToCatch = { $case: "specificFailure", specificFailure: object.failureToCatch.specificFailure };
    }
    if (
      object.failureToCatch?.$case === "anyFailureOfType" &&
      object.failureToCatch?.anyFailureOfType !== undefined &&
      object.failureToCatch?.anyFailureOfType !== null
    ) {
      message.failureToCatch = { $case: "anyFailureOfType", anyFailureOfType: object.failureToCatch.anyFailureOfType };
    }
    return message;
  },
};

function createBaseWaitForThreadsNode(): WaitForThreadsNode {
  return { threadsToWaitFor: undefined, perThreadFailureHandlers: [] };
}

export const WaitForThreadsNode = {
  encode(message: WaitForThreadsNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.threadsToWaitFor?.$case) {
      case "threads":
        WaitForThreadsNode_ThreadsToWaitFor.encode(message.threadsToWaitFor.threads, writer.uint32(10).fork()).ldelim();
        break;
      case "threadList":
        VariableAssignment.encode(message.threadsToWaitFor.threadList, writer.uint32(18).fork()).ldelim();
        break;
    }
    for (const v of message.perThreadFailureHandlers) {
      FailureHandlerDef.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WaitForThreadsNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitForThreadsNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threadsToWaitFor = {
            $case: "threads",
            threads: WaitForThreadsNode_ThreadsToWaitFor.decode(reader, reader.uint32()),
          };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.threadsToWaitFor = {
            $case: "threadList",
            threadList: VariableAssignment.decode(reader, reader.uint32()),
          };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.perThreadFailureHandlers.push(FailureHandlerDef.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WaitForThreadsNode>): WaitForThreadsNode {
    return WaitForThreadsNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WaitForThreadsNode>): WaitForThreadsNode {
    const message = createBaseWaitForThreadsNode();
    if (
      object.threadsToWaitFor?.$case === "threads" &&
      object.threadsToWaitFor?.threads !== undefined &&
      object.threadsToWaitFor?.threads !== null
    ) {
      message.threadsToWaitFor = {
        $case: "threads",
        threads: WaitForThreadsNode_ThreadsToWaitFor.fromPartial(object.threadsToWaitFor.threads),
      };
    }
    if (
      object.threadsToWaitFor?.$case === "threadList" &&
      object.threadsToWaitFor?.threadList !== undefined &&
      object.threadsToWaitFor?.threadList !== null
    ) {
      message.threadsToWaitFor = {
        $case: "threadList",
        threadList: VariableAssignment.fromPartial(object.threadsToWaitFor.threadList),
      };
    }
    message.perThreadFailureHandlers = object.perThreadFailureHandlers?.map((e) => FailureHandlerDef.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseWaitForThreadsNode_ThreadToWaitFor(): WaitForThreadsNode_ThreadToWaitFor {
  return { threadRunNumber: undefined };
}

export const WaitForThreadsNode_ThreadToWaitFor = {
  encode(message: WaitForThreadsNode_ThreadToWaitFor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.threadRunNumber !== undefined) {
      VariableAssignment.encode(message.threadRunNumber, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WaitForThreadsNode_ThreadToWaitFor {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitForThreadsNode_ThreadToWaitFor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threadRunNumber = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WaitForThreadsNode_ThreadToWaitFor>): WaitForThreadsNode_ThreadToWaitFor {
    return WaitForThreadsNode_ThreadToWaitFor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WaitForThreadsNode_ThreadToWaitFor>): WaitForThreadsNode_ThreadToWaitFor {
    const message = createBaseWaitForThreadsNode_ThreadToWaitFor();
    message.threadRunNumber = (object.threadRunNumber !== undefined && object.threadRunNumber !== null)
      ? VariableAssignment.fromPartial(object.threadRunNumber)
      : undefined;
    return message;
  },
};

function createBaseWaitForThreadsNode_ThreadsToWaitFor(): WaitForThreadsNode_ThreadsToWaitFor {
  return { threads: [] };
}

export const WaitForThreadsNode_ThreadsToWaitFor = {
  encode(message: WaitForThreadsNode_ThreadsToWaitFor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.threads) {
      WaitForThreadsNode_ThreadToWaitFor.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WaitForThreadsNode_ThreadsToWaitFor {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitForThreadsNode_ThreadsToWaitFor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threads.push(WaitForThreadsNode_ThreadToWaitFor.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WaitForThreadsNode_ThreadsToWaitFor>): WaitForThreadsNode_ThreadsToWaitFor {
    return WaitForThreadsNode_ThreadsToWaitFor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WaitForThreadsNode_ThreadsToWaitFor>): WaitForThreadsNode_ThreadsToWaitFor {
    const message = createBaseWaitForThreadsNode_ThreadsToWaitFor();
    message.threads = object.threads?.map((e) => WaitForThreadsNode_ThreadToWaitFor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExternalEventNode(): ExternalEventNode {
  return {
    externalEventDefId: undefined,
    timeoutSeconds: undefined,
    correlationKey: undefined,
    maskCorrelationKey: false,
  };
}

export const ExternalEventNode = {
  encode(message: ExternalEventNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.externalEventDefId !== undefined) {
      ExternalEventDefId.encode(message.externalEventDefId, writer.uint32(10).fork()).ldelim();
    }
    if (message.timeoutSeconds !== undefined) {
      VariableAssignment.encode(message.timeoutSeconds, writer.uint32(18).fork()).ldelim();
    }
    if (message.correlationKey !== undefined) {
      VariableAssignment.encode(message.correlationKey, writer.uint32(26).fork()).ldelim();
    }
    if (message.maskCorrelationKey !== false) {
      writer.uint32(32).bool(message.maskCorrelationKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExternalEventNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalEventNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalEventDefId = ExternalEventDefId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeoutSeconds = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.correlationKey = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maskCorrelationKey = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ExternalEventNode>): ExternalEventNode {
    return ExternalEventNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalEventNode>): ExternalEventNode {
    const message = createBaseExternalEventNode();
    message.externalEventDefId = (object.externalEventDefId !== undefined && object.externalEventDefId !== null)
      ? ExternalEventDefId.fromPartial(object.externalEventDefId)
      : undefined;
    message.timeoutSeconds = (object.timeoutSeconds !== undefined && object.timeoutSeconds !== null)
      ? VariableAssignment.fromPartial(object.timeoutSeconds)
      : undefined;
    message.correlationKey = (object.correlationKey !== undefined && object.correlationKey !== null)
      ? VariableAssignment.fromPartial(object.correlationKey)
      : undefined;
    message.maskCorrelationKey = object.maskCorrelationKey ?? false;
    return message;
  },
};

function createBaseEntrypointNode(): EntrypointNode {
  return {};
}

export const EntrypointNode = {
  encode(_: EntrypointNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EntrypointNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntrypointNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<EntrypointNode>): EntrypointNode {
    return EntrypointNode.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<EntrypointNode>): EntrypointNode {
    const message = createBaseEntrypointNode();
    return message;
  },
};

function createBaseExitNode(): ExitNode {
  return { failureDef: undefined };
}

export const ExitNode = {
  encode(message: ExitNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.failureDef !== undefined) {
      FailureDef.encode(message.failureDef, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExitNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExitNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.failureDef = FailureDef.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ExitNode>): ExitNode {
    return ExitNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExitNode>): ExitNode {
    const message = createBaseExitNode();
    message.failureDef = (object.failureDef !== undefined && object.failureDef !== null)
      ? FailureDef.fromPartial(object.failureDef)
      : undefined;
    return message;
  },
};

function createBaseFailureDef(): FailureDef {
  return { failureName: "", message: "", content: undefined };
}

export const FailureDef = {
  encode(message: FailureDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.failureName !== "") {
      writer.uint32(10).string(message.failureName);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.content !== undefined) {
      VariableAssignment.encode(message.content, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FailureDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailureDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.failureName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FailureDef>): FailureDef {
    return FailureDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FailureDef>): FailureDef {
    const message = createBaseFailureDef();
    message.failureName = object.failureName ?? "";
    message.message = object.message ?? "";
    message.content = (object.content !== undefined && object.content !== null)
      ? VariableAssignment.fromPartial(object.content)
      : undefined;
    return message;
  },
};

function createBaseNode(): Node {
  return { outgoingEdges: [], failureHandlers: [], node: undefined };
}

export const Node = {
  encode(message: Node, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.outgoingEdges) {
      Edge.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.failureHandlers) {
      FailureHandlerDef.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    switch (message.node?.$case) {
      case "entrypoint":
        EntrypointNode.encode(message.node.entrypoint, writer.uint32(42).fork()).ldelim();
        break;
      case "exit":
        ExitNode.encode(message.node.exit, writer.uint32(50).fork()).ldelim();
        break;
      case "task":
        TaskNode.encode(message.node.task, writer.uint32(58).fork()).ldelim();
        break;
      case "externalEvent":
        ExternalEventNode.encode(message.node.externalEvent, writer.uint32(66).fork()).ldelim();
        break;
      case "startThread":
        StartThreadNode.encode(message.node.startThread, writer.uint32(74).fork()).ldelim();
        break;
      case "waitForThreads":
        WaitForThreadsNode.encode(message.node.waitForThreads, writer.uint32(82).fork()).ldelim();
        break;
      case "nop":
        NopNode.encode(message.node.nop, writer.uint32(90).fork()).ldelim();
        break;
      case "sleep":
        SleepNode.encode(message.node.sleep, writer.uint32(98).fork()).ldelim();
        break;
      case "userTask":
        UserTaskNode.encode(message.node.userTask, writer.uint32(106).fork()).ldelim();
        break;
      case "startMultipleThreads":
        StartMultipleThreadsNode.encode(message.node.startMultipleThreads, writer.uint32(122).fork()).ldelim();
        break;
      case "throwEvent":
        ThrowEventNode.encode(message.node.throwEvent, writer.uint32(130).fork()).ldelim();
        break;
      case "waitForCondition":
        WaitForConditionNode.encode(message.node.waitForCondition, writer.uint32(138).fork()).ldelim();
        break;
      case "startChildWf":
        StartChildWfNode.encode(message.node.startChildWf, writer.uint32(146).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Node {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outgoingEdges.push(Edge.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.failureHandlers.push(FailureHandlerDef.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.node = { $case: "entrypoint", entrypoint: EntrypointNode.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.node = { $case: "exit", exit: ExitNode.decode(reader, reader.uint32()) };
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.node = { $case: "task", task: TaskNode.decode(reader, reader.uint32()) };
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.node = { $case: "externalEvent", externalEvent: ExternalEventNode.decode(reader, reader.uint32()) };
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.node = { $case: "startThread", startThread: StartThreadNode.decode(reader, reader.uint32()) };
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.node = {
            $case: "waitForThreads",
            waitForThreads: WaitForThreadsNode.decode(reader, reader.uint32()),
          };
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.node = { $case: "nop", nop: NopNode.decode(reader, reader.uint32()) };
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.node = { $case: "sleep", sleep: SleepNode.decode(reader, reader.uint32()) };
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.node = { $case: "userTask", userTask: UserTaskNode.decode(reader, reader.uint32()) };
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.node = {
            $case: "startMultipleThreads",
            startMultipleThreads: StartMultipleThreadsNode.decode(reader, reader.uint32()),
          };
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.node = { $case: "throwEvent", throwEvent: ThrowEventNode.decode(reader, reader.uint32()) };
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.node = {
            $case: "waitForCondition",
            waitForCondition: WaitForConditionNode.decode(reader, reader.uint32()),
          };
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.node = { $case: "startChildWf", startChildWf: StartChildWfNode.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Node>): Node {
    return Node.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node>): Node {
    const message = createBaseNode();
    message.outgoingEdges = object.outgoingEdges?.map((e) => Edge.fromPartial(e)) || [];
    message.failureHandlers = object.failureHandlers?.map((e) => FailureHandlerDef.fromPartial(e)) || [];
    if (
      object.node?.$case === "entrypoint" && object.node?.entrypoint !== undefined && object.node?.entrypoint !== null
    ) {
      message.node = { $case: "entrypoint", entrypoint: EntrypointNode.fromPartial(object.node.entrypoint) };
    }
    if (object.node?.$case === "exit" && object.node?.exit !== undefined && object.node?.exit !== null) {
      message.node = { $case: "exit", exit: ExitNode.fromPartial(object.node.exit) };
    }
    if (object.node?.$case === "task" && object.node?.task !== undefined && object.node?.task !== null) {
      message.node = { $case: "task", task: TaskNode.fromPartial(object.node.task) };
    }
    if (
      object.node?.$case === "externalEvent" &&
      object.node?.externalEvent !== undefined &&
      object.node?.externalEvent !== null
    ) {
      message.node = {
        $case: "externalEvent",
        externalEvent: ExternalEventNode.fromPartial(object.node.externalEvent),
      };
    }
    if (
      object.node?.$case === "startThread" &&
      object.node?.startThread !== undefined &&
      object.node?.startThread !== null
    ) {
      message.node = { $case: "startThread", startThread: StartThreadNode.fromPartial(object.node.startThread) };
    }
    if (
      object.node?.$case === "waitForThreads" &&
      object.node?.waitForThreads !== undefined &&
      object.node?.waitForThreads !== null
    ) {
      message.node = {
        $case: "waitForThreads",
        waitForThreads: WaitForThreadsNode.fromPartial(object.node.waitForThreads),
      };
    }
    if (object.node?.$case === "nop" && object.node?.nop !== undefined && object.node?.nop !== null) {
      message.node = { $case: "nop", nop: NopNode.fromPartial(object.node.nop) };
    }
    if (object.node?.$case === "sleep" && object.node?.sleep !== undefined && object.node?.sleep !== null) {
      message.node = { $case: "sleep", sleep: SleepNode.fromPartial(object.node.sleep) };
    }
    if (object.node?.$case === "userTask" && object.node?.userTask !== undefined && object.node?.userTask !== null) {
      message.node = { $case: "userTask", userTask: UserTaskNode.fromPartial(object.node.userTask) };
    }
    if (
      object.node?.$case === "startMultipleThreads" &&
      object.node?.startMultipleThreads !== undefined &&
      object.node?.startMultipleThreads !== null
    ) {
      message.node = {
        $case: "startMultipleThreads",
        startMultipleThreads: StartMultipleThreadsNode.fromPartial(object.node.startMultipleThreads),
      };
    }
    if (
      object.node?.$case === "throwEvent" && object.node?.throwEvent !== undefined && object.node?.throwEvent !== null
    ) {
      message.node = { $case: "throwEvent", throwEvent: ThrowEventNode.fromPartial(object.node.throwEvent) };
    }
    if (
      object.node?.$case === "waitForCondition" &&
      object.node?.waitForCondition !== undefined &&
      object.node?.waitForCondition !== null
    ) {
      message.node = {
        $case: "waitForCondition",
        waitForCondition: WaitForConditionNode.fromPartial(object.node.waitForCondition),
      };
    }
    if (
      object.node?.$case === "startChildWf" &&
      object.node?.startChildWf !== undefined &&
      object.node?.startChildWf !== null
    ) {
      message.node = { $case: "startChildWf", startChildWf: StartChildWfNode.fromPartial(object.node.startChildWf) };
    }
    return message;
  },
};

function createBaseWaitForConditionNode(): WaitForConditionNode {
  return { condition: undefined };
}

export const WaitForConditionNode = {
  encode(message: WaitForConditionNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.condition !== undefined) {
      EdgeCondition.encode(message.condition, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WaitForConditionNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitForConditionNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.condition = EdgeCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WaitForConditionNode>): WaitForConditionNode {
    return WaitForConditionNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WaitForConditionNode>): WaitForConditionNode {
    const message = createBaseWaitForConditionNode();
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? EdgeCondition.fromPartial(object.condition)
      : undefined;
    return message;
  },
};

function createBaseThrowEventNode(): ThrowEventNode {
  return { eventDefId: undefined, content: undefined };
}

export const ThrowEventNode = {
  encode(message: ThrowEventNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventDefId !== undefined) {
      WorkflowEventDefId.encode(message.eventDefId, writer.uint32(10).fork()).ldelim();
    }
    if (message.content !== undefined) {
      VariableAssignment.encode(message.content, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThrowEventNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThrowEventNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventDefId = WorkflowEventDefId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ThrowEventNode>): ThrowEventNode {
    return ThrowEventNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThrowEventNode>): ThrowEventNode {
    const message = createBaseThrowEventNode();
    message.eventDefId = (object.eventDefId !== undefined && object.eventDefId !== null)
      ? WorkflowEventDefId.fromPartial(object.eventDefId)
      : undefined;
    message.content = (object.content !== undefined && object.content !== null)
      ? VariableAssignment.fromPartial(object.content)
      : undefined;
    return message;
  },
};

function createBaseUserTaskNode(): UserTaskNode {
  return {
    userTaskDefName: "",
    userGroup: undefined,
    userId: undefined,
    actions: [],
    userTaskDefVersion: undefined,
    notes: undefined,
    onCancellationExceptionName: undefined,
  };
}

export const UserTaskNode = {
  encode(message: UserTaskNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userTaskDefName !== "") {
      writer.uint32(10).string(message.userTaskDefName);
    }
    if (message.userGroup !== undefined) {
      VariableAssignment.encode(message.userGroup, writer.uint32(18).fork()).ldelim();
    }
    if (message.userId !== undefined) {
      VariableAssignment.encode(message.userId, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.actions) {
      UTActionTrigger.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.userTaskDefVersion !== undefined) {
      writer.uint32(40).int32(message.userTaskDefVersion);
    }
    if (message.notes !== undefined) {
      VariableAssignment.encode(message.notes, writer.uint32(50).fork()).ldelim();
    }
    if (message.onCancellationExceptionName !== undefined) {
      VariableAssignment.encode(message.onCancellationExceptionName, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTaskNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userTaskDefName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userGroup = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.actions.push(UTActionTrigger.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.userTaskDefVersion = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.notes = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.onCancellationExceptionName = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<UserTaskNode>): UserTaskNode {
    return UserTaskNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTaskNode>): UserTaskNode {
    const message = createBaseUserTaskNode();
    message.userTaskDefName = object.userTaskDefName ?? "";
    message.userGroup = (object.userGroup !== undefined && object.userGroup !== null)
      ? VariableAssignment.fromPartial(object.userGroup)
      : undefined;
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? VariableAssignment.fromPartial(object.userId)
      : undefined;
    message.actions = object.actions?.map((e) => UTActionTrigger.fromPartial(e)) || [];
    message.userTaskDefVersion = object.userTaskDefVersion ?? undefined;
    message.notes = (object.notes !== undefined && object.notes !== null)
      ? VariableAssignment.fromPartial(object.notes)
      : undefined;
    message.onCancellationExceptionName =
      (object.onCancellationExceptionName !== undefined && object.onCancellationExceptionName !== null)
        ? VariableAssignment.fromPartial(object.onCancellationExceptionName)
        : undefined;
    return message;
  },
};

function createBaseEdgeCondition(): EdgeCondition {
  return { comparator: Comparator.LESS_THAN, left: undefined, right: undefined };
}

export const EdgeCondition = {
  encode(message: EdgeCondition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.comparator !== Comparator.LESS_THAN) {
      writer.uint32(8).int32(comparatorToNumber(message.comparator));
    }
    if (message.left !== undefined) {
      VariableAssignment.encode(message.left, writer.uint32(18).fork()).ldelim();
    }
    if (message.right !== undefined) {
      VariableAssignment.encode(message.right, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EdgeCondition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdgeCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.comparator = comparatorFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.left = VariableAssignment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.right = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<EdgeCondition>): EdgeCondition {
    return EdgeCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EdgeCondition>): EdgeCondition {
    const message = createBaseEdgeCondition();
    message.comparator = object.comparator ?? Comparator.LESS_THAN;
    message.left = (object.left !== undefined && object.left !== null)
      ? VariableAssignment.fromPartial(object.left)
      : undefined;
    message.right = (object.right !== undefined && object.right !== null)
      ? VariableAssignment.fromPartial(object.right)
      : undefined;
    return message;
  },
};

function createBaseEdge(): Edge {
  return { sinkNodeName: "", condition: undefined, variableMutations: [] };
}

export const Edge = {
  encode(message: Edge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sinkNodeName !== "") {
      writer.uint32(10).string(message.sinkNodeName);
    }
    if (message.condition !== undefined) {
      EdgeCondition.encode(message.condition, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.variableMutations) {
      VariableMutation.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Edge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sinkNodeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.condition = EdgeCondition.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.variableMutations.push(VariableMutation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Edge>): Edge {
    return Edge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Edge>): Edge {
    const message = createBaseEdge();
    message.sinkNodeName = object.sinkNodeName ?? "";
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? EdgeCondition.fromPartial(object.condition)
      : undefined;
    message.variableMutations = object.variableMutations?.map((e) => VariableMutation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNopNode(): NopNode {
  return {};
}

export const NopNode = {
  encode(_: NopNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NopNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNopNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NopNode>): NopNode {
    return NopNode.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<NopNode>): NopNode {
    const message = createBaseNopNode();
    return message;
  },
};

function createBaseSleepNode(): SleepNode {
  return { sleepLength: undefined };
}

export const SleepNode = {
  encode(message: SleepNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.sleepLength?.$case) {
      case "rawSeconds":
        VariableAssignment.encode(message.sleepLength.rawSeconds, writer.uint32(10).fork()).ldelim();
        break;
      case "timestamp":
        VariableAssignment.encode(message.sleepLength.timestamp, writer.uint32(18).fork()).ldelim();
        break;
      case "isoDate":
        VariableAssignment.encode(message.sleepLength.isoDate, writer.uint32(26).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SleepNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSleepNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sleepLength = { $case: "rawSeconds", rawSeconds: VariableAssignment.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sleepLength = { $case: "timestamp", timestamp: VariableAssignment.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sleepLength = { $case: "isoDate", isoDate: VariableAssignment.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SleepNode>): SleepNode {
    return SleepNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SleepNode>): SleepNode {
    const message = createBaseSleepNode();
    if (
      object.sleepLength?.$case === "rawSeconds" &&
      object.sleepLength?.rawSeconds !== undefined &&
      object.sleepLength?.rawSeconds !== null
    ) {
      message.sleepLength = {
        $case: "rawSeconds",
        rawSeconds: VariableAssignment.fromPartial(object.sleepLength.rawSeconds),
      };
    }
    if (
      object.sleepLength?.$case === "timestamp" &&
      object.sleepLength?.timestamp !== undefined &&
      object.sleepLength?.timestamp !== null
    ) {
      message.sleepLength = {
        $case: "timestamp",
        timestamp: VariableAssignment.fromPartial(object.sleepLength.timestamp),
      };
    }
    if (
      object.sleepLength?.$case === "isoDate" &&
      object.sleepLength?.isoDate !== undefined &&
      object.sleepLength?.isoDate !== null
    ) {
      message.sleepLength = { $case: "isoDate", isoDate: VariableAssignment.fromPartial(object.sleepLength.isoDate) };
    }
    return message;
  },
};

function createBaseWfSpecVersionMigration(): WfSpecVersionMigration {
  return { newMajorVersion: 0, newRevision: 0, threadSpecMigrations: {} };
}

export const WfSpecVersionMigration = {
  encode(message: WfSpecVersionMigration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.newMajorVersion !== 0) {
      writer.uint32(8).int32(message.newMajorVersion);
    }
    if (message.newRevision !== 0) {
      writer.uint32(16).int32(message.newRevision);
    }
    Object.entries(message.threadSpecMigrations).forEach(([key, value]) => {
      WfSpecVersionMigration_ThreadSpecMigrationsEntry.encode({ key: key as any, value }, writer.uint32(26).fork())
        .ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpecVersionMigration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpecVersionMigration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.newMajorVersion = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.newRevision = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = WfSpecVersionMigration_ThreadSpecMigrationsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.threadSpecMigrations[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WfSpecVersionMigration>): WfSpecVersionMigration {
    return WfSpecVersionMigration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WfSpecVersionMigration>): WfSpecVersionMigration {
    const message = createBaseWfSpecVersionMigration();
    message.newMajorVersion = object.newMajorVersion ?? 0;
    message.newRevision = object.newRevision ?? 0;
    message.threadSpecMigrations = Object.entries(object.threadSpecMigrations ?? {}).reduce<
      { [key: string]: ThreadSpecMigration }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = ThreadSpecMigration.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseWfSpecVersionMigration_ThreadSpecMigrationsEntry(): WfSpecVersionMigration_ThreadSpecMigrationsEntry {
  return { key: "", value: undefined };
}

export const WfSpecVersionMigration_ThreadSpecMigrationsEntry = {
  encode(
    message: WfSpecVersionMigration_ThreadSpecMigrationsEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ThreadSpecMigration.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WfSpecVersionMigration_ThreadSpecMigrationsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWfSpecVersionMigration_ThreadSpecMigrationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ThreadSpecMigration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<WfSpecVersionMigration_ThreadSpecMigrationsEntry>,
  ): WfSpecVersionMigration_ThreadSpecMigrationsEntry {
    return WfSpecVersionMigration_ThreadSpecMigrationsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WfSpecVersionMigration_ThreadSpecMigrationsEntry>,
  ): WfSpecVersionMigration_ThreadSpecMigrationsEntry {
    const message = createBaseWfSpecVersionMigration_ThreadSpecMigrationsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ThreadSpecMigration.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseThreadSpecMigration(): ThreadSpecMigration {
  return { newThreadSpecName: "", nodeMigrations: {} };
}

export const ThreadSpecMigration = {
  encode(message: ThreadSpecMigration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.newThreadSpecName !== "") {
      writer.uint32(10).string(message.newThreadSpecName);
    }
    Object.entries(message.nodeMigrations).forEach(([key, value]) => {
      ThreadSpecMigration_NodeMigrationsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadSpecMigration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadSpecMigration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.newThreadSpecName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = ThreadSpecMigration_NodeMigrationsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.nodeMigrations[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ThreadSpecMigration>): ThreadSpecMigration {
    return ThreadSpecMigration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreadSpecMigration>): ThreadSpecMigration {
    const message = createBaseThreadSpecMigration();
    message.newThreadSpecName = object.newThreadSpecName ?? "";
    message.nodeMigrations = Object.entries(object.nodeMigrations ?? {}).reduce<{ [key: string]: NodeMigration }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = NodeMigration.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseThreadSpecMigration_NodeMigrationsEntry(): ThreadSpecMigration_NodeMigrationsEntry {
  return { key: "", value: undefined };
}

export const ThreadSpecMigration_NodeMigrationsEntry = {
  encode(message: ThreadSpecMigration_NodeMigrationsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      NodeMigration.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadSpecMigration_NodeMigrationsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadSpecMigration_NodeMigrationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = NodeMigration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ThreadSpecMigration_NodeMigrationsEntry>): ThreadSpecMigration_NodeMigrationsEntry {
    return ThreadSpecMigration_NodeMigrationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreadSpecMigration_NodeMigrationsEntry>): ThreadSpecMigration_NodeMigrationsEntry {
    const message = createBaseThreadSpecMigration_NodeMigrationsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? NodeMigration.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseNodeMigration(): NodeMigration {
  return { newNodeName: "" };
}

export const NodeMigration = {
  encode(message: NodeMigration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.newNodeName !== "") {
      writer.uint32(10).string(message.newNodeName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeMigration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeMigration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.newNodeName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NodeMigration>): NodeMigration {
    return NodeMigration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeMigration>): NodeMigration {
    const message = createBaseNodeMigration();
    message.newNodeName = object.newNodeName ?? "";
    return message;
  },
};

function createBaseStartChildWfNode(): StartChildWfNode {
  return { wfSpecName: "", majorVersion: undefined, variables: {} };
}

export const StartChildWfNode = {
  encode(message: StartChildWfNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wfSpecName !== "") {
      writer.uint32(10).string(message.wfSpecName);
    }
    if (message.majorVersion !== undefined) {
      writer.uint32(16).int32(message.majorVersion);
    }
    Object.entries(message.variables).forEach(([key, value]) => {
      StartChildWfNode_VariablesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartChildWfNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartChildWfNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wfSpecName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.majorVersion = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = StartChildWfNode_VariablesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.variables[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StartChildWfNode>): StartChildWfNode {
    return StartChildWfNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartChildWfNode>): StartChildWfNode {
    const message = createBaseStartChildWfNode();
    message.wfSpecName = object.wfSpecName ?? "";
    message.majorVersion = object.majorVersion ?? undefined;
    message.variables = Object.entries(object.variables ?? {}).reduce<{ [key: string]: VariableAssignment }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = VariableAssignment.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseStartChildWfNode_VariablesEntry(): StartChildWfNode_VariablesEntry {
  return { key: "", value: undefined };
}

export const StartChildWfNode_VariablesEntry = {
  encode(message: StartChildWfNode_VariablesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      VariableAssignment.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartChildWfNode_VariablesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartChildWfNode_VariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = VariableAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StartChildWfNode_VariablesEntry>): StartChildWfNode_VariablesEntry {
    return StartChildWfNode_VariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartChildWfNode_VariablesEntry>): StartChildWfNode_VariablesEntry {
    const message = createBaseStartChildWfNode_VariablesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? VariableAssignment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}
