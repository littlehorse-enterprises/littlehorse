// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v4.23.4
// source: struct_def.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { TypeDefinition } from "./common_wfspec";
import { StructDefId } from "./object_id";

/**
 * A `StructDef` is a versioned metadata object (tenant-scoped) inside LittleHorse
 * that defines the structure and content of a variable value. It allows strong typing.
 */
export interface StructDef {
  /** The id of the `Schema`. This includes the version. */
  id:
    | StructDefId
    | undefined;
  /** Optionally description of the schema. */
  description?:
    | string
    | undefined;
  /** The `StructDef` defines the actual structure of any `Struct` using this `InlineStructDeff`. */
  structDef: InlineStructDef | undefined;
}

/** An `InlineStructDef` is the actual representation of the Schema. */
export interface InlineStructDef {
  /** The fields in this schema. */
  fields: StructFieldDef[];
}

/** A `SchemaFieldDef` defines a field inside a `StructDef`. */
export interface StructFieldDef {
  /** The name of the field. */
  name: string;
  /** Whether the field is optional / nullable. */
  optional: boolean;
  /** The type of the field. */
  fieldType: TypeDefinition | undefined;
}

function createBaseStructDef(): StructDef {
  return { id: undefined, description: undefined, structDef: undefined };
}

export const StructDef = {
  encode(message: StructDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      StructDefId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.description !== undefined) {
      writer.uint32(18).string(message.description);
    }
    if (message.structDef !== undefined) {
      InlineStructDef.encode(message.structDef, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StructDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = StructDefId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.structDef = InlineStructDef.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StructDef>): StructDef {
    return StructDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructDef>): StructDef {
    const message = createBaseStructDef();
    message.id = (object.id !== undefined && object.id !== null) ? StructDefId.fromPartial(object.id) : undefined;
    message.description = object.description ?? undefined;
    message.structDef = (object.structDef !== undefined && object.structDef !== null)
      ? InlineStructDef.fromPartial(object.structDef)
      : undefined;
    return message;
  },
};

function createBaseInlineStructDef(): InlineStructDef {
  return { fields: [] };
}

export const InlineStructDef = {
  encode(message: InlineStructDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.fields) {
      StructFieldDef.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InlineStructDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInlineStructDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fields.push(StructFieldDef.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<InlineStructDef>): InlineStructDef {
    return InlineStructDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InlineStructDef>): InlineStructDef {
    const message = createBaseInlineStructDef();
    message.fields = object.fields?.map((e) => StructFieldDef.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStructFieldDef(): StructFieldDef {
  return { name: "", optional: false, fieldType: undefined };
}

export const StructFieldDef = {
  encode(message: StructFieldDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.optional !== false) {
      writer.uint32(16).bool(message.optional);
    }
    if (message.fieldType !== undefined) {
      TypeDefinition.encode(message.fieldType, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StructFieldDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructFieldDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.optional = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fieldType = TypeDefinition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StructFieldDef>): StructFieldDef {
    return StructFieldDef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructFieldDef>): StructFieldDef {
    const message = createBaseStructFieldDef();
    message.name = object.name ?? "";
    message.optional = object.optional ?? false;
    message.fieldType = (object.fieldType !== undefined && object.fieldType !== null)
      ? TypeDefinition.fromPartial(object.fieldType)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;
